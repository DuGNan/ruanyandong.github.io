<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wing&#39;s Blog</title>
  
  <subtitle>Technology to Change the World</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ruanyandong.github.io/"/>
  <updated>2020-03-01T14:52:25.021Z</updated>
  <id>https://ruanyandong.github.io/</id>
  
  <author>
    <name>阮严冬——Wings</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java并发编程-原子性变量</title>
    <link href="https://ruanyandong.github.io/2020/03/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%98%E9%87%8F/"/>
    <id>https://ruanyandong.github.io/2020/03/01/Java并发编程-原子性变量/</id>
    <published>2020-03-01T14:48:11.000Z</published>
    <updated>2020-03-01T14:52:25.021Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原子性布尔-AtomicBoolean"><a href="#原子性布尔-AtomicBoolean" class="headerlink" title="原子性布尔 AtomicBoolean"></a>原子性布尔 AtomicBoolean</h1><p>AtomicBoolean 类为我们提供了一个可以用原子方式进行读和写的布尔值，它还拥有一些先进的原子性操作，比如 compareAndSet()。AtomicBoolean 类位于 java.util.concurrent.atomic 包，完整类名是为 java.util.concurrent.atomic.AtomicBoolean。</p><h5 id="1、创建一个-AtomicBoolean"><a href="#1、创建一个-AtomicBoolean" class="headerlink" title="1、创建一个 AtomicBoolean"></a>1、创建一个 AtomicBoolean</h5><p>你可以这样创建一个 AtomicBoolean：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AtomicBoolean atomicBoolean = <span class="keyword">new</span> AtomicBoolean();</span><br></pre></td></tr></table></figure></p><p>以上示例新建了一个默认值为 false 的 AtomicBoolean。如果你想要为 AtomicBoolean 实例设置一个显式的初始值，那么你可以将初始值传给 AtomicBoolean 的构造子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AtomicBoolean atomicBoolean = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p><h5 id="2、获取-AtomicBoolean-的值"><a href="#2、获取-AtomicBoolean-的值" class="headerlink" title="2、获取 AtomicBoolean 的值"></a>2、获取 AtomicBoolean 的值</h5><p>你可以通过使用 get() 方法来获取一个 AtomicBoolean 的值。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AtomicBoolean atomicBoolean = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">boolean</span> value = atomicBoolean.get();</span><br></pre></td></tr></table></figure><p>以上代码执行后 value 变量的值将为 true。</p><h5 id="3、设置-AtomicBoolean-的值"><a href="#3、设置-AtomicBoolean-的值" class="headerlink" title="3、设置 AtomicBoolean 的值"></a>3、设置 AtomicBoolean 的值</h5><p>你可以通过使用 set() 方法来设置一个 AtomicBoolean 的值。<br>示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AtomicBoolean atomicBoolean = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);  </span><br><span class="line">  </span><br><span class="line">atomicBoolean.set(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure></p><p>以上代码执行后 AtomicBoolean 的值为 false。</p><h5 id="4、交换-AtomicBoolean-的值"><a href="#4、交换-AtomicBoolean-的值" class="headerlink" title="4、交换 AtomicBoolean 的值"></a>4、交换 AtomicBoolean 的值</h5><p>你可以通过 getAndSet() 方法来交换一个 AtomicBoolean 实例的值。getAndSet() 方法将返回 AtomicBoolean 当前的值，并将为 AtomicBoolean 设置一个新值。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AtomicBoolean atomicBoolean = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">boolean</span> oldValue = atomicBoolean.getAndSet(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>以上代码执行后 oldValue 变量的值为 true，atomicBoolean 实例将持有 false 值。代码成功将 AtomicBoolean 当前值 ture 交换为 false。</p><h5 id="5、比较并设置-AtomicBoolean-的值"><a href="#5、比较并设置-AtomicBoolean-的值" class="headerlink" title="5、比较并设置 AtomicBoolean 的值"></a>5、比较并设置 AtomicBoolean 的值</h5><p>compareAndSet() 方法允许你对 AtomicBoolean 的当前值与一个期望值进行比较，如果当前值等于期望值的话，将会对 AtomicBoolean 设定一个新值。compareAndSet() 方法是原子性的，因此在同一时间之内有单个线程执行它。因此 compareAndSet() 方法可被用于一些类似于锁的同步的简单实现。以下是一个 compareAndSet() 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AtomicBoolean atomicBoolean = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">boolean</span> expectedValue = <span class="keyword">true</span>;  </span><br><span class="line"><span class="keyword">boolean</span> newValue      = <span class="keyword">false</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">boolean</span> wasNewValueSet = atomicBoolean.compareAndSet(  </span><br><span class="line">    expectedValue, newValue);</span><br></pre></td></tr></table></figure><p>本示例对 AtomicBoolean 的当前值与 true 值进行比较，如果相等，将 AtomicBoolean 的值更新为 false。</p><h1 id="原子性整型-AtomicInteger"><a href="#原子性整型-AtomicInteger" class="headerlink" title="原子性整型 AtomicInteger"></a>原子性整型 AtomicInteger</h1><p>AtomicInteger 类为我们提供了一个可以进行原子性读和写操作的 int 变量，它还包含一系列先进的原子性操作，比如 compareAndSet()。AtomicInteger 类位于 java.util.concurrent.atomic 包，因此其完整类名为 java.util.concurrent.atomic.AtomicInteger。</p><h5 id="1、创建一个-AtomicInteger"><a href="#1、创建一个-AtomicInteger" class="headerlink" title="1、创建一个 AtomicInteger"></a>1、创建一个 AtomicInteger</h5><p>创建一个 AtomicInteger 示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br></pre></td></tr></table></figure></p><p>本示例将创建一个初始值为 0 的 AtomicInteger。如果你想要创建一个给定初始值的 AtomicInteger，你可以这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">123</span>);</span><br></pre></td></tr></table></figure></p><p>本示例将 123 作为参数传给 AtomicInteger 的构造子，它将设置 AtomicInteger 实例的初始值为 123。</p><h5 id="2、获取-AtomicInteger-的值"><a href="#2、获取-AtomicInteger-的值" class="headerlink" title="2、获取 AtomicInteger 的值"></a>2、获取 AtomicInteger 的值</h5><p>你可以使用 get() 方法获取 AtomicInteger 实例的值。示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">123</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> theValue = atomicInteger.get();</span><br></pre></td></tr></table></figure></p><h5 id="3、设置-AtomicInteger-的值"><a href="#3、设置-AtomicInteger-的值" class="headerlink" title="3、设置 AtomicInteger 的值"></a>3、设置 AtomicInteger 的值</h5><p>你可以通过 set() 方法对 AtomicInteger 的值进行重新设置。以下是 AtomicInteger.set() 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">123</span>);  </span><br><span class="line">  </span><br><span class="line">atomicInteger.set(<span class="number">234</span>);</span><br></pre></td></tr></table></figure><p>以上示例创建了一个初始值为 123 的 AtomicInteger，而在第二行将其值更新为 234。</p><h5 id="4、比较并设置-AtomicInteger-的值"><a href="#4、比较并设置-AtomicInteger-的值" class="headerlink" title="4、比较并设置 AtomicInteger 的值"></a>4、比较并设置 AtomicInteger 的值</h5><p>AtomicInteger 类也通过了一个原子性的 compareAndSet() 方法。这一方法将 AtomicInteger 实例的当前值与期望值进行比较，如果二者相等，为 AtomicInteger 实例设置一个新值。AtomicInteger.compareAndSet() 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">123</span>);  </span><br><span class="line"><span class="keyword">int</span> expectedValue = <span class="number">123</span>;  </span><br><span class="line"><span class="keyword">int</span> newValue      = <span class="number">234</span>;  </span><br><span class="line">atomicInteger.compareAndSet(expectedValue, newValue);</span><br></pre></td></tr></table></figure><p>本示例首先新建一个初始值为 123 的 AtomicInteger 实例。然后将 AtomicInteger 与期望值 123 进行比较，如果相等，将 AtomicInteger 的值更新为 234。</p><h5 id="5、增加-AtomicInteger-值"><a href="#5、增加-AtomicInteger-值" class="headerlink" title="5、增加 AtomicInteger 值"></a>5、增加 AtomicInteger 值</h5><p>AtomicInteger 类包含有一些方法，通过它们你可以增加 AtomicInteger 的值，并获取其值。这些方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addAndGet()</span><br><span class="line">getAndAdd()</span><br><span class="line">getAndIncrement()</span><br><span class="line">incrementAndGet()</span><br></pre></td></tr></table></figure></p><p>第一个 addAndGet() 方法给 AtomicInteger 增加了一个值，然后返回增加后的值。getAndAdd() 方法为 AtomicInteger 增加了一个值，但返回的是增加以前的 AtomicInteger 的值。具体使用哪一个取决于你的应用场景。以下是这两种方法的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();  </span><br><span class="line">System.out.println(atomicInteger.getAndAdd(<span class="number">10</span>));  </span><br><span class="line">System.out.println(atomicInteger.addAndGet(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><p>本示例将打印出 0 和 20。例子中，第二行拿到的是加 10 之前的 AtomicInteger 的值。加 10 之前的值是 0。第三行将 AtomicInteger 的值再加 10，并返回加操作之后的值。该值现在是为 20。你当然也可以使用这俩方法为 AtomicInteger 添加负值。结果实际是一个减法操作。getAndIncrement() 和 incrementAndGet() 方法类似于 getAndAdd() 和 addAndGet()，但每次只将 AtomicInteger 的值加 1。</p><h5 id="6、减小-AtomicInteger-的值"><a href="#6、减小-AtomicInteger-的值" class="headerlink" title="6、减小 AtomicInteger 的值"></a>6、减小 AtomicInteger 的值</h5><p>AtomicInteger 类还提供了一些减小 AtomicInteger 的值的原子性方法。这些方法是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decrementAndGet()</span><br><span class="line">getAndDecrement()</span><br></pre></td></tr></table></figure></p><p>decrementAndGet() 将 AtomicInteger 的值减一，并返回减一后的值。getAndDecrement() 也将 AtomicInteger 的值减一，但它返回的是减一之前的值。</p><h1 id="原子性长整型-AtomicLong"><a href="#原子性长整型-AtomicLong" class="headerlink" title="原子性长整型 AtomicLong"></a>原子性长整型 AtomicLong</h1><p>AtomicLong 类为我们提供了一个可以进行原子性读和写操作的 long 变量，它还包含一系列先进的原子性操作，比如 compareAndSet()。AtomicLong 类位于 java.util.concurrent.atomic 包，因此其完整类名为 java.util.concurrent.atomic.AtomicLong。</p><h5 id="1、创建一个-AtomicLong"><a href="#1、创建一个-AtomicLong" class="headerlink" title="1、创建一个 AtomicLong"></a>1、创建一个 AtomicLong</h5><p>创建一个 AtomicLong 如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong();</span><br></pre></td></tr></table></figure></p><p>将创建一个初始值为 0 的 AtomicLong。如果你想创建一个指定初始值的 AtomicLong，可以：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong(<span class="number">123</span>);</span><br></pre></td></tr></table></figure></p><p>本示例将 123 作为参数传递给 AtomicLong 的构造子，后者将 AtomicLong 实例的初始值设置为 123。</p><h5 id="2、获取-AtomicLong-的值"><a href="#2、获取-AtomicLong-的值" class="headerlink" title="2、获取 AtomicLong 的值"></a>2、获取 AtomicLong 的值</h5><p>你可以通过 get() 方法获取 AtomicLong 的值。AtomicLong.get() 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong(<span class="number">123</span>);  </span><br><span class="line"><span class="keyword">long</span> theValue = atomicLong.get();</span><br></pre></td></tr></table></figure><h5 id="3、设置-AtomicLong-的值"><a href="#3、设置-AtomicLong-的值" class="headerlink" title="3、设置 AtomicLong 的值"></a>3、设置 AtomicLong 的值</h5><p>你可以通过 set() 方法设置 AtomicLong 实例的值。一个 AtomicLong.set() 的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong(<span class="number">123</span>);  </span><br><span class="line">atomicLong.set(<span class="number">234</span>);</span><br></pre></td></tr></table></figure><p>本示例新建了一个初始值为 123 的 AtomicLong，第二行将其值设置为 234。</p><h5 id="4、比较并设置-AtomicLong-的值"><a href="#4、比较并设置-AtomicLong-的值" class="headerlink" title="4、比较并设置 AtomicLong 的值"></a>4、比较并设置 AtomicLong 的值</h5><p>AtomicLong 类也有一个原子性的 compareAndSet() 方法。这一方法将 AtomicLong 实例的当前值与一个期望值进行比较，如果两种相等，为 AtomicLong 实例设置一个新值。AtomicLong.compareAndSet() 使用示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong(<span class="number">123</span>);  </span><br><span class="line"><span class="keyword">long</span> expectedValue = <span class="number">123</span>;  </span><br><span class="line"><span class="keyword">long</span> newValue      = <span class="number">234</span>;  </span><br><span class="line">atomicLong.compareAndSet(expectedValue, newValue);</span><br></pre></td></tr></table></figure></p><p>本示例新建了一个初始值为 123 的 AtomicLong。然后将 AtomicLong 的当前值与期望值 123 进行比较，如果相等的话，AtomicLong 的新值将变为 234。</p><h5 id="5、增加-AtomicLong-值"><a href="#5、增加-AtomicLong-值" class="headerlink" title="5、增加 AtomicLong 值"></a>5、增加 AtomicLong 值</h5><p>AtomicLong 具备一些能够增加 AtomicLong 的值并返回自身值的方法。这些方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addAndGet()</span><br><span class="line">getAndAdd()</span><br><span class="line">getAndIncrement()</span><br><span class="line">incrementAndGet()</span><br></pre></td></tr></table></figure></p><p>第一个方法 addAndGet() 将 AtomicLong 的值加一个数字，并返回增加后的值。第二个方法 getAndAdd() 也将 AtomicLong 的值加一个数字，但返回的是增加前的 AtomicLong 的值。具体使用哪一个取决于你自己的场景。示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong();  </span><br><span class="line">System.out.println(atomicLong.getAndAdd(<span class="number">10</span>));  </span><br><span class="line">System.out.println(atomicLong.addAndGet(<span class="number">10</span>));</span><br></pre></td></tr></table></figure></p><p>本示例将打印出 0 和 20。例子中，第二行拿到的是加 10 之前的 AtomicLong 的值。加 10 之前的值是 0。第三行将 AtomicLong 的值再加 10，并返回加操作之后的值。该值现在是为 20。你当然也可以使用这俩方法为 AtomicLong 添加负值。结果实际是一个减法操作。getAndIncrement() 和 incrementAndGet() 方法类似于 getAndAdd() 和 addAndGet()，但每次只将 AtomicLong 的值加 1。</p><h5 id="6、减小-AtomicLong-的值"><a href="#6、减小-AtomicLong-的值" class="headerlink" title="6、减小 AtomicLong 的值"></a>6、减小 AtomicLong 的值</h5><p>AtomicLong 类还提供了一些减小 AtomicLong 的值的原子性方法。这些方法是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decrementAndGet()</span><br><span class="line">getAndDecrement()</span><br></pre></td></tr></table></figure></p><p>decrementAndGet() 将 AtomicLong 的值减一，并返回减一后的值。getAndDecrement() 也将 AtomicLong 的值减一，但它返回的是减一之前的值。</p><h1 id="原子性引用型-AtomicReference"><a href="#原子性引用型-AtomicReference" class="headerlink" title="原子性引用型 AtomicReference"></a>原子性引用型 AtomicReference</h1><p>AtomicReference 提供了一个可以被原子性读和写的对象引用变量。原子性的意思是多个想要改变同一个 AtomicReference 的线程不会导致 AtomicReference 处于不一致的状态。AtomicReference 还有一个 compareAndSet() 方法，通过它你可以将当前引用于一个期望值(引用)进行比较，如果相等，在该 AtomicReference 对象内部设置一个新的引用。</p><h5 id="1、创建一个-AtomicReference"><a href="#1、创建一个-AtomicReference" class="headerlink" title="1、创建一个 AtomicReference"></a>1、创建一个 AtomicReference</h5><p>创建 AtomicReference 如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AtomicReference atomicReference = <span class="keyword">new</span> AtomicReference();</span><br></pre></td></tr></table></figure></p><p>如果你需要使用一个指定引用创建 AtomicReference，可以：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String initialReference = <span class="string">"the initially referenced string"</span>;  </span><br><span class="line">AtomicReference atomicReference = <span class="keyword">new</span> AtomicReference(initialReference);</span><br></pre></td></tr></table></figure></p><h5 id="2、创建泛型-AtomicReference"><a href="#2、创建泛型-AtomicReference" class="headerlink" title="2、创建泛型 AtomicReference"></a>2、创建泛型 AtomicReference</h5><p>你可以使用 Java 泛型来创建一个泛型 AtomicReference。示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AtomicReference&lt;String&gt; atomicStringReference =  </span><br><span class="line">    <span class="keyword">new</span> AtomicReference&lt;String&gt;();</span><br></pre></td></tr></table></figure></p><p>你也可以为泛型 AtomicReference 设置一个初始值。示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String initialReference = <span class="string">"the initially referenced string"</span>;  </span><br><span class="line">AtomicReference&lt;String&gt; atomicStringReference =  </span><br><span class="line">    <span class="keyword">new</span> AtomicReference&lt;String&gt;(initialReference);</span><br></pre></td></tr></table></figure></p><h5 id="3、获取-AtomicReference-引用"><a href="#3、获取-AtomicReference-引用" class="headerlink" title="3、获取 AtomicReference 引用"></a>3、获取 AtomicReference 引用</h5><p>你可以通过 AtomicReference 的 get() 方法来获取保存在 AtomicReference 里的引用。如果你的 AtomicReference 是非泛型的，get() 方法将返回一个 Object 类型的引用。如果是泛型化的，get() 将返回你创建 AtomicReference 时声明的那个类型。先来看一个非泛型的 AtomicReference get() 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AtomicReference atomicReference = <span class="keyword">new</span> AtomicReference(<span class="string">"first value referenced"</span>);  </span><br><span class="line">String reference = (String) atomicReference.get();</span><br></pre></td></tr></table></figure><p>注意如何对 get() 方法返回的引用强制转换为 String。泛型化的 AtomicReference 示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AtomicReference&lt;String&gt; atomicReference =   </span><br><span class="line">     <span class="keyword">new</span> AtomicReference&lt;String&gt;(<span class="string">"first value referenced"</span>);  </span><br><span class="line">String reference = atomicReference.get();</span><br></pre></td></tr></table></figure></p><p>编译器知道了引用的类型，所以我们无需再对 get() 返回的引用进行强制转换了。</p><h5 id="4、设置-AtomicReference-引用"><a href="#4、设置-AtomicReference-引用" class="headerlink" title="4、设置 AtomicReference 引用"></a>4、设置 AtomicReference 引用</h5><p>你可以使用 get() 方法对 AtomicReference 里边保存的引用进行设置。如果你定义的是一个非泛型 AtomicReference，set() 将会以一个 Object 引用作为参数。如果是泛型化的 AtomicReference，set() 方法将只接受你定义给的类型。AtomicReference set() 示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AtomicReference atomicReference =   </span><br><span class="line">     <span class="keyword">new</span> AtomicReference();  </span><br><span class="line">      </span><br><span class="line">atomicReference.set(<span class="string">"New object referenced"</span>);</span><br></pre></td></tr></table></figure></p><p>这个看起来非泛型和泛型化的没啥区别。真正的区别在于编译器将对你能够设置给一个泛型化的 AtomicReference 参数类型进行限制。</p><h5 id="5、比较并设置-AtomicReference-引用"><a href="#5、比较并设置-AtomicReference-引用" class="headerlink" title="5、比较并设置 AtomicReference 引用"></a>5、比较并设置 AtomicReference 引用</h5><p>AtomicReference 类具备了一个很有用的方法：compareAndSet()。compareAndSet() 可以将保存在 AtomicReference 里的引用于一个期望引用进行比较，如果两个引用是一样的(并非 equals() 的相等，而是 == 的一样)，将会给 AtomicReference 实例设置一个新的引用。</p><p>如果 compareAndSet() 为 AtomicReference 设置了一个新的引用，compareAndSet() 将返回 true。否则 compareAndSet() 返回 false。AtomicReference compareAndSet() 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String initialReference = <span class="string">"initial value referenced"</span>;  </span><br><span class="line">  </span><br><span class="line">AtomicReference&lt;String&gt; atomicStringReference =  </span><br><span class="line">    <span class="keyword">new</span> AtomicReference&lt;String&gt;(initialReference);  </span><br><span class="line">  </span><br><span class="line">String newReference = <span class="string">"new value referenced"</span>;  </span><br><span class="line"><span class="keyword">boolean</span> exchanged = atomicStringReference.compareAndSet(initialReference, newReference);  </span><br><span class="line">System.out.println(<span class="string">"exchanged: "</span> + exchanged);  </span><br><span class="line">  </span><br><span class="line">exchanged = atomicStringReference.compareAndSet(initialReference, newReference);  </span><br><span class="line">System.out.println(<span class="string">"exchanged: "</span> + exchanged);</span><br></pre></td></tr></table></figure><p>本示例创建了一个带有一个初始引用的泛型化的 AtomicReference。之后两次调用 comparesAndSet()来对存储值和期望值进行对比，如果二者一致，为 AtomicReference 设置一个新的引用。第一次比较，存储的引用(initialReference)和期望的引用(initialReference)一致，所以一个新的引用(newReference)被设置给 AtomicReference，compareAndSet() 方法返回 true。第二次比较时，存储的引用(newReference)和期望的引用(initialReference)不一致，因此新的引用没有被设置给 AtomicReference，compareAndSet() 方法返回 false。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原子性布尔-AtomicBoolean&quot;&gt;&lt;a href=&quot;#原子性布尔-AtomicBoolean&quot; class=&quot;headerlink&quot; title=&quot;原子性布尔 AtomicBoolean&quot;&gt;&lt;/a&gt;原子性布尔 AtomicBoolean&lt;/h1&gt;&lt;p&gt;At
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>不使用synchronized和lock，如何实现一个线程安全的单例？</title>
    <link href="https://ruanyandong.github.io/2020/03/01/%E4%B8%8D%E4%BD%BF%E7%94%A8synchronized%E5%92%8Clock%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%EF%BC%9F/"/>
    <id>https://ruanyandong.github.io/2020/03/01/不使用synchronized和lock，如何实现一个线程安全的单例？/</id>
    <published>2020-03-01T14:19:25.000Z</published>
    <updated>2020-03-01T14:44:41.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>单例，大家肯定都不陌生，这是Java中很重要的一个设计模式。稍微了解一点单例的朋友也都知道实现单例是要考虑并发问题的，一般情况下，我们都会使用synchronized来保证线程安全。</p><p>那么，如果有这样一道面试题：不使用synchronized和lock，如何实现一个线程安全的单例？你该如何回答？</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h4 id="C类应聘者：可以使用饿汉模式实现单例"><a href="#C类应聘者：可以使用饿汉模式实现单例" class="headerlink" title="C类应聘者：可以使用饿汉模式实现单例"></a>C类应聘者：可以使用饿汉模式实现单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="还有部分程序员可以想到饿汉的变种"><a href="#还有部分程序员可以想到饿汉的变种" class="headerlink" title="还有部分程序员可以想到饿汉的变种"></a>还有部分程序员可以想到饿汉的变种</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用static来定义静态成员变量或静态代码，借助Class的类加载机制实现线程安全单例。</p><h4 id="B类应聘者：除了以上两种方式，还有一种办法，就是通过静态内部类来实现，代码如下："><a href="#B类应聘者：除了以上两种方式，还有一种办法，就是通过静态内部类来实现，代码如下：" class="headerlink" title="B类应聘者：除了以上两种方式，还有一种办法，就是通过静态内部类来实现，代码如下："></a>B类应聘者：除了以上两种方式，还有一种办法，就是通过静态内部类来实现，代码如下：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式相比前面两种有所优化，就是使用了lazy-loading。Singleton类被装载了，但是instance并没有立即初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。</p><h4 id="A类应聘者：除了以上方式，还可以使用枚举的方式"><a href="#A类应聘者：除了以上方式，还可以使用枚举的方式" class="headerlink" title="A类应聘者：除了以上方式，还可以使用枚举的方式"></a>A类应聘者：除了以上方式，还可以使用枚举的方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒。</p><ul><li>以上几种答案，其实现原理都是利用借助了类加载的时候初始化单例。即借助了ClassLoader的线程安全机制。</li><li>所谓ClassLoader的线程安全机制，就是ClassLoader的loadClass方法在加载类的时候使用了synchronized关键字。也正是因为这样， 除非被重写，这个方法默认在整个装载过程中都是同步的，也就是保证了线程安全。</li><li>所以，以上各种方法，虽然并没有显示的使用synchronized，但是还是其底层实现原理还是用到了synchronized。</li></ul><h4 id="A类应聘者：还可以使用Java并发包中的Lock实现"><a href="#A类应聘者：还可以使用Java并发包中的Lock实现" class="headerlink" title="A类应聘者：还可以使用Java并发包中的Lock实现"></a>A类应聘者：还可以使用Java并发包中的Lock实现</h4><p>面试官：本质上还是在使用锁，不使用锁的话，有办法实现线程安全的单例吗？</p><h4 id="A-类面试者：有的，那就是使用CAS。"><a href="#A-类面试者：有的，那就是使用CAS。" class="headerlink" title="A+类面试者：有的，那就是使用CAS。"></a>A+类面试者：有的，那就是使用CAS。</h4><p>CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。实现单例的方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReference&lt;Singleton&gt; INSTANCE = <span class="keyword">new</span> AtomicReference&lt;Singleton&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Singleton singleton = INSTANCE.get();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != singleton) &#123;</span><br><span class="line">                <span class="keyword">return</span> singleton;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">            <span class="keyword">if</span> (INSTANCE.compareAndSet(<span class="keyword">null</span>, singleton)) &#123;</span><br><span class="line">                <span class="keyword">return</span> singleton;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>面试官：这种方式实现的单例有啥优缺点吗？</p><p>A++类面试者：</p><ul><li>用CAS的好处在于不需要使用传统的锁机制来保证线程安全,CAS是一种基于忙等待的算法,依赖底层硬件的实现,相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度。</li><li>CAS的一个重要缺点在于如果忙等待一直执行不成功(一直在死循环中),会对CPU造成较大的执行开销。</li><li>另外，如果N个线程同时执行到singleton = new Singleton();的时候，会有大量对象创建，很可能导致内存溢出。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;单例，大家肯定都不陌生，这是Java中很重要的一个设计模式。稍微了解一点单例的朋友也都知道实现单例是要考虑并发问题的，一般情况下，我们都会使
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>生产者与消费者问题</title>
    <link href="https://ruanyandong.github.io/2020/02/27/%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/"/>
    <id>https://ruanyandong.github.io/2020/02/27/生产者与消费者问题/</id>
    <published>2020-02-27T15:04:49.000Z</published>
    <updated>2020-02-27T15:18:12.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><h5 id="线程模型中的经典问题"><a href="#线程模型中的经典问题" class="headerlink" title="线程模型中的经典问题"></a>线程模型中的经典问题</h5><p>生产者和消费者分别为两个线程（或进程），共享一个固定大小的缓冲区（存储空间），生产者往存储空间中添加产品，消费者从存储空间中取走产品，当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。<br><img src="https://img-blog.csdnimg.cn/20200227150132625.png" alt="在这里插入图片描述"></p><h5 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h5><ul><li>制造数据并且在缓冲区未满时写入，否则等待；</li><li>在缓冲区为空的情况下写入数据并唤醒消费者读取数据；<h5 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h5></li><li>在缓冲区不为空时读出数据，否则等待；</li><li>在缓冲区满的情况下消费数据并唤醒生产者写入数据。</li></ul><h5 id="问题关键"><a href="#问题关键" class="headerlink" title="问题关键"></a>问题关键</h5><ul><li><p>对缓冲区进行互斥处理，缓冲区为临界区，防止竞争；</p></li><li><p>正确实现生产者和消费者的同步关系，防止出现死锁。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="wait-和notify-方法的实现"><a href="#wait-和notify-方法的实现" class="headerlink" title="wait()和notify()方法的实现"></a>wait()和notify()方法的实现</h2><p>缓冲区满和为空时都调用wait()方法等待，当生产者生产了一个产品或者消费者消费了一个产品之后会唤醒所有线程。</p><h5 id="关于wait-和notify"><a href="#关于wait-和notify" class="headerlink" title="关于wait()和notify()"></a>关于wait()和notify()</h5></li><li><p>wait(): 调用任何对象的wait()方法会让当前线程进入等待状态，会把当前的锁释放，然后让出CPU，直到另一个线程调用同一个对象的notify()或notifyAll()方法。</p></li><li><p>notify(): 唤醒因调用这个对象wait()方法而阻塞的线程，然后继续往下执行，直到执行完退出对象锁锁住的区域（synchronized修饰的代码块）后再释放锁。</p></li><li><p>wait()/notify()直接隶属于Object 类，所有对象都拥有这一对方法。</p></li><li><p>这一对方法却必须在 synchronized方法或块中调用，只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException异常。</p></li><li><p>调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题</p></li><li><p>除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。</p></li><li><p>wait()和notify()必须成对存在。</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录产品的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 限定产品的总数量为10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FULL = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 锁对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK = <span class="string">"LOCK"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerConsumer producerConsumer = <span class="keyword">new</span> ProducerConsumer();</span><br><span class="line">        <span class="comment">// 线程池执行</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (count == FULL) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            LOCK.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count++;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"生产者生产，目前总共有"</span> + count);</span><br><span class="line">                    LOCK.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            LOCK.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count--;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"消费者消费，目前总共有"</span> + count);</span><br><span class="line">                    LOCK.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>生产者生产，目前总共有<span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>消费者消费，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>生产者生产，目前总共有<span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>消费者消费，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>生产者生产，目前总共有<span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>消费者消费，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>消费者消费，目前总共有<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="阻塞队列BlockingQueue的实现"><a href="#阻塞队列BlockingQueue的实现" class="headerlink" title="阻塞队列BlockingQueue的实现"></a>阻塞队列BlockingQueue的实现</h2><p>BlockingQueue即阻塞队列，在某些情况下对阻塞队列的访问可能会造成阻塞。</p><h5 id="被阻塞的情况主要有如下两种"><a href="#被阻塞的情况主要有如下两种" class="headerlink" title="被阻塞的情况主要有如下两种:"></a>被阻塞的情况主要有如下两种:</h5><ul><li>当队列满了的时候进行入队列操作</li><li>当队列空了的时候进行出队列操作</li><li>当一个线程对已经满了的阻塞队列进行入队操作时会阻塞，除非有另外一个线程进行了出队操作，当一个线程对一个空的阻塞队列进行出队操作时也会阻塞，除非有另外一个线程进行了入队操作。</li><li>阻塞队列是线程安全的。</li></ul><h5 id="BlockingQueue接口的一些方法"><a href="#BlockingQueue接口的一些方法" class="headerlink" title="BlockingQueue接口的一些方法:"></a>BlockingQueue接口的一些方法:</h5><table><thead><tr><th>操作</th><th>抛异常</th><th>特定值</th><th>阻塞</th><th>超时</th></tr></thead><tbody><tr><td>插入</td><td>add(o)</td><td>offer(o)</td><td>put(o)</td><td>offer(o, timeout, timeunit)</td></tr><tr><td>移除</td><td>remove(o)</td><td>poll(o)</td><td>take(o)</td><td>poll(timeout, timeunit)</td></tr><tr><td>检查</td><td>element(o)</td><td>peek(o)</td><td></td></tr></tbody></table><p>这四类方法分别对应的是：</p><ul><li>ThrowsException：如果操作不能马上进行，则抛出异常</li><li>SpecialValue：如果操作不能马上进行，将会返回一个特殊的值，一般是true或者false</li><li>Blocks:如果操作不能马上进行，操作会被阻塞</li><li>TimesOut:如果操作不能马上进行，操作会被阻塞指定的时间，如果指定时间没执行，则返回一个特殊值，一般是true或者false<h5 id="BlockingQueue方法对比"><a href="#BlockingQueue方法对比" class="headerlink" title="BlockingQueue方法对比"></a>BlockingQueue方法对比</h5>|方法|描述|<br>|–|–|<br>|boolean add(E e)|    如果可能，向队列中添加一个元素。否则，它抛出异常。|<br>|boolean offer(E e)|    如果能添加元素，则将元素添加到队列中，而不抛出异常。 它在失败时返回false，在成功时返回true。|<br>|E remove()|    删除队列的头。如果队列为空，它会抛出异常。此方法返回已移除的项目。|<br>|E poll()|    从队列中删除元素。如果队列为空而不是抛出异常，则返回null。|<br>|Eelement()|    查看队列的头，而不从队列中删除它。 如果队列为空，它会抛出异常。|<br>|E peek()|    查看队列，如果队列为空而不是抛出异常，则返回null。|<br>|void put(E e)|put方法只存在于<strong><strong>BlockingQueue类型的阻塞队列中，使用put方法向已满的队列添加新元素时，代码会阻塞在put处|<br>|E take()|take方法只存在于</strong></strong>BlockingQueue类型的阻塞队列中，获得空队列的头部元素时，会阻塞在获取的位置|</li></ul><p>下面看由阻塞队列实现的生产者消费者模型,这里使用take()和put()方法，消费者和消费者之间不存在同步，所以会出现连续生成和连续消费的现象。</p><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录产品的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerConsumer producerConsumer = <span class="keyword">new</span> ProducerConsumer();</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    blockingQueue.put(<span class="number">1</span>);</span><br><span class="line">                    count++;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">"生产者生产，目前总共有"</span> + count);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    blockingQueue.take();</span><br><span class="line">                    count--;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">"消费者消费，目前总共有"</span> + count);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可重入锁ReentrantLock的实现"><a href="#可重入锁ReentrantLock的实现" class="headerlink" title="可重入锁ReentrantLock的实现"></a>可重入锁ReentrantLock的实现</h2><h5 id="ReentrantLock简介"><a href="#ReentrantLock简介" class="headerlink" title="ReentrantLock简介"></a>ReentrantLock简介</h5><ul><li>通过ReentrantLock对象的lock()方法和unlock()方法实现了对锁的显示控制，而synchronize()则是对锁的隐性控制。</li><li>可重入锁，也叫做递归锁，简单来说，该锁维护这一个与获取锁相关的计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，函数调用结束计数器就减1，然后锁需要被释放两次才能获得真正释放。已经获取锁的线程进入其他需要相同锁的同步代码块不会被阻塞。</li><li>从Java 5开始，引入了一个高级的处理并发的java.util.concurrent包，它提供了大量更高级的并发功能，能大大简化多线程程序的编写。</li><li>Java语言直接提供了synchronized关键字用于加锁，但这种锁一是很重，二是获取时必须一直等待，没有额外的尝试机制。</li></ul><p>java.util.concurrent.locks包提供的ReentrantLock用于替代synchronized加锁，我们来看一下传统的synchronized代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用ReentrantLock替代，可以把代码改造为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>因为synchronized是Java语言层面提供的语法，所以我们不需要考虑异常，而ReentrantLock是Java代码实现的锁，我们就必须先获取锁，然后在finally中正确释放锁。</li><li>顾名思义，ReentrantLock是可重入锁，它和synchronized一样，一个线程可以多次获取同一个锁。</li><li>和synchronized不同的是，ReentrantLock可以尝试获取锁：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上述代码在尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，tryLock()返回false，程序就可以做一些额外处理，而不是无限等待下去。</li><li>所以，使用ReentrantLock比直接使用synchronized更安全，线程在tryLock()失败的时候不会导致死锁。</li><li>ReentrantLock可以替代synchronized进行同步；</li><li>ReentrantLock获取锁更安全；</li><li>必须先获取到锁，再进入try {…}代码块，最后使用finally保证释放锁；</li><li>可以使用tryLock()尝试获取锁。<h5 id="Condition简介"><a href="#Condition简介" class="headerlink" title="Condition简介"></a>Condition简介</h5>synchronized可以配合wait和notify实现线程在条件不满足时等待，条件满足时唤醒，用ReentrantLock我们怎么编写wait和notify的功能呢？</li></ul><p>答案是使用Condition对象来实现wait和notify的功能。</p><p>我们仍然以TaskQueue为例，把前面用synchronized实现的功能通过ReentrantLock和Condition来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.add(s);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> queue.remove();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，使用Condition时，引用的Condition对象必须从Lock实例的newCondition()返回，这样才能获得一个绑定了Lock实例的Condition实例。</p><p>Condition提供的await()、signal()、signalAll()原理和synchronized锁对象的wait()、notify()、notifyAll()是一致的，并且其行为也是一样的：</p><ul><li><p>await()会释放当前锁，进入等待状态；</p></li><li><p>signal()会唤醒某个等待线程；</p></li><li><p>signalAll()会唤醒所有等待线程；</p></li></ul><p>唤醒线程从await()返回后需要重新获得锁。</p><p>此外，和tryLock()类似，await()可以在等待指定时间后，如果还没有被其他线程通过signal()或signalAll()唤醒，可以自己醒来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition.await(<span class="number">1</span>, TimeUnit.SECOND)) &#123;</span><br><span class="line">    <span class="comment">// 被其他线程唤醒</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 指定时间内没有被其他线程唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，使用Condition配合Lock，我们可以实现更灵活的线程同步。</p><h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录产品的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer FULL = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//创建一个锁对象</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//创建两个条件变量，一个为缓冲区已满，一个为缓冲区非空</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition alreadyFull = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerConsumer producerConsumer = <span class="keyword">new</span> ProducerConsumer();</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//获取锁</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (count == FULL) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            alreadyFull.await();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count++;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">"生产者生产，目前总共有"</span> + count);</span><br><span class="line">                    <span class="comment">//唤醒消费者</span></span><br><span class="line">                    notEmpty.signal();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//释放锁</span></span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            notEmpty.await();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count--;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">"消费者消费，目前总共有"</span> + count);</span><br><span class="line">                    alreadyFull.signal();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号量Semaphore的实现"><a href="#信号量Semaphore的实现" class="headerlink" title="信号量Semaphore的实现"></a>信号量Semaphore的实现</h2><ul><li>Semaphore(信号量)是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源，在操作系统中是一个非常重要的问题，可以用来解决哲学家就餐问题。</li><li>Java中的Semaphore维护了一个许可集，一开始先设定这个许可集的数量，可以使用acquire()方法获得一个许可，当许可不足时会被阻塞，release()添加一个许可。在下列代码中，还加入了另外一个mutex信号量，维护生产者消费者之间的同步关系，保证生产者和消费者之间的交替进行<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录产品的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//创建三个信号量</span></span><br><span class="line">    <span class="keyword">final</span> Semaphore producer = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">final</span> Semaphore consumer = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">final</span> Semaphore mutex = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerConsumer producerConsumer = <span class="keyword">new</span> ProducerConsumer();</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    producer.acquire();</span><br><span class="line">                    mutex.acquire();</span><br><span class="line">                    count++;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">"生产者生产，目前总共有"</span> + count);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mutex.release();</span><br><span class="line">                    consumer.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    consumer.acquire();</span><br><span class="line">                    mutex.acquire();</span><br><span class="line">                    count--;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">"消费者消费，目前总共有"</span> + count);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mutex.release();</span><br><span class="line">                    producer.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="管道输入输出流PipedInputStream和PipedOutputStream实现"><a href="#管道输入输出流PipedInputStream和PipedOutputStream实现" class="headerlink" title="管道输入输出流PipedInputStream和PipedOutputStream实现"></a>管道输入输出流PipedInputStream和PipedOutputStream实现</h2><ul><li>在java的io包下，PipedOutputStream和PipedInputStream分别是管道输出流和管道输入流。它们的作用是让多线程可以通过管道进行线程间的通讯。在使用管道通信时，必须将PipedOutputStream和PipedInputStream配套使用。</li><li>使用方法：先创建一个管道输入流和管道输出流，然后将输入流和输出流进行连接，用生产者线程往管道输出流中写入数据，消费者在管道输入流中读取数据，这样就可以实现了不同线程间的相互通讯，但是这种方式在生产者和生产者、消费者和消费者之间不能保证同步，也就是说在一个生产者和一个消费者的情况下是可以生产者和消费者之间交替运行的，多个生成者和多个消费者者之间则不行<h5 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> PipedInputStream pis = <span class="keyword">new</span> PipedInputStream();</span><br><span class="line">    <span class="keyword">final</span> PipedOutputStream pos = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pis.connect(pos);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerConsumer producerConsumer = <span class="keyword">new</span> ProducerConsumer();</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">int</span> num = (<span class="keyword">int</span>) (Math.random() * <span class="number">255</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"生产者生产了一个数字，该数字为： "</span> + num);</span><br><span class="line">                    pos.write(num);</span><br><span class="line">                    pos.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    pos.close();</span><br><span class="line">                    pis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">int</span> num = pis.read();</span><br><span class="line">                    System.out.println(<span class="string">"消费者消费了一个数字，该数字为："</span> + num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    pos.close();</span><br><span class="line">                    pis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;h5 id=&quot;线程模型中的经典问题&quot;&gt;&lt;a href=&quot;#线程模型中的经典问题&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git reset 和 revert</title>
    <link href="https://ruanyandong.github.io/2020/02/17/git-reset-%E5%92%8C-revert/"/>
    <id>https://ruanyandong.github.io/2020/02/17/git-reset-和-revert/</id>
    <published>2020-02-17T13:30:15.000Z</published>
    <updated>2020-02-17T13:33:16.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在利用git实现多人合作开发程序的过程中，有时会出现错误提交的情况，此时希望能撤销提交操作，让程序回到提交前的样子，本文总结了两种方法：reset（重置）、revert（恢复）。</p><p>先简单说一下，在提交到远程库之前我们使用<strong>git reset</strong> 命令完全可以满足我们 撤销操作的需求，如果操作已经提交到远程库，那只好使用 <strong>git revert</strong> 来提交一个新的撤销操作 撤销 需要撤销的那次commit。</p><h1 id="git的工作流"><a href="#git的工作流" class="headerlink" title="git的工作流"></a>git的工作流</h1><ul><li><p><strong>工作区</strong>：即自己当前分支所修改的代码，git add xx 之前的！不包括 git add xx 和 git commit xxx 之后的。</p></li><li><p><strong>暂存区</strong>：已经 git add xxx 进去，且未 git commit xxx 的。</p></li><li><p><strong>本地分支</strong>：已经git commit -m xxx 提交到本地分支的。</p></li></ul><p>在将文件提交至远程端时，文件的提交需要经过<strong>git add</strong>、<strong>git commit</strong>及<strong>git push</strong>三个过程才能提交至git远程仓库。我们平时修改文件在<strong>工作目录</strong>中，提交时先使用git add提交至<strong>暂存区</strong>，再通过git commit提交至<strong>本地仓库</strong>，最后才能使用git push提交至远程仓库。</p><ul><li><strong>在工作区的代码</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- a.txt   <span class="comment"># 丢弃某个文件，或者</span></span><br><span class="line">git checkout -- .       <span class="comment"># 丢弃全部</span></span><br></pre></td></tr></table></figure><p>注意：git checkout – . 丢弃全部，也包括：新增的文件会被删除、删除的文件会恢复回来、修改的文件会回去。这几个前提都说的是，回到暂存区之前的样子。对之前保存在暂存区里的代码不会有任何影响。对commit提交到本地分支的代码就更没影响了。当然，如果你之前压根都没有暂存或commit，那就是回到你上次pull下来的样子了。</p><ul><li><strong>代码git add到缓存区，并未commit提交</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD .  或者</span><br><span class="line">git reset HEAD a.txt</span><br></pre></td></tr></table></figure><p>这个命令仅改变暂存区，并不改变工作区，这意味着在无任何其他操作的情况下，工作区中的实际文件同该命令运行之前无任何变化</p><ul><li><strong>git commit到本地分支、但没有git push到远程</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment"># 得到你需要回退一次提交的commit id</span></span><br><span class="line">git reset --hard &lt;commit_id&gt;  <span class="comment"># 回到其中你想要的某个版</span></span><br><span class="line">或者</span><br><span class="line">git reset --hard HEAD^  <span class="comment"># 回到最新的一次提交</span></span><br><span class="line">或者</span><br><span class="line">git reset HEAD^  <span class="comment"># 此时代码保留，回到 git add 之前</span></span><br></pre></td></tr></table></figure><ul><li><strong>git push把修改提交到远程仓库</strong><br>1）通过git reset是直接删除指定的commit</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment"># 得到你需要回退一次提交的commit id</span></span><br><span class="line">git reset --hard &lt;commit_id&gt;</span><br><span class="line">git push origin HEAD --force <span class="comment"># 强制提交一次，之前错误的提交就从远程仓库删除</span></span><br></pre></td></tr></table></figure><p>2）通过git revert是用一次新的commit来回滚之前的commit</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment"># 得到你需要回退一次提交的commit id</span></span><br><span class="line">git revert &lt;commit_id&gt;  <span class="comment"># 撤销指定的版本，撤销也会作为一次提交进行保存</span></span><br><span class="line">git commit -m <span class="string">"......."</span> </span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>开发过程中，你肯定会遇到这样的场景：</p><p>场景一：</p><pre><code>糟了，我刚把不想要的代码，commit到本地仓库中了，但是还没有做push操作！</code></pre><p>场景二：</p><pre><code>彻底完了，刚线上更新的代码出现问题了，需要还原这次提交的代码！</code></pre><p>场景三：</p><pre><code>刚才我发现之前的某次提交太愚蠢了，现在想要干掉它！</code></pre><p>撤销</p><p>上述场景一，在未进行git push前的所有操作，都是在“本地仓库”中执行的。我们暂且将“本地仓库”的代码还原操作叫做“撤销”！</p><p>情况一：文件被修改了，但未执行git add操作(working tree内撤销)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout fileName</span><br><span class="line">git checkout .</span><br></pre></td></tr></table></figure><p>情况二：同时对多个文件执行了git add操作，但本次只想提交其中一部分文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add *</span><br><span class="line">$ git status</span><br><span class="line"><span class="comment"># 取消暂存</span></span><br><span class="line">$ git reset HEAD &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>情况三：文件执行了git add操作，但想撤销对其的修改（index内回滚）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取消暂存</span></span><br><span class="line"> git reset HEAD fileName</span><br><span class="line"> <span class="comment"># 撤销修改</span></span><br><span class="line"> git checkout fileName</span><br></pre></td></tr></table></figure><p>情况四：修改的文件已被git commit，但想再次修改不再产生新的Commit</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改最后一次提交 </span></span><br><span class="line">  $ git add sample.txt</span><br><span class="line">  $ git commit --amend -m<span class="string">"说明"</span></span><br></pre></td></tr></table></figure><h1 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h1><p>git reset中有三个命令（–hard、–soft与–mixed）；主要用于工作区、暂存区、本地仓库三个区域的文件提交撤回</p><ul><li>git reset –hard xxx</li></ul><p>hard （修改版本库，修改暂存区，修改工作区）</p><p>–hard HEAD～1 (或是版本号)意为将版本库回退1个版本，但是不仅仅是将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并且会将工作区代码也回退到这个版本</p><ul><li><p>git reset –soft xxx</p><p>soft （修改版本库，保留暂存区，保留工作区）</p></li></ul><p>–soft HEAD～1 意为将版本库软回退1个版本，所谓软回退表示将本地版本库的头指针全部重置到指定版本，且将这次提交之后的所有变更都移动到暂存区。</p><h1 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h1><ul><li>git revert xxx</li></ul><p>– git revert 也是撤销命令，区别在于reset是指向原地或者向前移动指针，git revert是创建一个commit来覆盖当前的commit，指针向后移动。</p><h1 id="git-revert-和-git-reset的区别"><a href="#git-revert-和-git-reset的区别" class="headerlink" title="git revert 和 git reset的区别"></a>git revert 和 git reset的区别</h1><ul><li>git revert是用一次新的commit来回滚之前的commit，此次提交之前的commit都会被保留；</li><li>git reset是回到某次提交，提交及之前的commit都会被保留，但是此commit id之后的修改都会被删除</li><li>git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit。</li></ul><ul><li>在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入。</li><li>git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在利用git实现多人合作开发程序的过程中，有时会出现错误提交的情况，此时希望能撤销提交操作，让程序回到提交前的样子，本文总结了两种方法：re
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git merge 和 rebase</title>
    <link href="https://ruanyandong.github.io/2020/02/17/git-merge-%E5%92%8C-rebase/"/>
    <id>https://ruanyandong.github.io/2020/02/17/git-merge-和-rebase/</id>
    <published>2020-02-17T13:19:20.000Z</published>
    <updated>2020-02-17T13:21:45.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h1><p>假设你现在基于远程分支”origin”，创建一个叫”mywork”的分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b mywork origin</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200217185852996.png" alt="在这里插入图片描述"><br>现在我们在这个分支做一些修改，然后生成两个提交(commit).</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vi file.txt</span><br><span class="line">$ git commit</span><br><span class="line">$ vi otherfile.txt</span><br><span class="line">$ git commit</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但是与此同时，有些人也在”origin”分支上做了一些修改并且做了提交了. 这就意味着”origin”和”mywork”这两个分支各自”前进”了，它们之间”分叉”了。<br><img src="https://img-blog.csdnimg.cn/20200217190033870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NjgxNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在这里，你可以用”pull”命令把”origin”分支上的修改拉下来并且和你的修改合并； 结果看起来就像一个新的”合并的提交”(merge commit):<br><img src="https://img-blog.csdnimg.cn/20200217190249605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NjgxNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>但是，如果你想让”mywork”分支历史看起来像没有经过任何合并一样，你也许可以用 git rebase:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout mywork</span><br><span class="line">$ git rebase origin</span><br></pre></td></tr></table></figure><p>这些命令会把你的”mywork”分支里的每个提交(commit)取消掉，并且把它们临时 保存为补丁(patch)(这些补丁放到”.git/rebase”目录中),然后把”mywork”分支更新 到最新的”origin”分支，最后把保存的这些补丁应用到”mywork”分支上。<br><img src="https://img-blog.csdnimg.cn/20200217190341269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NjgxNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>当’mywork’分支更新之后，它会指向这些新创建的提交(commit),而那些老的提交会被丢弃。 如果运行垃圾收集命令(pruning garbage collection), 这些被丢弃的提交就会删除. （请查看 git gc)<br><img src="https://img-blog.csdnimg.cn/20200217190435390.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NjgxNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>现在我们可以看一下用合并(merge)和用rebase所产生的历史的区别：<br><img src="https://img-blog.csdnimg.cn/20200217190631810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NjgxNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p><ul><li>1-2-3 是现在的分支状态</li><li>这个时候从原来的master ,checkout出来一个prod分支</li><li>然后master提交了4.5，prod提交了6.7</li><li>这个时候master分支状态就是1-2-3-4-5，prod状态变成1-2-3-6-7</li><li>如果在prod上用rebase master ,prod分支状态就成了1-2-3-4-5-6-7</li><li>如果是merge 1-2-3-6-7-8  …….. |4-5|</li><li>会出来一个8，这个8的提交就是把4-5合进来的提交</li></ul><p>在rebase的过程中，也许会出现冲突(conflict). 在这种情况，Git会停止rebase并会让你去解决 冲突；在解决完冲突后，用”git-add”命令去更新这些内容的索引(index), 然后，你无需执行 git-commit,只要执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><p>这样git会继续应用(apply)余下的补丁。</p><p>在任何时候，你可以用–abort参数来终止rebase的行动，并且”mywork” 分支会回到rebase开始前的状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --abort</span><br></pre></td></tr></table></figure><h2 id="git-pull和git-pull-–rebase区别"><a href="#git-pull和git-pull-–rebase区别" class="headerlink" title="git pull和git pull –rebase区别"></a><strong>git pull</strong>和<strong>git pull –rebase</strong>区别</h2><p><strong>git pul</strong>l做了两个操作分别是‘获取’和合并。所以加了rebase就是以rebase的方式进行合并分支，默认为merge。</p><h2 id="git-merge-和-git-merge-–no-ff的区别"><a href="#git-merge-和-git-merge-–no-ff的区别" class="headerlink" title="git merge 和 git merge –no-ff的区别"></a>git merge 和 git merge –no-ff的区别</h2><p>1、尝试merge命令后，发现：merge时并没有产生一个commit。不是说merge时会产生一个merge commit吗？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意:只有在冲突的时候，解决完冲突才会自动产生一个commit。</span><br></pre></td></tr></table></figure><p>如果想在没有冲突的情况下也自动生成一个commit，记录此次合并就可以用：<strong>git merge –no-ff</strong>命令，下面用一张图来表示两者的区别：<br><img src="https://img-blog.csdnimg.cn/20200217192653541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NjgxNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">2、如果不加 –no-ff 则被合并的分支之前的commit都会被抹去，只会保留一个解决冲突后的 merge commit。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://gitbook.liuhui998.com/4_2.html" target="_blank" rel="noopener">merge和rebase</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;rebase&quot;&gt;&lt;a href=&quot;#rebase&quot; class=&quot;headerlink&quot; title=&quot;rebase&quot;&gt;&lt;/a&gt;rebase&lt;/h1&gt;&lt;p&gt;假设你现在基于远程分支”origin”，创建一个叫”mywork”的分支。&lt;/p&gt;
&lt;figure clas
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git revert踩坑之路</title>
    <link href="https://ruanyandong.github.io/2020/02/16/git-revert%E8%B8%A9%E5%9D%91%E4%B9%8B%E8%B7%AF/"/>
    <id>https://ruanyandong.github.io/2020/02/16/git-revert踩坑之路/</id>
    <published>2020-02-16T15:26:45.000Z</published>
    <updated>2020-02-16T15:27:59.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在实际的开发工作中，使用git总会遇到一堆问题，本文将结合具体例子，讲述在何种条件下会出发<strong>git revert失败</strong>以及<strong>解决的方案和措施</strong>。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>首先，创建一个git 仓库（repo），本人是在Mac环境下，Windows下打开git 命令行，但代码是一样的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir git-revert</span><br><span class="line"><span class="built_in">cd</span> git-revert</span><br><span class="line">git init</span><br></pre></td></tr></table></figure></p><p>首先创建两个 commit 来模拟 master 上现有的 commit 记录：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'file1'</span> &gt; file1 </span><br><span class="line">git add . &amp;&amp; git commit -m <span class="string">'commit 1'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'file2'</span> &gt; file2</span><br><span class="line">git add . &amp;&amp; git commit -m <span class="string">'commit 2'</span></span><br></pre></td></tr></table></figure></p><p>现在我们需要开发一个新功能，所以需要基于master分支拉了一个新分支dev，我们创建并切换到dev分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch dev</span><br><span class="line">git checkout dev </span><br><span class="line"><span class="comment"># 或者使用 git checkout -b dev 合上面两步效果一样</span></span><br></pre></td></tr></table></figure></p><p>接下来我们添加两个commit来完成dev分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'file3'</span> &gt; file3</span><br><span class="line">git add . &amp;&amp; git commit -m <span class="string">'dev - commit 1'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'file4'</span> &gt; file4</span><br><span class="line">git add . &amp;&amp; git commit -m <span class="string">'dev - commit 2'</span></span><br></pre></td></tr></table></figure></p><p>在dev分支开发过程中，master 分支上通常会有其他人新的 commit提交，于是我们回到 master，来模拟一下这些 commit:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'file5'</span> &gt; file5</span><br><span class="line">git add . &amp;&amp; git commit -m <span class="string">'commit 3'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'file6'</span> &gt; file6</span><br><span class="line">git add . &amp;&amp; git commit -m <span class="string">'commit 4'</span></span><br></pre></td></tr></table></figure></p><p>这个时候，dev分支测试通过了，需要合并到master分支上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure><p>如图所示：<br><img src="https://img-blog.csdnimg.cn/20200121120329144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NjgxNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>后来，master 上又多了一些 commit：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'file7'</span> &gt; file7</span><br><span class="line">git add . &amp;&amp; git commit -m <span class="string">'commit 5'</span></span><br></pre></td></tr></table></figure></p><p>由于dev分支有问题，不想合并master分支，想revert这次merge commit，那就revert吧。<br>首先，先git log看一下：<br><img src="https://img-blog.csdnimg.cn/20200121143718784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NjgxNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>找到merge的commit id来revert，711b06，<br><img src="https://img-blog.csdnimg.cn/20200121144304989.png" alt="在这里插入图片描述"><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert 711b06</span><br></pre></td></tr></table></figure></p><p>问题出现了，revert失败：<br><img src="https://img-blog.csdnimg.cn/2020012114453925.png" alt="在这里插入图片描述"></p><h1 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h1><p>再次给出错误信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: commit 711b06365ec6ced517bf2597fa1b7562060e1181 is a merge but no -m option was given.</span><br></pre></td></tr></table></figure></p><p>我们来看看 -m 到底指的是什么, 查看官方文档, 可以看到：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-m parent-number</span><br><span class="line">--mainline parent-number</span><br><span class="line">Usually you cannot revert a merge because you <span class="keyword">do</span> not know <span class="built_in">which</span> side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows revert to reverse the change relative to the specified parent.</span><br><span class="line"></span><br><span class="line">Reverting a merge commit declares that you will never want the tree changes brought <span class="keyword">in</span> by the merge. As a result, later merges will only bring <span class="keyword">in</span> tree changes introduced by commits that are not ancestors of the previously reverted merge. This may or may not be what you want.</span><br></pre></td></tr></table></figure></p><p>翻译过来就是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通常情况下，你无法 revert 一个 merge，因为你不知道 merge 的哪一条线应该被视为主线。这个选项（-m）指定了主线的 parent 的代号（从1开始），并允许以相对于指定的 parent 的进行 revert。</span><br><span class="line"></span><br><span class="line">revert 一个 merge commit 意味着你将完全不想要来自 merge commit 带来的 tree change。 因此，之后的 merge 只会引入那些不是之前被 revert 的那个 merge 的祖先引入的 tree change，这可能是也可能不是你想要的。</span><br></pre></td></tr></table></figure><p>由于 merge commit 是将两条线合并到一条线上，因此，合并时的那个commit，将具有两个祖先。所以 git 不知道 base 是选择哪个 parent 进行 diff，所以你要用 -m 属性显示地告诉 git 用哪一个 parent。<br>那么，如何查看当前的commit有几个祖先呢？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show 711b06</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.csdnimg.cn/20200121145947797.png" alt="在这里插入图片描述"><br>Merge 这个字段便标明了当前的parent，分别是 0ffc72f 和 8f1dbff</p><p><strong>当你在 B 分支上把 A merge 到 B 中，那么 B 就是merge commit 的 parent1，而 A 是 parent2，所以，master分支是parent1，dev分支是parent2。</strong></p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>有了上一节的分析，我们可以很直接地给出以下可用的代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert 711b06 -m 1</span><br></pre></td></tr></table></figure></p><p>输出以下log：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Revert <span class="string">"Merge branch 'dev'"</span></span><br><span class="line">  </span><br><span class="line">This reverts commit 711b06365ec6ced517bf2597fa1b7562060e1181, reversing</span><br><span class="line">changes made to 0ffc72ff1095bb8c70e72f39ab99e8102ce480b9.</span><br><span class="line"></span><br><span class="line"> Please enter the commit message <span class="keyword">for</span> your changes. Lines starting</span><br><span class="line"> with <span class="string">'#'</span> will be ignored, and an empty message aborts the commit.</span><br><span class="line"> </span><br><span class="line"> On branch master</span><br><span class="line"> Changes to be committed:</span><br><span class="line">       deleted:    file3</span><br><span class="line">       deleted:    file4</span><br></pre></td></tr></table></figure><p>:wq 退出看到:<br><img src="https://img-blog.csdnimg.cn/2020012115160522.png" alt="在这里插入图片描述"><br>file3 和 file4 是dev上的 commit 引入的文件，被正确地删掉了。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><ul><li>对于单一 parent 的 commit，直接使用 git revert commit_id;</li><li>对于具有多个 parent 的 commit，需要结合 -m 属性：git revert commit_id -m parent_id;</li><li>对于从 branch 合并到 master 的 merge commit，master 的 parent_id 是1，branch 的 parent_id 是2, 反之亦然;</li></ul><p>参考以下文章<br><a href="https://juejin.im/post/5acf4db8f265da239148822d" target="_blank" rel="noopener">当你决定去 revert 一个merge commit</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在实际的开发工作中，使用git总会遇到一堆问题，本文将结合具体例子，讲述在何种条件下会出发&lt;strong&gt;git revert失败&lt;/str
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android沉浸式状态栏</title>
    <link href="https://ruanyandong.github.io/2020/02/16/Android%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E6%A0%8F/"/>
    <id>https://ruanyandong.github.io/2020/02/16/Android沉浸式状态栏/</id>
    <published>2020-02-16T15:08:22.000Z</published>
    <updated>2020-02-16T15:10:14.980Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前做过Android沉浸式状态栏的相关需求，但是一直忙于工作，没时间系统的整理下沉浸式相关的知识，所以今天抽出时间，写一篇 Android沉浸式状态栏的文章。</p><h1 id="何为沉浸式"><a href="#何为沉浸式" class="headerlink" title="何为沉浸式"></a>何为沉浸式</h1><p><strong>沉浸式</strong>就是要给用户提供完全沉浸的体验，使用户有一种置身于虚拟世界之中的感觉。<br><strong>沉浸式模式</strong>就是整个屏幕中显示都是应用的内容，没有状态栏也没有导航栏，用户不会被一些系统的界面元素所打扰。<br><strong>Android沉浸式模式</strong>的本质就是全屏化，但这可能并不是我们想要的，我们还是来实现下网上传的沸沸扬扬的<strong>Android沉浸式状态栏</strong></p><h1 id="沉浸式状态栏的兼容情况"><a href="#沉浸式状态栏的兼容情况" class="headerlink" title="沉浸式状态栏的兼容情况"></a>沉浸式状态栏的兼容情况</h1><table><thead><tr><th>Android版本</th><th>透明状态栏</th></tr></thead><tbody><tr><td>&lt;4.4</td><td>×</td></tr><tr><td>4.4-5.0</td><td>✓</td></tr><tr><td>&gt;=5.0</td><td>✓</td></tr></tbody></table><table><thead><tr><th>Android版本</th><th>黑白字符状态栏</th></tr></thead><tbody><tr><td>&lt;6.0</td><td>×</td></tr><tr><td>&gt;=6.0</td><td>✓</td></tr></tbody></table><h1 id="fitsSystemWindows"><a href="#fitsSystemWindows" class="headerlink" title="fitsSystemWindows"></a>fitsSystemWindows</h1><p>在讲沉浸式状态栏之前，我们先来认识一个属性——fitsSystemWindows，这个属性在沉浸式状态中扮演着非常重要的角色。</p><ul><li>官方描述</li></ul><blockquote><p>Boolean internal attribute to adjust view layout based on system<br>windows such as the status bar. If true, adjusts the padding of this view to leave space for the system windows. Will only take effect if this view is in a non-embedded activity.</p></blockquote><ul><li>中文描述</li></ul><blockquote><p>Boolean内部属性是基于系统窗口（如status bar）调整视图布局。如果为true，将调整视图padding为系统窗口预留出空间。Will only take effect if this view is in a non-embedded activity.<br> 这句话的意思是view不在非嵌入式的activity才会生效。<br> 嵌入式activity是托管在父activity中的活动。常见的例子是TabHost / TabActivity设计。特别是，嵌入式Acitvities位于主机中 LocalActivityManager，这在概念上类似于 FragmentManager 它允许您在另一个内部显示一个Activity。</p></blockquote><p>根据这个定义，很容易理解为什么只有主机（非嵌入式）Activity才能支持 fitsSystemWindows 属性，因为任何嵌入的活动都限制在其主机定义的区域内。</p><ul><li>注意：<blockquote><p>fitsSystemWindows只作用在sdk&gt;=19的系统上就是高于4.4的系统，android:fitsSystemWindows默认值为false，并且在哪个控件设置android:fitsSystemWindows=”true”会有不一样的效果</p></blockquote></li></ul><p>android:fitsSystemWindows=”true”，这个属性可以给任何view设置,只要设置了这个属性此view的所有padding属性失效.只有在设置了透明状态栏(StatusBar)或者导航栏(NavigationBar)此属性才会生效</p><p><strong>当设置了透明状态栏(StatusBar)时:</strong><br>当为此activity设置了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;item name="android:windowTranslucentStatus"&gt;true&lt;/item&gt;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">   getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果有以上两种情况之一,我们的状态栏(StatusBar)就会变成透明,并且布局会扩展到StatusBar的位置同时,所有设置了android:fitsSystemWindows=”true”属性的view会自动添加一个值等于状态栏高度的paddingTop</p><p><strong>当设置了透明导航栏(NavigationBar)时:</strong><br>当为此activity设置了:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;item name="android:windowTranslucentNavigation"&gt;true&lt;/item&gt;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">    getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果有以上两种情况之一,我们的导航栏(NavigationBar)就会变成透明,并且布局会扩展到NavigationBar的位置。同时,所有设置了android:fitsSystemWindows=”true”属性的view会自动添加一个值等于导航栏高度的paddingBottom。</p><h1 id="沉浸式状态栏实现的一般思路"><a href="#沉浸式状态栏实现的一般思路" class="headerlink" title="沉浸式状态栏实现的一般思路"></a>沉浸式状态栏实现的一般思路</h1><ul><li><strong>4.4以下版本：</strong> 我们可以对StatusBar和 NavigationBar进行显示和隐藏操作，但无法实现沉浸式状态栏。</li><li><p><strong>Android4.4（API 19） - Android 5.0（API 21)：</strong> 通过FLAG_TRANSLUCENT_STATUS设置状态栏为透明并且为全屏模式，然后通过添加一个与StatusBar 一样大小的View，将View 的 background 设置为我们想要的颜色，从而来实现沉浸式。</p></li><li><p><strong>Android 5.0（API 21）以上版本：</strong> 在Android 5.0的时候，加入了一个重要的属性和方法 android:statusBarColor （对应方法为 setStatusBarColor），通过这个方法我们就可以轻松实现沉浸式。也就是说，从Android5.0开始，系统才真正的支持沉浸式。</p></li><li><p><strong>Android 6.0（API 23）以上版本：</strong> Android6.0以上的实现方式和Android 5.0 +是一样，但从Android 6.0（API 23）开始，我们可以改状态栏的绘制模式，可以显示白色或浅黑色的内容和图标（除了魅族手机，魅族自家有做源码更改，6.0以下就能实现）</p></li></ul><h3 id="Android4-4（API-19）-Android-5-0（API-21）实现沉浸式的方式"><a href="#Android4-4（API-19）-Android-5-0（API-21）实现沉浸式的方式" class="headerlink" title="Android4.4（API 19） - Android 5.0（API 21）实现沉浸式的方式"></a>Android4.4（API 19） - Android 5.0（API 21）实现沉浸式的方式</h3><p>Android 4.4 为什么能够实现沉浸式的效果呢？因为在Android 4.4 新增了一个重要的属性：<strong>FLAG_TRANSLUCENT_STATUS</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Window flag: request a translucent status bar with minimal system-provided</span></span><br><span class="line"><span class="comment">        * background protection.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * &lt;p&gt;This flag can be controlled in your theme through the</span></span><br><span class="line"><span class="comment">        * &#123;<span class="doctag">@link</span> android.R.attr#windowTranslucentStatus&#125; attribute; this attribute</span></span><br><span class="line"><span class="comment">        * is automatically set for you in the standard translucent decor themes</span></span><br><span class="line"><span class="comment">        * such as</span></span><br><span class="line"><span class="comment">        * &#123;<span class="doctag">@link</span> android.R.style#Theme_Holo_NoActionBar_TranslucentDecor&#125;,</span></span><br><span class="line"><span class="comment">        * &#123;<span class="doctag">@link</span> android.R.style#Theme_Holo_Light_NoActionBar_TranslucentDecor&#125;,</span></span><br><span class="line"><span class="comment">        * &#123;<span class="doctag">@link</span> android.R.style#Theme_DeviceDefault_NoActionBar_TranslucentDecor&#125;, and</span></span><br><span class="line"><span class="comment">        * &#123;<span class="doctag">@link</span> android.R.style#Theme_DeviceDefault_Light_NoActionBar_TranslucentDecor&#125;.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * &lt;p&gt;When this flag is enabled for a window, it automatically sets</span></span><br><span class="line"><span class="comment">        * the system UI visibility flags &#123;<span class="doctag">@link</span> View#SYSTEM_UI_FLAG_LAYOUT_STABLE&#125; and</span></span><br><span class="line"><span class="comment">        * &#123;<span class="doctag">@link</span> View#SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN&#125;.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_TRANSLUCENT_STATUS = <span class="number">0x04000000</span>;</span><br></pre></td></tr></table></figure></p><blockquote><p> 解释：设置状态栏透明，并且变为全屏模式。上面的解释已经说得很清楚了，当window的这个属性有效的时候，会自动设置 system ui visibility的标志SYSTEM_UI_FLAG_LAYOUT_STABLE和SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN.</p></blockquote><p><strong>有两种方式实现这个属性：</strong></p><p><strong>可以在代码中设置</strong>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br></pre></td></tr></table></figure><p><strong>当然也可以在theme 中设置属性windowTranslucentStatus</strong>,如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:windowTranslucentStatus</span><br></pre></td></tr></table></figure></p><p>效果如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy84LzgvMTgzMDA4MzVmZGU4NzExOThlMzkwZTU5NWIwYTRkNzI?x-oss-process=image/format,png#pic_center" alt="Alt"><br>效果如上图，可以看出，沉浸式的效果是出来了，但是也有一个问题，<strong>我们的标题栏和状态栏重叠了</strong>，相当于整个布局上移了StatusBar 的高度。<strong>为了让标题栏回到原来的位置，我们在标题栏的上方添加一个大小和StatusBar大小一样的View,View 的BackgroundColor 为标题栏一样的颜色，这个View起到一个占位的作用。这个时候，标题栏就会下移StatusBar的高度，回到正常的位置。</strong><br>添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取windowphone下的decorView</span></span><br><span class="line"> ViewGroup decorView = (ViewGroup) activity.getWindow().getDecorView();</span><br><span class="line"> <span class="keyword">int</span>       count     = decorView.getChildCount();</span><br><span class="line"> <span class="comment">//判断是否已经添加了statusBarView</span></span><br><span class="line"> <span class="keyword">if</span> (count &gt; <span class="number">0</span> &amp;&amp; decorView.getChildAt(count - <span class="number">1</span>) <span class="keyword">instanceof</span> StatusBarView) &#123;</span><br><span class="line">     decorView.getChildAt(count - <span class="number">1</span>).setBackgroundColor(calculateStatusColor(color, statusBarAlpha));</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">//新建一个和状态栏高宽的view</span></span><br><span class="line">     StatusBarView statusView = createStatusBarView(activity, color, statusBarAlpha);</span><br><span class="line">     decorView.addView(statusView);</span><br><span class="line"> &#125;</span><br><span class="line"> ViewGroup rootView = (ViewGroup) ((ViewGroup) activity.findViewById(android.R.id.content)).getChildAt(<span class="number">0</span>);</span><br><span class="line"> <span class="comment">//rootview不会为状态栏留出状态栏空间</span></span><br><span class="line"> ViewCompat.setFitsSystemWindows(rootView,<span class="keyword">true</span>);</span><br><span class="line"> rootView.setClipToPadding(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>创建和status bar 一样大小的View的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> StatusBarView <span class="title">createStatusBarView</span><span class="params">(Activity activity, <span class="keyword">int</span> color, <span class="keyword">int</span> alpha)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 绘制一个和状态栏一样高的矩形</span></span><br><span class="line">       StatusBarView statusBarView = <span class="keyword">new</span> StatusBarView(activity);</span><br><span class="line">       LinearLayout.LayoutParams params =</span><br><span class="line">               <span class="keyword">new</span> LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, getStatusBarHeight(activity));</span><br><span class="line">       statusBarView.setLayoutParams(params);</span><br><span class="line">       statusBarView.setBackgroundColor(calculateStatusColor(color, alpha));</span><br><span class="line">       <span class="keyword">return</span> statusBarView;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>其中StatusBarView 就是一个普通的View。<br>添加上述代码后，效果如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy84LzgvNjFkNjhmZThjMTkzOGZhNGFkMjEwMjgzZTU0ODRhY2Y?x-oss-process=image/format,png#pic_center" alt="Alt"><br>通过以上就可以实现<strong>Android 4.4 上的沉浸式状态栏</strong>。</p><p>另外，<strong>如果是一张图片延伸到状态栏的话</strong>，直接设置<strong>FLAG_TRANSLUCENT_STATUS</strong>就可以了，如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy84LzgvZmY2Y2M4MmZiZDhhZTVjZjk2OTkyNjI4OWM4ZTQ1YWQ?x-oss-process=image/format,png#pic_center" alt="Alt"></p><blockquote><p>小结：Android4.4上实现沉浸式状态栏的套路是：为window添加FLAG_TRANSLUCENT_STATUS Flag,然后添加一个和status bar 一样大小的View 站位，从而让让标题栏不会与status bar重叠。而图片延伸到状态栏只需要设置FLAG_TRANSLUCENT_STATUS就OK。</p></blockquote><p> 沉浸式在Android4.4 - Android5.0 之间的版本表现得不是很好，从上面贴的几张图就可以看出，状态栏的顶部有一个渐变，会显示出黑色的阴影（底部的导航栏也是一样的效果），在Android 5.0 版本已经被修复了。</p><h3 id="Android-5-0（API-21）以上实现沉浸式的方式"><a href="#Android-5-0（API-21）以上实现沉浸式的方式" class="headerlink" title="Android 5.0（API 21）以上实现沉浸式的方式"></a>Android 5.0（API 21）以上实现沉浸式的方式</h3><p> Android 5.0 是一个里程碑式的版本，从Android 5.0开始，Google 推出了全新的设计规范 Material Design,并且原生控件就可以实现一些炫酷的UI动效。从这个版本开始，google 加入了一个比较重要的方法setStatusBarColor (对应属性：android:statusBarColor),通过这个方法，可以很轻松地实现沉浸式状态栏。方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Sets the color of the status bar to &#123;<span class="doctag">@code</span> color&#125;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * For this to take effect,</span></span><br><span class="line"><span class="comment">    * the window must be drawing the system bar backgrounds with</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> android.view.WindowManager.LayoutParams#FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS&#125; and</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> android.view.WindowManager.LayoutParams#FLAG_TRANSLUCENT_STATUS&#125; must not be set.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * If &#123;<span class="doctag">@code</span> color&#125; is not opaque, consider setting</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> android.view.View#SYSTEM_UI_FLAG_LAYOUT_STABLE&#125; and</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> android.view.View#SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * The transitionName for the view background will be "android:status:background".</span></span><br><span class="line"><span class="comment">    * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setStatusBarColor</span><span class="params">(@ColorInt <span class="keyword">int</span> color)</span></span>;</span><br></pre></td></tr></table></figure><p>注意看这个方法的注释，<strong>想要这个方法生效，必须还要配合一个Flag一起使用，必须设置FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS ,并且不能设置FLAG_TRANSLUCENT_STATUS(Android 4.4才用这个)</strong><br>看一下<strong>FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS</strong>这个flag:<br>可以看到，这个flag 也是在Android 5.0添加的，它的作用是什么呢？</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy84LzgvZDBkZDkwYjQxMDE5MDdlNGM0Mjk5MzMzMjcxY2ExODc?x-oss-process=image/format,png#pic_center" alt="Alt"></p><blockquote><p>解释：设置了FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS,表明会Window负责系统bar的background 绘制，绘制透明背景的系统bar（状态栏和导航栏），然后用getStatusBarColor()和getNavigationBarColor()的颜色填充相应的区域。这就是Android 5.0 以上实现沉浸式导航栏的原理。</p></blockquote><p>实现沉浸式添加如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getWindow().addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);</span><br><span class="line"><span class="comment">//注意要清除 FLAG_TRANSLUCENT_STATUS flag</span></span><br><span class="line">getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">getWindow().setStatusBarColor(getResources().getColor(android.R.color.holo_red_light));</span><br></pre></td></tr></table></figure></p><p>效果如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy84LzgvM2U1NmU0ZThkMWM2NDlhOTJmNWNjMTYyYWI5MjhkMzM?x-oss-process=image/format,png#pic_center" alt="Alt"></p><p>当然也可以直接在Theme中使用，在values-v21文件夹下添加如下主题：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=<span class="string">"MDTheme"</span> parent=<span class="string">"Theme.Design.Light.NoActionBar"</span>&gt;</span><br><span class="line">        &lt;item name="android:windowTranslucentStatus"&gt;false&lt;/item&gt;</span><br><span class="line">        &lt;item name="android:windowDrawsSystemBarBackgrounds"&gt;true&lt;/item&gt;</span><br><span class="line">        &lt;item name="android:statusBarColor"&gt;@android:color/holo_red_light&lt;/item&gt;</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure><p>效果和上面代码中添加的效果一样。</p><p><strong>图片延伸到状态栏</strong></p><p>在<strong>Android 5.0使图片延伸到状态栏</strong>，只需设置windowTranslucentStatus,将 statusBarColor 设置为透明即可：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=<span class="string">"ImageTranslucentTheme"</span> parent=<span class="string">"Theme.AppCompat.DayNight.NoActionBar"</span>&gt;</span><br><span class="line">        &lt;item name="android:windowTranslucentNavigation"&gt;true&lt;/item&gt;</span><br><span class="line">        &lt;item name="android:windowTranslucentStatus"&gt;true&lt;/item&gt;</span><br><span class="line">        &lt;!-- 设置statusBarColor 为透明--&gt;</span><br><span class="line">        &lt;item name="android:statusBarColor"&gt;@android:color/transparent&lt;/item&gt;</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure><p>效果如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy84LzgvY2JiMjYxODFhNGNlNTA1NDdiYWIxMGQ5ZDE0MWNiOGE?x-oss-process=image/format,png#pic_center" alt="Alt"></p><p>代码实现方式中通过版本号的判断兼容 Android5.0以下和Android 5.0以上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">            activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);</span><br><span class="line">            activity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">            activity.getWindow().setStatusBarColor(calculateStatusColor(color, statusBarAlpha));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">            ViewGroup decorView = (ViewGroup) activity.getWindow().getDecorView();</span><br><span class="line">            <span class="keyword">int</span> count = decorView.getChildCount();</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span> &amp;&amp; decorView.getChildAt(count - <span class="number">1</span>) <span class="keyword">instanceof</span> StatusBarView) &#123;</span><br><span class="line">                decorView.getChildAt(count - <span class="number">1</span>).setBackgroundColor(calculateStatusColor(color, statusBarAlpha));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                StatusBarView statusView = createStatusBarView(activity, color, statusBarAlpha);</span><br><span class="line">                decorView.addView(statusView);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ViewGroup rootView = (ViewGroup) ((ViewGroup) activity.findViewById(android.R.id.content)).getChildAt(<span class="number">0</span>);</span><br><span class="line">            rootView.setFitsSystemWindows(<span class="keyword">true</span>);</span><br><span class="line">            rootView.setClipToPadding(<span class="keyword">true</span>);</span><br><span class="line">            setRootView(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Android-6-0-实现状态栏字色和图标浅黑色"><a href="#Android-6-0-实现状态栏字色和图标浅黑色" class="headerlink" title="Android 6.0 + 实现状态栏字色和图标浅黑色"></a>Android 6.0 + 实现状态栏字色和图标浅黑色</h3><p>使用沉浸式的时候会遇到一个问题，那就是<strong>Android 系统状态栏的字色和图标颜色为白色，当我的主题色或者图片接近白色或者为浅色的时候，状态栏上的内容就看不清了</strong>。 这个问题在Android 6.0的时候得到了解决。<strong>Android 6.0 新添加了一个属性SYSTEM_UI_FLAG_LIGHT_STATUS_BAR</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy84LzgvZjIyZDkwOWU5ZjMwMTkzODBhODhmYzNhNDRlZWRiMzc?x-oss-process=image/format,png#pic_center" alt="Alt"></p><blockquote><p>解释：为setSystemUiVisibility(int)方法添加的Flag,请求status bar<br>绘制模式，它可以兼容亮色背景的status bar 。要在设置了FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDSflag<br>,同时清除了FLAG_TRANSLUCENT_STATUSflag 才会生效。</p></blockquote><p>添加如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">            getWindow().getDecorView().setSystemUiVisibility(</span><br><span class="line">                    View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN|View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>效果如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy84LzgvOTA3MGM3NTc3Y2YxYmQwNjM5MDUwNGM5NTRmMzE4NjU?x-oss-process=image/format,png#pic_center" alt="Alt"><br>除了在代码中添加以外，还可以直接在主题中使用属性：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=<span class="string">"MDTheme"</span> parent=<span class="string">"Theme.Design.Light.NoActionBar"</span>&gt;</span><br><span class="line">       &lt;item name="android:windowTranslucentStatus"&gt;false&lt;/item&gt;</span><br><span class="line">       &lt;item name="android:windowDrawsSystemBarBackgrounds"&gt;true&lt;/item&gt;</span><br><span class="line">       &lt;item name="android:statusBarColor"&gt;@android:color/holo_red_light&lt;/item&gt;</span><br><span class="line">       &lt;!-- Android <span class="number">6.0</span>以上 状态栏字色和图标为浅黑色--&gt;</span><br><span class="line">       &lt;item name="android:windowLightStatusBar"&gt;true&lt;/item&gt;</span><br><span class="line">   &lt;/style&gt;</span><br></pre></td></tr></table></figure><p>注意：主题要放在values-v23文件夹下</p><p><strong>参考以下文章</strong><br><a href="https://juejin.im/post/5989ded56fb9a03c3b6c8bde" target="_blank" rel="noopener">Android关于沉浸式状态栏总结</a><br><a href="https://juejin.im/post/5b7d40a4f265da432a6adca5" target="_blank" rel="noopener">Android适配—沉浸式状态栏</a><br><a href="https://jaeger.itscoder.com/android/2016/02/15/status-bar-demo.html" target="_blank" rel="noopener">Android App 沉浸式状态栏解决方案</a><br><a href="https://www.infoq.cn/article/PaCj30OK19ubiSbdrbHG" target="_blank" rel="noopener">Android 沉浸式解析和轮子使用</a><br><a href="https://www.jianshu.com/p/a44c119d6ef7" target="_blank" rel="noopener">Android沉浸式(透明)状态栏适配</a><br><a href="https://blog.csdn.net/guolin_blog/article/details/51763825" target="_blank" rel="noopener">Android状态栏微技巧，带你真正理解沉浸式模式</a><br><a href="https://segmentfault.com/a/1190000017431435" target="_blank" rel="noopener">android沉浸式状态栏封装—教你玩出新花样</a><br><a href="https://github.com/gyf-dev/ImmersionBar" target="_blank" rel="noopener">ImmersionBar – android 4.4以上沉浸式实现</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;之前做过Android沉浸式状态栏的相关需求，但是一直忙于工作，没时间系统的整理下沉浸式相关的知识，所以今天抽出时间，写一篇 Android
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java守护线程和非守护线程</title>
    <link href="https://ruanyandong.github.io/2019/06/17/Java%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%9D%9E%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/"/>
    <id>https://ruanyandong.github.io/2019/06/17/Java守护线程和非守护线程/</id>
    <published>2019-06-16T16:24:36.000Z</published>
    <updated>2019-06-16T16:26:34.022Z</updated>
    
    <content type="html"><![CDATA[<p>请参考&gt;&gt;<a href="https://blog.csdn.net/lc1010078424/article/details/79613348" target="_blank" rel="noopener">Java守护线程和非守护线程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;请参考&amp;gt;&amp;gt;&lt;a href=&quot;https://blog.csdn.net/lc1010078424/article/details/79613348&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java守护线程和非守护线程&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>代码库上传Jcenter</title>
    <link href="https://ruanyandong.github.io/2019/06/16/%E4%BB%A3%E7%A0%81%E5%BA%93%E4%B8%8A%E4%BC%A0Jcenter/"/>
    <id>https://ruanyandong.github.io/2019/06/16/代码库上传Jcenter/</id>
    <published>2019-06-16T03:03:22.000Z</published>
    <updated>2019-06-16T03:09:23.134Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/lmj623565791/article/details/51148825" target="_blank" rel="noopener">Android 快速发布开源项目到jcenter</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/lmj623565791/article/details/51148825&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android 快速发布开源项目到jcenter&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android网络安全配置</title>
    <link href="https://ruanyandong.github.io/2019/06/11/Android%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/"/>
    <id>https://ruanyandong.github.io/2019/06/11/Android网络安全配置/</id>
    <published>2019-06-11T03:53:49.000Z</published>
    <updated>2019-06-11T04:03:51.380Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/dcfb61720413" target="_blank" rel="noopener">请看这篇文章——Android网络安全配置</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/dcfb61720413&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;请看这篇文章——Android网络安全配置&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java值传递和引用传递</title>
    <link href="https://ruanyandong.github.io/2019/04/24/java%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    <id>https://ruanyandong.github.io/2019/04/24/java值传递和引用传递/</id>
    <published>2019-04-24T13:30:34.000Z</published>
    <updated>2019-04-24T13:38:03.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java在传参时分为值-传递-和-引用传递-。参数为基本类型时是值传递，-参数为封装类型时是引用传递。"><a href="#java在传参时分为值-传递-和-引用传递-。参数为基本类型时是值传递，-参数为封装类型时是引用传递。" class="headerlink" title="java在传参时分为值 传递 和 引用传递 。参数为基本类型时是值传递， 参数为封装类型时是引用传递。"></a>java在传参时分为值 传递 和 引用传递 。参数为基本类型时是值传递， 参数为封装类型时是引用传递。</h1><h2 id="基本类型参数"><a href="#基本类型参数" class="headerlink" title="基本类型参数"></a>基本类型参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int num = 0 ;</span><br><span class="line">        changeNum(num);</span><br><span class="line">        System.out.println(&quot;num=&quot;+num);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void changeNum(int num) &#123;</span><br><span class="line">        num = 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印的结果是num=0。</p><h2 id="封装类型参数"><a href="#封装类型参数" class="headerlink" title="封装类型参数"></a>封装类型参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Product p = new Product();</span><br><span class="line">        p.setProName(&quot;before&quot;);</span><br><span class="line">        p.setNum(0);</span><br><span class="line">        changeProduct(p);</span><br><span class="line">        System.out.println(&quot;p.proName=&quot;+p.getProName());</span><br><span class="line">        System.out.println(&quot;p.num=&quot;+p.getNum());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void changeProduct(Product p) &#123;</span><br><span class="line">        p.setProName(&quot;after&quot;);</span><br><span class="line">        p.setNum(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Product &#123;</span><br><span class="line">    private int num;</span><br><span class="line">    private String proName;</span><br><span class="line"> </span><br><span class="line">    public int getNum() &#123;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setNum(int num) &#123;</span><br><span class="line">        this.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public String getProName() &#123;</span><br><span class="line">        return proName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setProName(String proName) &#123;</span><br><span class="line">        this.proName = proName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行的结果是：p.proName=after和p.num=1 。</p><h2 id="上面的两个例子是明显的值传递和引用传递。但是如果参数是String类型呢？"><a href="#上面的两个例子是明显的值传递和引用传递。但是如果参数是String类型呢？" class="headerlink" title="上面的两个例子是明显的值传递和引用传递。但是如果参数是String类型呢？"></a>上面的两个例子是明显的值传递和引用传递。但是如果参数是String类型呢？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str = &quot;ab&quot;;</span><br><span class="line">        changeString(str);</span><br><span class="line">        System.out.println(&quot;str=&quot;+str);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void changeString(String str) &#123;</span><br><span class="line">        str = &quot;cd&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照前面的例子，String应该是一个封装类型，它应该是引用传递，是可以改变值得， 运行的结果应该是”cd”。<br>我们实际运行一下看看，str=ab,这如何解释呢？</p><h2 id="这就要从java底层的机制讲起了，java的内存模型分为-堆-和-栈-。"><a href="#这就要从java底层的机制讲起了，java的内存模型分为-堆-和-栈-。" class="headerlink" title="这就要从java底层的机制讲起了，java的内存模型分为 堆 和 栈 。"></a>这就要从java底层的机制讲起了，java的内存模型分为 堆 和 栈 。</h2><p>1.基本类型的变量放在栈里；<br>2.封装类型中，对象放在堆里，对象的引用放在栈里。</p><p>java在方法传递参数时，是将变量复制一份，然后传入方法体去执行。 这句话是很难理解的，也是解释这个 问题的精髓。我们先按照这句话解释一下基本类型的传递</p><pre><code>虚拟机分配给num一个内存地址，并且存了一个值0.虚拟机复制了一个num，我们叫他num’，num’和num的内存地址不同，但存的值都是0。虚拟机讲num’传入方法，方法将num’的值改为1.方法结束，方法外打印num的值，由于num内存中的值没有改变，还是0，所以打印是0.</code></pre><p>我们再解释封装类型的传递：</p><pre><code>虚拟机在堆中开辟了一个Product的内存空间，内存中包含proName和num。虚拟机在栈中分配给p一个内存地址，这个地址中存的是1中的Product的内存地址。虚拟机复制了一个p，我们叫他p’,p和p’的内存地址不同，但它们存的值是相同的，都是1中Product的内存地址。将p’传入方法，方法改变了1中的proName和num。方法结束，方法外打印p中变量的值，由于p和p’中存的都是1中Product的地址，但是1中Product里的值发生了改变， 所以，方法外打印p的值，是方法执行以后的。我们看到的效果是封装类型的值是改变的。</code></pre><p>最后我们再来解释String在传递过程中的步骤：</p><pre><code>虚拟机在堆中开辟一块内存，并存值”ab”。虚拟机在栈中分配给str一个内存，内存中存的是1中的地址。虚拟机复制一份str，我们叫str’，str和str’内存不同，但存的值都是1的地址。将str’传入方法体方法体在堆中开辟一块内存，并存值”cd”方法体将str’的值改变，存入5的内存地址方法结束，方法外打印str，由于str存的是1的地址，所有打印结果是”ab”</code></pre><p>这样我们理解了java在方法传参的整个过程。其实还是上面那句比较重要的话 java在方法传递参数时，是将变量复制一份，然后传入方法体去执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java在传参时分为值-传递-和-引用传递-。参数为基本类型时是值传递，-参数为封装类型时是引用传递。&quot;&gt;&lt;a href=&quot;#java在传参时分为值-传递-和-引用传递-。参数为基本类型时是值传递，-参数为封装类型时是引用传递。&quot; class=&quot;headerlin
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android NDK学习</title>
    <link href="https://ruanyandong.github.io/2019/03/30/Android-NDK%E5%AD%A6%E4%B9%A0/"/>
    <id>https://ruanyandong.github.io/2019/03/30/Android-NDK学习/</id>
    <published>2019-03-29T18:52:50.000Z</published>
    <updated>2019-03-29T18:58:25.093Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.android.google.cn/ndk/guides/android_mk" target="_blank" rel="noopener">Android NDK官网</a><br><a href="https://www.jianshu.com/p/87ce6f565d37" target="_blank" rel="noopener">Android JNI</a><br><a href="https://blog.csdn.net/young_time/article/details/80346631" target="_blank" rel="noopener">使用 Android Studio 写出第一个 NDK 程序</a><br><a href="https://www.jianshu.com/c/a25bf14495d7" target="_blank" rel="noopener">Android NDK 开发之旅</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://developer.android.google.cn/ndk/guides/android_mk&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android NDK官网&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>android音视频学习</title>
    <link href="https://ruanyandong.github.io/2019/03/12/android%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/"/>
    <id>https://ruanyandong.github.io/2019/03/12/android音视频学习/</id>
    <published>2019-03-12T06:32:54.000Z</published>
    <updated>2019-03-12T07:05:04.150Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/renhui/p/7452572.html" target="_blank" rel="noopener">android音视频学习</a><br><a href="https://blog.csdn.net/ywl5320/article/details/80335290" target="_blank" rel="noopener">Android音视频开发详解</a><br><a href="https://blog.csdn.net/eydwyz/article/details/79112260" target="_blank" rel="noopener">Android音视频开发进阶</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/renhui/p/7452572.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;android音视频学习&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CheckBox改变样式</title>
    <link href="https://ruanyandong.github.io/2019/03/12/CheckBox%E6%94%B9%E5%8F%98%E6%A0%B7%E5%BC%8F/"/>
    <id>https://ruanyandong.github.io/2019/03/12/CheckBox改变样式/</id>
    <published>2019-03-12T05:11:01.000Z</published>
    <updated>2019-03-12T05:19:27.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-自定义CheckBox样式"><a href="#Android-自定义CheckBox样式" class="headerlink" title="Android 自定义CheckBox样式"></a>Android 自定义CheckBox样式</h1><h2 id="一、修改checkbox选项框样式"><a href="#一、修改checkbox选项框样式" class="headerlink" title="一、修改checkbox选项框样式"></a>一、修改checkbox选项框样式</h2><h3 id="首先我们要找到两张checkbox选项框的图片："><a href="#首先我们要找到两张checkbox选项框的图片：" class="headerlink" title="首先我们要找到两张checkbox选项框的图片："></a>首先我们要找到两张checkbox选项框的图片：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">normal.png</span><br><span class="line"></span><br><span class="line">checked.png</span><br></pre></td></tr></table></figure><h3 id="然后我们设置一个背景选择器checkbox-style-xml："><a href="#然后我们设置一个背景选择器checkbox-style-xml：" class="headerlink" title="然后我们设置一个背景选择器checkbox_style.xml："></a>然后我们设置一个背景选择器checkbox_style.xml：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/checked&quot; android:state_checked=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/normal&quot; android:state_checked=&quot;false&quot;/&gt;</span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/normal&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/selector&gt;</span><br></pre></td></tr></table></figure><h3 id="到这里，在往下有两种方案，一种是直接在布局文件的android：button属性中设置："><a href="#到这里，在往下有两种方案，一种是直接在布局文件的android：button属性中设置：" class="headerlink" title="到这里，在往下有两种方案，一种是直接在布局文件的android：button属性中设置："></a>到这里，在往下有两种方案，一种是直接在布局文件的android：button属性中设置：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;CheckBox</span><br><span class="line">            android:id=&quot;@+id/checkbox1&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:text=&quot;@strings/check_text&quot;</span><br><span class="line">            android:button=&quot;@drawable/checkbox_style&quot;</span><br><span class="line">            android:checked=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure><h3 id="还有一种是在style-xml文件中添加样式MyCheckboxStyle，并在布局文件中的style属性中设置："><a href="#还有一种是在style-xml文件中添加样式MyCheckboxStyle，并在布局文件中的style属性中设置：" class="headerlink" title="还有一种是在style.xml文件中添加样式MyCheckboxStyle，并在布局文件中的style属性中设置："></a>还有一种是在style.xml文件中添加样式MyCheckboxStyle，并在布局文件中的style属性中设置：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;MyCheckboxStyle&quot; parent=&quot;@android:style/Widget.CompoundButton.CheckBox&quot;&gt;</span><br><span class="line">    &lt;item name=&quot;android:button&quot;&gt;@drawable/checkbox_style&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;CheckBox</span><br><span class="line">        android:id=&quot;@+id/checkbox1&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        style=&quot;@style/MyCheckboxStyle&quot; /&gt;</span><br></pre></td></tr></table></figure><h2 id="二、去掉选项框，自定义类Button样式"><a href="#二、去掉选项框，自定义类Button样式" class="headerlink" title="二、去掉选项框，自定义类Button样式"></a>二、去掉选项框，自定义类Button样式</h2><h3 id="同样，我们需要来一个selector-checkbox-style-xml，但是这里的图片就不是选项框的图片了，而是整个checkbox的背景图片"><a href="#同样，我们需要来一个selector-checkbox-style-xml，但是这里的图片就不是选项框的图片了，而是整个checkbox的背景图片" class="headerlink" title="同样，我们需要来一个selector checkbox_style.xml，但是这里的图片就不是选项框的图片了，而是整个checkbox的背景图片"></a>同样，我们需要来一个selector checkbox_style.xml，但是这里的图片就不是选项框的图片了，而是整个checkbox的背景图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/checked&quot; android:state_checked=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/normal&quot; android:state_checked=&quot;false&quot;/&gt;</span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/normal&quot;/&gt;</span><br></pre></td></tr></table></figure><h3 id="然后，我们可以在布局文件中将android：button属性设置为“-null”来去掉选项框，并且在android：background属性中设置："><a href="#然后，我们可以在布局文件中将android：button属性设置为“-null”来去掉选项框，并且在android：background属性中设置：" class="headerlink" title="然后，我们可以在布局文件中将android：button属性设置为“@null”来去掉选项框，并且在android：background属性中设置："></a>然后，我们可以在布局文件中将android：button属性设置为“@null”来去掉选项框，并且在android：background属性中设置：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;CheckBox</span><br><span class="line">            android:id=&quot;@+id/checkbox1&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:background=&quot;@drawable/checkbox_style&quot;</span><br><span class="line">            android:button=&quot;@null&quot;</span><br><span class="line">            android:checked=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure><h2 id="文章链接"><a href="#文章链接" class="headerlink" title="文章链接"></a>文章链接</h2><p><a href="https://www.cnblogs.com/lihualuo/p/3665847.html" target="_blank" rel="noopener">Android知识整理（3） 两种自定义样式的Checkbox</a><br><a href="https://www.cnblogs.com/Claire6649/p/5941145.html" target="_blank" rel="noopener">Android 自定义CheckBox样式</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android-自定义CheckBox样式&quot;&gt;&lt;a href=&quot;#Android-自定义CheckBox样式&quot; class=&quot;headerlink&quot; title=&quot;Android 自定义CheckBox样式&quot;&gt;&lt;/a&gt;Android 自定义CheckBox样式&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JDBC学习</title>
    <link href="https://ruanyandong.github.io/2018/12/30/JDBC%E5%AD%A6%E4%B9%A0/"/>
    <id>https://ruanyandong.github.io/2018/12/30/JDBC学习/</id>
    <published>2018-12-30T10:00:44.000Z</published>
    <updated>2018-12-30T13:27:41.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDBC之存贮过程的调用"><a href="#JDBC之存贮过程的调用" class="headerlink" title="JDBC之存贮过程的调用"></a>JDBC之存贮过程的调用</h1><h2 id="存储过程的代码"><a href="#存储过程的代码" class="headerlink" title="存储过程的代码"></a>存储过程的代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE imooc_db.sp_select_nofilter()</span><br><span class="line">BEGIN</span><br><span class="line">     select * from imooc_goddess;</span><br><span class="line">END;</span><br><span class="line">imooc_db是数据库的名字，sp_select_nofilter()是存储过程的方法名；</span><br></pre></td></tr></table></figure><h2 id="调用代码"><a href="#调用代码" class="headerlink" title="调用代码"></a>调用代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = DBUtil.getConnection();</span><br><span class="line">CallableStatement cs = conn.prepareCall(&quot;&#123;call sp_select_nofilter()&#125;&quot;);</span><br><span class="line">cs.execute();</span><br><span class="line">ResultSet rs = cd.getResultSet();</span><br></pre></td></tr></table></figure><h2 id="博客链接"><a href="#博客链接" class="headerlink" title="博客链接"></a>博客链接</h2><p>  <a href="https://www.cnblogs.com/Qian123/p/5349884.html" target="_blank" rel="noopener">JDBC慕课学习博客链接</a><br>  <a href="https://blog.csdn.net/wqc19920906/article/details/72825793" target="_blank" rel="noopener">Java 数据库系列教程–C3P0详解</a><br>  <a href="https://baike.baidu.com/item/c3p0" target="_blank" rel="noopener">c3p0配置</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JDBC之存贮过程的调用&quot;&gt;&lt;a href=&quot;#JDBC之存贮过程的调用&quot; class=&quot;headerlink&quot; title=&quot;JDBC之存贮过程的调用&quot;&gt;&lt;/a&gt;JDBC之存贮过程的调用&lt;/h1&gt;&lt;h2 id=&quot;存储过程的代码&quot;&gt;&lt;a href=&quot;#存储过程的代
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DialogFragment的宽高设置</title>
    <link href="https://ruanyandong.github.io/2018/12/29/DialogFragment%E7%9A%84%E5%AE%BD%E9%AB%98%E8%AE%BE%E7%BD%AE/"/>
    <id>https://ruanyandong.github.io/2018/12/29/DialogFragment的宽高设置/</id>
    <published>2018-12-28T17:56:34.000Z</published>
    <updated>2018-12-28T18:02:50.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onResume() &#123;</span><br><span class="line">    ViewGroup.LayoutParams params = getDialog().getWindow().getAttributes();</span><br><span class="line">    params.width = LayoutParams.MATCH_PARENT;</span><br><span class="line">    params.height = LayoutParams.MATCH_PARENT;</span><br><span class="line">    getDialog().getWindow().setAttributes((android.view.WindowManager.LayoutParams) params);</span><br><span class="line"></span><br><span class="line">    super.onResume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onResume() &#123;</span><br><span class="line">    getDialog().getWindow().setLayout(width, height);</span><br><span class="line">    super.onResume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;方法一&quot;&gt;&lt;a href=&quot;#方法一&quot; class=&quot;headerlink&quot; title=&quot;方法一&quot;&gt;&lt;/a&gt;方法一&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android依赖管理与私服搭建</title>
    <link href="https://ruanyandong.github.io/2018/12/03/Android%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E4%B8%8E%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/"/>
    <id>https://ruanyandong.github.io/2018/12/03/Android依赖管理与私服搭建/</id>
    <published>2018-12-02T17:37:17.000Z</published>
    <updated>2018-12-03T13:18:52.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android引入依赖的多种方式"><a href="#Android引入依赖的多种方式" class="headerlink" title="Android引入依赖的多种方式"></a>Android引入依赖的多种方式</h1><h2 id="一、第三方jar包"><a href="#一、第三方jar包" class="headerlink" title="一、第三方jar包"></a>一、第三方jar包</h2><p>   步骤：将jar包放入libs目录下面，然后add as library</p><h2 id="二、依赖本地模块"><a href="#二、依赖本地模块" class="headerlink" title="二、依赖本地模块"></a>二、依赖本地模块</h2><p>   步骤：新建本地module或者library，然后用本地模块进行依赖，例如：implementation project(‘:mylibrary’)</p><h2 id="三、aar方式依赖本地模块"><a href="#三、aar方式依赖本地模块" class="headerlink" title="三、aar方式依赖本地模块"></a>三、aar方式依赖本地模块</h2><p>   步骤：新建本地module或者library，然后build或者rebuild整个project，<br>   然后在新建的module或者library的build目录下的output目录下的aar目录，将aar文件放入需要依赖的libs目录下面，<br>   然后在gradle中加入一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">repositories&#123;</span><br><span class="line">        flatDir&#123;</span><br><span class="line">            dirs &apos;libs&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">implementation(name:&apos;lib2&apos;,ext:&apos;aar&apos;)</span><br><span class="line">name是aar文件的名字，ext是后缀名</span><br></pre></td></tr></table></figure></p><h2 id="四、在相应的gradle文件依赖"><a href="#四、在相应的gradle文件依赖" class="headerlink" title="四、在相应的gradle文件依赖"></a>四、在相应的gradle文件依赖</h2><p>   步骤：直接在dependencies进行implementation<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：implementation &apos;com.android.support:appcompat-v7:28.0.0&apos;</span><br></pre></td></tr></table></figure></p><h1 id="私服Nexus的获取和windows平台搭建"><a href="#私服Nexus的获取和windows平台搭建" class="headerlink" title="私服Nexus的获取和windows平台搭建"></a>私服Nexus的获取和windows平台搭建<img src="http://www.sonatype.com" alt="网址"></h1><p>  以下是一些参考博客</p><ul><li><a href="https://www.jianshu.com/p/b1fe26d5b8c8" target="_blank" rel="noopener">maven私服搭建及gradle上传</a>  </li><li><a href="https://blog.csdn.net/huweijian5/article/details/56670569" target="_blank" rel="noopener">Windows下搭建基于Nexus的Android Maven私服(一)</a></li><li><a href="https://blog.csdn.net/huweijian5/article/details/56834199" target="_blank" rel="noopener">Windows下搭建基于Nexus的Android Maven私服(二)</a></li><li><a href="https://www.jianshu.com/p/e8d999465edf" target="_blank" rel="noopener">Gradle中文教程系列-跟我学Gradle-4.1：Nexus私服的安装与配置</a></li><li><a href="https://blog.csdn.net/u011974987/article/details/52372185" target="_blank" rel="noopener">使用Gradle和Sonatype Nexus 搭建私有maven仓库</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android引入依赖的多种方式&quot;&gt;&lt;a href=&quot;#Android引入依赖的多种方式&quot; class=&quot;headerlink&quot; title=&quot;Android引入依赖的多种方式&quot;&gt;&lt;/a&gt;Android引入依赖的多种方式&lt;/h1&gt;&lt;h2 id=&quot;一、第三方jar包
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android绘图基础</title>
    <link href="https://ruanyandong.github.io/2018/11/15/Android%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80/"/>
    <id>https://ruanyandong.github.io/2018/11/15/Android绘图基础/</id>
    <published>2018-11-15T12:51:18.000Z</published>
    <updated>2018-11-15T13:08:31.039Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自定义控件之绘图篇：区域（Region）"><a href="#自定义控件之绘图篇：区域（Region）" class="headerlink" title="自定义控件之绘图篇：区域（Region）"></a><a href="https://blog.csdn.net/lu1024188315/article/details/77197968" target="_blank" rel="noopener">自定义控件之绘图篇：区域（Region）</a></h1><h1 id="自定义控件之绘图篇（三）：区域（Range）"><a href="#自定义控件之绘图篇（三）：区域（Range）" class="headerlink" title="自定义控件之绘图篇（三）：区域（Range）"></a><a href="https://blog.csdn.net/harvic880925/article/details/39056701" target="_blank" rel="noopener">自定义控件之绘图篇（三）：区域（Range）</a></h1><h1 id="android-Graphics：区域（Region）"><a href="#android-Graphics：区域（Region）" class="headerlink" title="android Graphics：区域（Region）"></a><a href="https://blog.csdn.net/wurensen/article/details/46437471" target="_blank" rel="noopener">android Graphics：区域（Region）</a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;自定义控件之绘图篇：区域（Region）&quot;&gt;&lt;a href=&quot;#自定义控件之绘图篇：区域（Region）&quot; class=&quot;headerlink&quot; title=&quot;自定义控件之绘图篇：区域（Region）&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://blog.csdn
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android事件分发</title>
    <link href="https://ruanyandong.github.io/2018/10/28/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"/>
    <id>https://ruanyandong.github.io/2018/10/28/Android事件分发/</id>
    <published>2018-10-28T10:29:23.000Z</published>
    <updated>2018-10-28T10:40:11.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h1><p>1.只有view，ViewGroup，Activity 具有事件分发和消费的功能。<br>2.Activity因为上最先接触到触摸事件，因此Activity没有事件拦截方法。即没有onInterceptTouchEvent方法。<br>3.对于不能添加子控件的view，不能对事件进行分发和拦截，它只有onTouchEvent事件。</p><h1 id="二-三个方法"><a href="#二-三个方法" class="headerlink" title="二.三个方法"></a>二.三个方法</h1><ul><li><p>1.public boolean dispatchTouchEvent(MotionEvent ev)<br>当触摸事件发生的时候，首先会被当前的activity进行分发，即当前activity的dispatchTouchEvent方法会被执行。<br>这个时候,该方法有三种返回的情况：</p><pre><code>return false： 表明事件不会被进行分发。事件会以冒泡的方式被传递给上层的view或activity的onTouchEvent方法进行消费掉。return true：表明该时间已经被处理。事件会被当前view或activity的dispatchTouchEvent给消费掉。不会再进行传递，事件到此结束。return super.dispatchTouchEvent(ev)：表明该事件将会被分发。此时当前View的onIntercepterTouchEvent方法会捕获该事件，判断需不需要进行事件的拦截。</code></pre></li><li><p>2.public boolean onInterceptTouchEvent(MotionEvent ev)<br>该方法用户拦截被传递过来的事件，用于判断被传递过来的事件是否需要被当前的view进行处理。<br>   return false : 不对事件进行拦截，放行该事件。事件会被传递到当前view的子控件中，由子控件中的dispatchTouchEvent方法进行分发处理。<br>   return true : 拦截该事件，将该事件交给当前view的onTouchEvent方法进行处理。<br>   return super.inInterceptTouchEvent(ev)：默认拦截方式，和return true一样。该事件会被拦截，将该事件交给当前view的onTouchEvent方法进行处理。（这里需要有一点说明，当有两个view。A view中有一个B view.点击A.A中如果onInterceptTouchEvent()返回super.interceptTouchEvent(ev),则事件将会被A进行拦截，交给A的onTouchEvent()进行处理，如果点击的是B，A中如果onInterceptTouchEvent()返回super.interceptTouchEvent(ev)，则事件将不会被拦截，会被分发到子控件中）</p></li><li><p>3.public boolean onTouchEvent(MotionEvent event)<br>当前的view把事件进行了拦截，则事件则会被传递到该方法中<br>   return false：表明没有消费该事件，事件将会以冒泡的方式一直被传递到上层的view或Activity中的onTouchEvent事件处理。如果最上层的view或Activity中的onTouchEvent还是返回false。则该事件将消失。接下来来的一系列事件都将会直接被上层的onTouchEvent方法捕获<br>   return true: 表明消费了该事件，事件到此结束。<br>   return super.onTouchEvent(event)：默认情况，和return false一样。</p></li></ul><h1 id="验证"><a href="#验证" class="headerlink" title="验证:"></a>验证:</h1><p>MainActivity FatherView ChildView中几个方法都返回super.<em>**</em>TouchEvent(ev)<br>     分析:</p><pre><code>当点击屏幕。MainActivity 中的dispatchTouchEvent方法先执行，打印MainActivity-dispatchTouchEvent--&gt;ACTION_DOWN因为返回的是super.dispatchTouchEvent(ev),所以事件ev将会被分发，但是MainActivity中没有onInterceptTouchEvent()方法，所以事件被传递到FatherView中的dispatchTouchEvent方法.打印FatherView-dispatchTouchEvent--&gt;ACTION_DOWN在FatherView中dispatchTouchEvent返回的是super.dispatchTouchEvent(ev),所有事件会被分发。FatherView中的onInterceptTouchEven()中的方法被执行。打印FatherView-onInterceptTouchEven--&gt;ACTION_DOWNFatherView中的onInterceptTouchEven()返回的是super.onInterceptTouchEvent(ev)。在这里，（1）如果点击的是屏幕中的ChildView。事件将不会被拦截，会被传递到ChildView中的dispatchTouchEvent方法中。（2）如果点击的值FatherView则事件将会被拦截。FatherView中的onTouchEvent()方法将被执行。以（1）为例，将打印ChildView-dispatchTouchEvent--&gt;ACTION_DOWN。ChildView中dispatchTouchEvent返回的是super.dispatchTouchEvent(ev),所有事件会被分发。打印ChildView-onInterceptTouchEvent--&gt;ACTION_DOWN。此时ChildView中onInterceptTouchEvent返回的是super.onInterceptTouchEvent(ev),，而且已经没有子控件了，所以事件将被拦截。打印ChildView-onTouchEvent--&gt;ACTION_DOWN。在childView中onTouchEvent()返回额是super.onTouchEvent(ev)。事件将不会被消耗，将以冒泡的方式传递到上层空间中的onTouchEvent(),此处上层空间中的onTouchEvent返回的都是super.onTouchEvent(ev)。所以讲一次打印 Father-onTouchEvent--&gt;ACTION_DOWN。 MainActivty-onTouchEvent--&gt;ACTION_DOWN。之后的事件动作，将不再被MainActivity分发到子view，直接被MainActivty中的onTouchEvent处理消耗。打印MainActivity-dispatchTouchEvent--&gt;ACTION_UP,MainActivty-onTouchEvent--&gt;ACTION_UP        MainActivity-dispatchTouchEvent--&gt;ACTION_DOWN        FatherView-dispatchTouchEvent--&gt;ACTION_DOWN        FatherView-onInterceptTouchEven--&gt;ACTION_DOWN        ChildView-dispatchTouchEvent--&gt;ACTION_DOWN        ChildView-onInterceptTouchEvent--&gt;ACTION_DOWN。        ChildView-onTouchEvent--&gt;ACTION_DOWN        Father-onTouchEvent--&gt;ACTION_DOWN。         MainActivty-onTouchEvent--&gt;ACTION_DOWN        MainActivity-dispatchTouchEvent--&gt;ACTION_UP,        MainActivty-onTouchEvent--&gt;ACTION_UP</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一. 概述&quot;&gt;&lt;/a&gt;一. 概述&lt;/h1&gt;&lt;p&gt;1.只有view，ViewGroup，Activity 具有事件分发和消费的功能。&lt;br&gt;2.Activity因为上最先
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android应用安装和卸载时的广播</title>
    <link href="https://ruanyandong.github.io/2018/10/23/Android%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD%E6%97%B6%E7%9A%84%E5%B9%BF%E6%92%AD/"/>
    <id>https://ruanyandong.github.io/2018/10/23/Android应用安装和卸载时的广播/</id>
    <published>2018-10-23T12:12:46.000Z</published>
    <updated>2018-10-23T12:21:02.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在android系统中，安装和卸载都会发送广播，当应用安装完成后系统会发android-intent-action-PACKAGE-ADDED广播。"><a href="#在android系统中，安装和卸载都会发送广播，当应用安装完成后系统会发android-intent-action-PACKAGE-ADDED广播。" class="headerlink" title="在android系统中，安装和卸载都会发送广播，当应用安装完成后系统会发android.intent.action.PACKAGE_ADDED广播。"></a>在android系统中，安装和卸载都会发送广播，当应用安装完成后系统会发android.intent.action.PACKAGE_ADDED广播。</h2><p>   可以通过intent.getDataString()获得所安装的包名。当卸载程序时系统发android.intent.action.PACKAGE_REMOVED广播。<br>   同样intent.getDataString()获得所卸载的包名。</p><h2 id="在安卓APP项目开发中，我们有这样的需求："><a href="#在安卓APP项目开发中，我们有这样的需求：" class="headerlink" title="在安卓APP项目开发中，我们有这样的需求："></a>在安卓APP项目开发中，我们有这样的需求：</h2><pre><code>APP安装更新完成后，需要把 APK 文件删除</code></pre><p>这里，我们可以通过安卓四大组件之一 —— 广播-接收器，来助阵。</p><p>广播有动态注册和静态注册两种方式，此处用静态注册方式。</p><p>在 AndroidManifest.xml 文件中静态注册广播接收器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver android:name=&quot;具体包名.广播接收器名&quot;</span><br><span class="line">            android:enabled=&quot;true&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=&quot;android.intent.action.PACKAGE_ADDED&quot; /&gt;</span><br><span class="line">                &lt;action android:name=&quot;android.intent.action.PACKAGE_REPLACED&quot; /&gt;</span><br><span class="line">                &lt;action android:name=&quot;android.intent.action.PACKAGE_REMOVED&quot; /&gt;</span><br><span class="line">                &lt;!--涉及到存储卡状态改变的时候必须添加--&gt;</span><br><span class="line">                &lt;data android:scheme=&quot;package&quot; /&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/receiver&gt;</span><br></pre></td></tr></table></figure></p><h1 id="几个-intent-filter-name-相信从名字就能知道什么意思了。"><a href="#几个-intent-filter-name-相信从名字就能知道什么意思了。" class="headerlink" title="几个 intent-filter name 相信从名字就能知道什么意思了。"></a>几个 intent-filter name 相信从名字就能知道什么意思了。</h1><pre><code>PACKAGE_ADDED 接受包被添加时发送的广播PACKAGE_REPLACED 接受包被替换时发送的广播PACKAGE_REMOVED 接受包被移除时发送的广播</code></pre><p>安卓系统在我们安装或卸载APP等操作时，会发送以上的一些广播包，我们这里设个接收器来”监听“这些操作的发生。</p><p>新建一个类，继承自 BroadcastReceiver，重写 onReceive 方法，具体逻辑处理可在此书写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import android.content.BroadcastReceiver;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.os.Environment;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by Moses on 2017/12/5.</span><br><span class="line"> *</span><br><span class="line"> * PackageInstallSuccessfulReceiver</span><br><span class="line"> *</span><br><span class="line"> * 接受 广播 软件包被添加、删除和替换时发出</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class PackInstSucRecei extends BroadcastReceiver &#123;</span><br><span class="line">    private String apkfileName = &quot;app-debug.apk&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line"></span><br><span class="line">        if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())) &#123;</span><br><span class="line">            Log.d(TAG, &quot;监听到系统广播,包被添加: &quot;);</span><br><span class="line">            //删除apk文件</span><br><span class="line">            deleteApkfile(apkfileName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (Intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction())) &#123;</span><br><span class="line">            Log.d(TAG, &quot;监听到系统广播,包被移除: &quot;);</span><br><span class="line">            Log.d(TAG, &quot;onReceive: &quot; + intent.getDataString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (Intent.ACTION_PACKAGE_REPLACED.equals(intent.getAction())) &#123;</span><br><span class="line">            Log.d(TAG, &quot;监听到系统广播,包被替换: &quot;);</span><br><span class="line">            Log.d(TAG, &quot;onReceive: &quot;+ intent.getPackage());</span><br><span class="line">            deleteApkfile(apkfileName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Boolean deleteApkfile(String apkFileName)&#123;</span><br><span class="line">        //Apk文件路径可自定义，此处用 download 文件夹</span><br><span class="line">        File apkfile = new File(Environment</span><br><span class="line">                .getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)</span><br><span class="line">                .getPath(), apkFileName);</span><br><span class="line">        if (!apkfile.exists()) &#123;</span><br><span class="line">            Log.d(TAG, &quot;apkfile delete already! &quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //调用现成的文件操作方法删除文件</span><br><span class="line">            if (apkfile.delete())</span><br><span class="line">                Log.d(TAG, &quot;apkfile delete successfully! &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;在android系统中，安装和卸载都会发送广播，当应用安装完成后系统会发android-intent-action-PACKAGE-ADDED广播。&quot;&gt;&lt;a href=&quot;#在android系统中，安装和卸载都会发送广播，当应用安装完成后系统会发android-in
      
    
    </summary>
    
    
  </entry>
  
</feed>
