<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>灵魂长者的博客</title>
  
  <subtitle>科技改变世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ruanyandong.github.io/"/>
  <updated>2020-02-16T15:10:14.980Z</updated>
  <id>https://ruanyandong.github.io/</id>
  
  <author>
    <name>阮严冬</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android沉浸式状态栏</title>
    <link href="https://ruanyandong.github.io/2020/02/16/Android%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E6%A0%8F/"/>
    <id>https://ruanyandong.github.io/2020/02/16/Android沉浸式状态栏/</id>
    <published>2020-02-16T15:08:22.000Z</published>
    <updated>2020-02-16T15:10:14.980Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前做过Android沉浸式状态栏的相关需求，但是一直忙于工作，没时间系统的整理下沉浸式相关的知识，所以今天抽出时间，写一篇 Android沉浸式状态栏的文章。</p><h1 id="何为沉浸式"><a href="#何为沉浸式" class="headerlink" title="何为沉浸式"></a>何为沉浸式</h1><p><strong>沉浸式</strong>就是要给用户提供完全沉浸的体验，使用户有一种置身于虚拟世界之中的感觉。<br><strong>沉浸式模式</strong>就是整个屏幕中显示都是应用的内容，没有状态栏也没有导航栏，用户不会被一些系统的界面元素所打扰。<br><strong>Android沉浸式模式</strong>的本质就是全屏化，但这可能并不是我们想要的，我们还是来实现下网上传的沸沸扬扬的<strong>Android沉浸式状态栏</strong></p><h1 id="沉浸式状态栏的兼容情况"><a href="#沉浸式状态栏的兼容情况" class="headerlink" title="沉浸式状态栏的兼容情况"></a>沉浸式状态栏的兼容情况</h1><table><thead><tr><th>Android版本</th><th>透明状态栏</th></tr></thead><tbody><tr><td>&lt;4.4</td><td>×</td></tr><tr><td>4.4-5.0</td><td>✓</td></tr><tr><td>&gt;=5.0</td><td>✓</td></tr></tbody></table><table><thead><tr><th>Android版本</th><th>黑白字符状态栏</th></tr></thead><tbody><tr><td>&lt;6.0</td><td>×</td></tr><tr><td>&gt;=6.0</td><td>✓</td></tr></tbody></table><h1 id="fitsSystemWindows"><a href="#fitsSystemWindows" class="headerlink" title="fitsSystemWindows"></a>fitsSystemWindows</h1><p>在讲沉浸式状态栏之前，我们先来认识一个属性——fitsSystemWindows，这个属性在沉浸式状态中扮演着非常重要的角色。</p><ul><li>官方描述</li></ul><blockquote><p>Boolean internal attribute to adjust view layout based on system<br>windows such as the status bar. If true, adjusts the padding of this view to leave space for the system windows. Will only take effect if this view is in a non-embedded activity.</p></blockquote><ul><li>中文描述</li></ul><blockquote><p>Boolean内部属性是基于系统窗口（如status bar）调整视图布局。如果为true，将调整视图padding为系统窗口预留出空间。Will only take effect if this view is in a non-embedded activity.<br> 这句话的意思是view不在非嵌入式的activity才会生效。<br> 嵌入式activity是托管在父activity中的活动。常见的例子是TabHost / TabActivity设计。特别是，嵌入式Acitvities位于主机中 LocalActivityManager，这在概念上类似于 FragmentManager 它允许您在另一个内部显示一个Activity。</p></blockquote><p>根据这个定义，很容易理解为什么只有主机（非嵌入式）Activity才能支持 fitsSystemWindows 属性，因为任何嵌入的活动都限制在其主机定义的区域内。</p><ul><li>注意：<blockquote><p>fitsSystemWindows只作用在sdk&gt;=19的系统上就是高于4.4的系统，android:fitsSystemWindows默认值为false，并且在哪个控件设置android:fitsSystemWindows=”true”会有不一样的效果</p></blockquote></li></ul><p>android:fitsSystemWindows=”true”，这个属性可以给任何view设置,只要设置了这个属性此view的所有padding属性失效.只有在设置了透明状态栏(StatusBar)或者导航栏(NavigationBar)此属性才会生效</p><p><strong>当设置了透明状态栏(StatusBar)时:</strong><br>当为此activity设置了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;item name="android:windowTranslucentStatus"&gt;true&lt;/item&gt;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">   getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果有以上两种情况之一,我们的状态栏(StatusBar)就会变成透明,并且布局会扩展到StatusBar的位置同时,所有设置了android:fitsSystemWindows=”true”属性的view会自动添加一个值等于状态栏高度的paddingTop</p><p><strong>当设置了透明导航栏(NavigationBar)时:</strong><br>当为此activity设置了:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;item name="android:windowTranslucentNavigation"&gt;true&lt;/item&gt;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">    getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果有以上两种情况之一,我们的导航栏(NavigationBar)就会变成透明,并且布局会扩展到NavigationBar的位置。同时,所有设置了android:fitsSystemWindows=”true”属性的view会自动添加一个值等于导航栏高度的paddingBottom。</p><h1 id="沉浸式状态栏实现的一般思路"><a href="#沉浸式状态栏实现的一般思路" class="headerlink" title="沉浸式状态栏实现的一般思路"></a>沉浸式状态栏实现的一般思路</h1><ul><li><strong>4.4以下版本：</strong> 我们可以对StatusBar和 NavigationBar进行显示和隐藏操作，但无法实现沉浸式状态栏。</li><li><p><strong>Android4.4（API 19） - Android 5.0（API 21)：</strong> 通过FLAG_TRANSLUCENT_STATUS设置状态栏为透明并且为全屏模式，然后通过添加一个与StatusBar 一样大小的View，将View 的 background 设置为我们想要的颜色，从而来实现沉浸式。</p></li><li><p><strong>Android 5.0（API 21）以上版本：</strong> 在Android 5.0的时候，加入了一个重要的属性和方法 android:statusBarColor （对应方法为 setStatusBarColor），通过这个方法我们就可以轻松实现沉浸式。也就是说，从Android5.0开始，系统才真正的支持沉浸式。</p></li><li><p><strong>Android 6.0（API 23）以上版本：</strong> Android6.0以上的实现方式和Android 5.0 +是一样，但从Android 6.0（API 23）开始，我们可以改状态栏的绘制模式，可以显示白色或浅黑色的内容和图标（除了魅族手机，魅族自家有做源码更改，6.0以下就能实现）</p></li></ul><h3 id="Android4-4（API-19）-Android-5-0（API-21）实现沉浸式的方式"><a href="#Android4-4（API-19）-Android-5-0（API-21）实现沉浸式的方式" class="headerlink" title="Android4.4（API 19） - Android 5.0（API 21）实现沉浸式的方式"></a>Android4.4（API 19） - Android 5.0（API 21）实现沉浸式的方式</h3><p>Android 4.4 为什么能够实现沉浸式的效果呢？因为在Android 4.4 新增了一个重要的属性：<strong>FLAG_TRANSLUCENT_STATUS</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Window flag: request a translucent status bar with minimal system-provided</span></span><br><span class="line"><span class="comment">        * background protection.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * &lt;p&gt;This flag can be controlled in your theme through the</span></span><br><span class="line"><span class="comment">        * &#123;<span class="doctag">@link</span> android.R.attr#windowTranslucentStatus&#125; attribute; this attribute</span></span><br><span class="line"><span class="comment">        * is automatically set for you in the standard translucent decor themes</span></span><br><span class="line"><span class="comment">        * such as</span></span><br><span class="line"><span class="comment">        * &#123;<span class="doctag">@link</span> android.R.style#Theme_Holo_NoActionBar_TranslucentDecor&#125;,</span></span><br><span class="line"><span class="comment">        * &#123;<span class="doctag">@link</span> android.R.style#Theme_Holo_Light_NoActionBar_TranslucentDecor&#125;,</span></span><br><span class="line"><span class="comment">        * &#123;<span class="doctag">@link</span> android.R.style#Theme_DeviceDefault_NoActionBar_TranslucentDecor&#125;, and</span></span><br><span class="line"><span class="comment">        * &#123;<span class="doctag">@link</span> android.R.style#Theme_DeviceDefault_Light_NoActionBar_TranslucentDecor&#125;.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * &lt;p&gt;When this flag is enabled for a window, it automatically sets</span></span><br><span class="line"><span class="comment">        * the system UI visibility flags &#123;<span class="doctag">@link</span> View#SYSTEM_UI_FLAG_LAYOUT_STABLE&#125; and</span></span><br><span class="line"><span class="comment">        * &#123;<span class="doctag">@link</span> View#SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN&#125;.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_TRANSLUCENT_STATUS = <span class="number">0x04000000</span>;</span><br></pre></td></tr></table></figure></p><blockquote><p> 解释：设置状态栏透明，并且变为全屏模式。上面的解释已经说得很清楚了，当window的这个属性有效的时候，会自动设置 system ui visibility的标志SYSTEM_UI_FLAG_LAYOUT_STABLE和SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN.</p></blockquote><p><strong>有两种方式实现这个属性：</strong></p><p><strong>可以在代码中设置</strong>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br></pre></td></tr></table></figure><p><strong>当然也可以在theme 中设置属性windowTranslucentStatus</strong>,如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:windowTranslucentStatus</span><br></pre></td></tr></table></figure></p><p>效果如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy84LzgvMTgzMDA4MzVmZGU4NzExOThlMzkwZTU5NWIwYTRkNzI?x-oss-process=image/format,png#pic_center" alt="Alt"><br>效果如上图，可以看出，沉浸式的效果是出来了，但是也有一个问题，<strong>我们的标题栏和状态栏重叠了</strong>，相当于整个布局上移了StatusBar 的高度。<strong>为了让标题栏回到原来的位置，我们在标题栏的上方添加一个大小和StatusBar大小一样的View,View 的BackgroundColor 为标题栏一样的颜色，这个View起到一个占位的作用。这个时候，标题栏就会下移StatusBar的高度，回到正常的位置。</strong><br>添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取windowphone下的decorView</span></span><br><span class="line"> ViewGroup decorView = (ViewGroup) activity.getWindow().getDecorView();</span><br><span class="line"> <span class="keyword">int</span>       count     = decorView.getChildCount();</span><br><span class="line"> <span class="comment">//判断是否已经添加了statusBarView</span></span><br><span class="line"> <span class="keyword">if</span> (count &gt; <span class="number">0</span> &amp;&amp; decorView.getChildAt(count - <span class="number">1</span>) <span class="keyword">instanceof</span> StatusBarView) &#123;</span><br><span class="line">     decorView.getChildAt(count - <span class="number">1</span>).setBackgroundColor(calculateStatusColor(color, statusBarAlpha));</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">//新建一个和状态栏高宽的view</span></span><br><span class="line">     StatusBarView statusView = createStatusBarView(activity, color, statusBarAlpha);</span><br><span class="line">     decorView.addView(statusView);</span><br><span class="line"> &#125;</span><br><span class="line"> ViewGroup rootView = (ViewGroup) ((ViewGroup) activity.findViewById(android.R.id.content)).getChildAt(<span class="number">0</span>);</span><br><span class="line"> <span class="comment">//rootview不会为状态栏留出状态栏空间</span></span><br><span class="line"> ViewCompat.setFitsSystemWindows(rootView,<span class="keyword">true</span>);</span><br><span class="line"> rootView.setClipToPadding(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>创建和status bar 一样大小的View的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> StatusBarView <span class="title">createStatusBarView</span><span class="params">(Activity activity, <span class="keyword">int</span> color, <span class="keyword">int</span> alpha)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 绘制一个和状态栏一样高的矩形</span></span><br><span class="line">       StatusBarView statusBarView = <span class="keyword">new</span> StatusBarView(activity);</span><br><span class="line">       LinearLayout.LayoutParams params =</span><br><span class="line">               <span class="keyword">new</span> LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, getStatusBarHeight(activity));</span><br><span class="line">       statusBarView.setLayoutParams(params);</span><br><span class="line">       statusBarView.setBackgroundColor(calculateStatusColor(color, alpha));</span><br><span class="line">       <span class="keyword">return</span> statusBarView;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>其中StatusBarView 就是一个普通的View。<br>添加上述代码后，效果如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy84LzgvNjFkNjhmZThjMTkzOGZhNGFkMjEwMjgzZTU0ODRhY2Y?x-oss-process=image/format,png#pic_center" alt="Alt"><br>通过以上就可以实现<strong>Android 4.4 上的沉浸式状态栏</strong>。</p><p>另外，<strong>如果是一张图片延伸到状态栏的话</strong>，直接设置<strong>FLAG_TRANSLUCENT_STATUS</strong>就可以了，如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy84LzgvZmY2Y2M4MmZiZDhhZTVjZjk2OTkyNjI4OWM4ZTQ1YWQ?x-oss-process=image/format,png#pic_center" alt="Alt"></p><blockquote><p>小结：Android4.4上实现沉浸式状态栏的套路是：为window添加FLAG_TRANSLUCENT_STATUS Flag,然后添加一个和status bar 一样大小的View 站位，从而让让标题栏不会与status bar重叠。而图片延伸到状态栏只需要设置FLAG_TRANSLUCENT_STATUS就OK。</p></blockquote><p> 沉浸式在Android4.4 - Android5.0 之间的版本表现得不是很好，从上面贴的几张图就可以看出，状态栏的顶部有一个渐变，会显示出黑色的阴影（底部的导航栏也是一样的效果），在Android 5.0 版本已经被修复了。</p><h3 id="Android-5-0（API-21）以上实现沉浸式的方式"><a href="#Android-5-0（API-21）以上实现沉浸式的方式" class="headerlink" title="Android 5.0（API 21）以上实现沉浸式的方式"></a>Android 5.0（API 21）以上实现沉浸式的方式</h3><p> Android 5.0 是一个里程碑式的版本，从Android 5.0开始，Google 推出了全新的设计规范 Material Design,并且原生控件就可以实现一些炫酷的UI动效。从这个版本开始，google 加入了一个比较重要的方法setStatusBarColor (对应属性：android:statusBarColor),通过这个方法，可以很轻松地实现沉浸式状态栏。方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Sets the color of the status bar to &#123;<span class="doctag">@code</span> color&#125;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * For this to take effect,</span></span><br><span class="line"><span class="comment">    * the window must be drawing the system bar backgrounds with</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> android.view.WindowManager.LayoutParams#FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS&#125; and</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> android.view.WindowManager.LayoutParams#FLAG_TRANSLUCENT_STATUS&#125; must not be set.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * If &#123;<span class="doctag">@code</span> color&#125; is not opaque, consider setting</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> android.view.View#SYSTEM_UI_FLAG_LAYOUT_STABLE&#125; and</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> android.view.View#SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * The transitionName for the view background will be "android:status:background".</span></span><br><span class="line"><span class="comment">    * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setStatusBarColor</span><span class="params">(@ColorInt <span class="keyword">int</span> color)</span></span>;</span><br></pre></td></tr></table></figure><p>注意看这个方法的注释，<strong>想要这个方法生效，必须还要配合一个Flag一起使用，必须设置FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS ,并且不能设置FLAG_TRANSLUCENT_STATUS(Android 4.4才用这个)</strong><br>看一下<strong>FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS</strong>这个flag:<br>可以看到，这个flag 也是在Android 5.0添加的，它的作用是什么呢？</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy84LzgvZDBkZDkwYjQxMDE5MDdlNGM0Mjk5MzMzMjcxY2ExODc?x-oss-process=image/format,png#pic_center" alt="Alt"></p><blockquote><p>解释：设置了FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS,表明会Window负责系统bar的background 绘制，绘制透明背景的系统bar（状态栏和导航栏），然后用getStatusBarColor()和getNavigationBarColor()的颜色填充相应的区域。这就是Android 5.0 以上实现沉浸式导航栏的原理。</p></blockquote><p>实现沉浸式添加如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getWindow().addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);</span><br><span class="line"><span class="comment">//注意要清除 FLAG_TRANSLUCENT_STATUS flag</span></span><br><span class="line">getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">getWindow().setStatusBarColor(getResources().getColor(android.R.color.holo_red_light));</span><br></pre></td></tr></table></figure></p><p>效果如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy84LzgvM2U1NmU0ZThkMWM2NDlhOTJmNWNjMTYyYWI5MjhkMzM?x-oss-process=image/format,png#pic_center" alt="Alt"></p><p>当然也可以直接在Theme中使用，在values-v21文件夹下添加如下主题：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=<span class="string">"MDTheme"</span> parent=<span class="string">"Theme.Design.Light.NoActionBar"</span>&gt;</span><br><span class="line">        &lt;item name="android:windowTranslucentStatus"&gt;false&lt;/item&gt;</span><br><span class="line">        &lt;item name="android:windowDrawsSystemBarBackgrounds"&gt;true&lt;/item&gt;</span><br><span class="line">        &lt;item name="android:statusBarColor"&gt;@android:color/holo_red_light&lt;/item&gt;</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure><p>效果和上面代码中添加的效果一样。</p><p><strong>图片延伸到状态栏</strong></p><p>在<strong>Android 5.0使图片延伸到状态栏</strong>，只需设置windowTranslucentStatus,将 statusBarColor 设置为透明即可：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=<span class="string">"ImageTranslucentTheme"</span> parent=<span class="string">"Theme.AppCompat.DayNight.NoActionBar"</span>&gt;</span><br><span class="line">        &lt;item name="android:windowTranslucentNavigation"&gt;true&lt;/item&gt;</span><br><span class="line">        &lt;item name="android:windowTranslucentStatus"&gt;true&lt;/item&gt;</span><br><span class="line">        &lt;!-- 设置statusBarColor 为透明--&gt;</span><br><span class="line">        &lt;item name="android:statusBarColor"&gt;@android:color/transparent&lt;/item&gt;</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure><p>效果如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy84LzgvY2JiMjYxODFhNGNlNTA1NDdiYWIxMGQ5ZDE0MWNiOGE?x-oss-process=image/format,png#pic_center" alt="Alt"></p><p>代码实现方式中通过版本号的判断兼容 Android5.0以下和Android 5.0以上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">            activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);</span><br><span class="line">            activity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">            activity.getWindow().setStatusBarColor(calculateStatusColor(color, statusBarAlpha));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">            ViewGroup decorView = (ViewGroup) activity.getWindow().getDecorView();</span><br><span class="line">            <span class="keyword">int</span> count = decorView.getChildCount();</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span> &amp;&amp; decorView.getChildAt(count - <span class="number">1</span>) <span class="keyword">instanceof</span> StatusBarView) &#123;</span><br><span class="line">                decorView.getChildAt(count - <span class="number">1</span>).setBackgroundColor(calculateStatusColor(color, statusBarAlpha));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                StatusBarView statusView = createStatusBarView(activity, color, statusBarAlpha);</span><br><span class="line">                decorView.addView(statusView);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ViewGroup rootView = (ViewGroup) ((ViewGroup) activity.findViewById(android.R.id.content)).getChildAt(<span class="number">0</span>);</span><br><span class="line">            rootView.setFitsSystemWindows(<span class="keyword">true</span>);</span><br><span class="line">            rootView.setClipToPadding(<span class="keyword">true</span>);</span><br><span class="line">            setRootView(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Android-6-0-实现状态栏字色和图标浅黑色"><a href="#Android-6-0-实现状态栏字色和图标浅黑色" class="headerlink" title="Android 6.0 + 实现状态栏字色和图标浅黑色"></a>Android 6.0 + 实现状态栏字色和图标浅黑色</h3><p>使用沉浸式的时候会遇到一个问题，那就是<strong>Android 系统状态栏的字色和图标颜色为白色，当我的主题色或者图片接近白色或者为浅色的时候，状态栏上的内容就看不清了</strong>。 这个问题在Android 6.0的时候得到了解决。<strong>Android 6.0 新添加了一个属性SYSTEM_UI_FLAG_LIGHT_STATUS_BAR</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy84LzgvZjIyZDkwOWU5ZjMwMTkzODBhODhmYzNhNDRlZWRiMzc?x-oss-process=image/format,png#pic_center" alt="Alt"></p><blockquote><p>解释：为setSystemUiVisibility(int)方法添加的Flag,请求status bar<br>绘制模式，它可以兼容亮色背景的status bar 。要在设置了FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDSflag<br>,同时清除了FLAG_TRANSLUCENT_STATUSflag 才会生效。</p></blockquote><p>添加如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">            getWindow().getDecorView().setSystemUiVisibility(</span><br><span class="line">                    View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN|View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>效果如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy84LzgvOTA3MGM3NTc3Y2YxYmQwNjM5MDUwNGM5NTRmMzE4NjU?x-oss-process=image/format,png#pic_center" alt="Alt"><br>除了在代码中添加以外，还可以直接在主题中使用属性：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=<span class="string">"MDTheme"</span> parent=<span class="string">"Theme.Design.Light.NoActionBar"</span>&gt;</span><br><span class="line">       &lt;item name="android:windowTranslucentStatus"&gt;false&lt;/item&gt;</span><br><span class="line">       &lt;item name="android:windowDrawsSystemBarBackgrounds"&gt;true&lt;/item&gt;</span><br><span class="line">       &lt;item name="android:statusBarColor"&gt;@android:color/holo_red_light&lt;/item&gt;</span><br><span class="line">       &lt;!-- Android <span class="number">6.0</span>以上 状态栏字色和图标为浅黑色--&gt;</span><br><span class="line">       &lt;item name="android:windowLightStatusBar"&gt;true&lt;/item&gt;</span><br><span class="line">   &lt;/style&gt;</span><br></pre></td></tr></table></figure><p>注意：主题要放在values-v23文件夹下</p><p><strong>参考以下文章</strong><br><a href="https://juejin.im/post/5989ded56fb9a03c3b6c8bde" target="_blank" rel="noopener">Android关于沉浸式状态栏总结</a><br><a href="https://juejin.im/post/5b7d40a4f265da432a6adca5" target="_blank" rel="noopener">Android适配—沉浸式状态栏</a><br><a href="https://jaeger.itscoder.com/android/2016/02/15/status-bar-demo.html" target="_blank" rel="noopener">Android App 沉浸式状态栏解决方案</a><br><a href="https://www.infoq.cn/article/PaCj30OK19ubiSbdrbHG" target="_blank" rel="noopener">Android 沉浸式解析和轮子使用</a><br><a href="https://www.jianshu.com/p/a44c119d6ef7" target="_blank" rel="noopener">Android沉浸式(透明)状态栏适配</a><br><a href="https://blog.csdn.net/guolin_blog/article/details/51763825" target="_blank" rel="noopener">Android状态栏微技巧，带你真正理解沉浸式模式</a><br><a href="https://segmentfault.com/a/1190000017431435" target="_blank" rel="noopener">android沉浸式状态栏封装—教你玩出新花样</a><br><a href="https://github.com/gyf-dev/ImmersionBar" target="_blank" rel="noopener">ImmersionBar – android 4.4以上沉浸式实现</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;之前做过Android沉浸式状态栏的相关需求，但是一直忙于工作，没时间系统的整理下沉浸式相关的知识，所以今天抽出时间，写一篇 Android
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java守护线程和非守护线程</title>
    <link href="https://ruanyandong.github.io/2019/06/17/Java%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%9D%9E%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/"/>
    <id>https://ruanyandong.github.io/2019/06/17/Java守护线程和非守护线程/</id>
    <published>2019-06-16T16:24:36.000Z</published>
    <updated>2019-06-16T16:26:34.022Z</updated>
    
    <content type="html"><![CDATA[<p>请参考&gt;&gt;<a href="https://blog.csdn.net/lc1010078424/article/details/79613348" target="_blank" rel="noopener">Java守护线程和非守护线程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;请参考&amp;gt;&amp;gt;&lt;a href=&quot;https://blog.csdn.net/lc1010078424/article/details/79613348&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java守护线程和非守护线程&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>代码库上传Jcenter</title>
    <link href="https://ruanyandong.github.io/2019/06/16/%E4%BB%A3%E7%A0%81%E5%BA%93%E4%B8%8A%E4%BC%A0Jcenter/"/>
    <id>https://ruanyandong.github.io/2019/06/16/代码库上传Jcenter/</id>
    <published>2019-06-16T03:03:22.000Z</published>
    <updated>2019-06-16T03:09:23.134Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/lmj623565791/article/details/51148825" target="_blank" rel="noopener">Android 快速发布开源项目到jcenter</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/lmj623565791/article/details/51148825&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android 快速发布开源项目到jcenter&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android网络安全配置</title>
    <link href="https://ruanyandong.github.io/2019/06/11/Android%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/"/>
    <id>https://ruanyandong.github.io/2019/06/11/Android网络安全配置/</id>
    <published>2019-06-11T03:53:49.000Z</published>
    <updated>2019-06-11T04:03:51.380Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/dcfb61720413" target="_blank" rel="noopener">请看这篇文章——Android网络安全配置</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/dcfb61720413&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;请看这篇文章——Android网络安全配置&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java值传递和引用传递</title>
    <link href="https://ruanyandong.github.io/2019/04/24/java%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    <id>https://ruanyandong.github.io/2019/04/24/java值传递和引用传递/</id>
    <published>2019-04-24T13:30:34.000Z</published>
    <updated>2019-04-24T13:38:03.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java在传参时分为值-传递-和-引用传递-。参数为基本类型时是值传递，-参数为封装类型时是引用传递。"><a href="#java在传参时分为值-传递-和-引用传递-。参数为基本类型时是值传递，-参数为封装类型时是引用传递。" class="headerlink" title="java在传参时分为值 传递 和 引用传递 。参数为基本类型时是值传递， 参数为封装类型时是引用传递。"></a>java在传参时分为值 传递 和 引用传递 。参数为基本类型时是值传递， 参数为封装类型时是引用传递。</h1><h2 id="基本类型参数"><a href="#基本类型参数" class="headerlink" title="基本类型参数"></a>基本类型参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int num = 0 ;</span><br><span class="line">        changeNum(num);</span><br><span class="line">        System.out.println(&quot;num=&quot;+num);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void changeNum(int num) &#123;</span><br><span class="line">        num = 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印的结果是num=0。</p><h2 id="封装类型参数"><a href="#封装类型参数" class="headerlink" title="封装类型参数"></a>封装类型参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Product p = new Product();</span><br><span class="line">        p.setProName(&quot;before&quot;);</span><br><span class="line">        p.setNum(0);</span><br><span class="line">        changeProduct(p);</span><br><span class="line">        System.out.println(&quot;p.proName=&quot;+p.getProName());</span><br><span class="line">        System.out.println(&quot;p.num=&quot;+p.getNum());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void changeProduct(Product p) &#123;</span><br><span class="line">        p.setProName(&quot;after&quot;);</span><br><span class="line">        p.setNum(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Product &#123;</span><br><span class="line">    private int num;</span><br><span class="line">    private String proName;</span><br><span class="line"> </span><br><span class="line">    public int getNum() &#123;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setNum(int num) &#123;</span><br><span class="line">        this.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public String getProName() &#123;</span><br><span class="line">        return proName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setProName(String proName) &#123;</span><br><span class="line">        this.proName = proName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行的结果是：p.proName=after和p.num=1 。</p><h2 id="上面的两个例子是明显的值传递和引用传递。但是如果参数是String类型呢？"><a href="#上面的两个例子是明显的值传递和引用传递。但是如果参数是String类型呢？" class="headerlink" title="上面的两个例子是明显的值传递和引用传递。但是如果参数是String类型呢？"></a>上面的两个例子是明显的值传递和引用传递。但是如果参数是String类型呢？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str = &quot;ab&quot;;</span><br><span class="line">        changeString(str);</span><br><span class="line">        System.out.println(&quot;str=&quot;+str);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void changeString(String str) &#123;</span><br><span class="line">        str = &quot;cd&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照前面的例子，String应该是一个封装类型，它应该是引用传递，是可以改变值得， 运行的结果应该是”cd”。<br>我们实际运行一下看看，str=ab,这如何解释呢？</p><h2 id="这就要从java底层的机制讲起了，java的内存模型分为-堆-和-栈-。"><a href="#这就要从java底层的机制讲起了，java的内存模型分为-堆-和-栈-。" class="headerlink" title="这就要从java底层的机制讲起了，java的内存模型分为 堆 和 栈 。"></a>这就要从java底层的机制讲起了，java的内存模型分为 堆 和 栈 。</h2><p>1.基本类型的变量放在栈里；<br>2.封装类型中，对象放在堆里，对象的引用放在栈里。</p><p>java在方法传递参数时，是将变量复制一份，然后传入方法体去执行。 这句话是很难理解的，也是解释这个 问题的精髓。我们先按照这句话解释一下基本类型的传递</p><pre><code>虚拟机分配给num一个内存地址，并且存了一个值0.虚拟机复制了一个num，我们叫他num’，num’和num的内存地址不同，但存的值都是0。虚拟机讲num’传入方法，方法将num’的值改为1.方法结束，方法外打印num的值，由于num内存中的值没有改变，还是0，所以打印是0.</code></pre><p>我们再解释封装类型的传递：</p><pre><code>虚拟机在堆中开辟了一个Product的内存空间，内存中包含proName和num。虚拟机在栈中分配给p一个内存地址，这个地址中存的是1中的Product的内存地址。虚拟机复制了一个p，我们叫他p’,p和p’的内存地址不同，但它们存的值是相同的，都是1中Product的内存地址。将p’传入方法，方法改变了1中的proName和num。方法结束，方法外打印p中变量的值，由于p和p’中存的都是1中Product的地址，但是1中Product里的值发生了改变， 所以，方法外打印p的值，是方法执行以后的。我们看到的效果是封装类型的值是改变的。</code></pre><p>最后我们再来解释String在传递过程中的步骤：</p><pre><code>虚拟机在堆中开辟一块内存，并存值”ab”。虚拟机在栈中分配给str一个内存，内存中存的是1中的地址。虚拟机复制一份str，我们叫str’，str和str’内存不同，但存的值都是1的地址。将str’传入方法体方法体在堆中开辟一块内存，并存值”cd”方法体将str’的值改变，存入5的内存地址方法结束，方法外打印str，由于str存的是1的地址，所有打印结果是”ab”</code></pre><p>这样我们理解了java在方法传参的整个过程。其实还是上面那句比较重要的话 java在方法传递参数时，是将变量复制一份，然后传入方法体去执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java在传参时分为值-传递-和-引用传递-。参数为基本类型时是值传递，-参数为封装类型时是引用传递。&quot;&gt;&lt;a href=&quot;#java在传参时分为值-传递-和-引用传递-。参数为基本类型时是值传递，-参数为封装类型时是引用传递。&quot; class=&quot;headerlin
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android NDK学习</title>
    <link href="https://ruanyandong.github.io/2019/03/30/Android-NDK%E5%AD%A6%E4%B9%A0/"/>
    <id>https://ruanyandong.github.io/2019/03/30/Android-NDK学习/</id>
    <published>2019-03-29T18:52:50.000Z</published>
    <updated>2019-03-29T18:58:25.093Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.android.google.cn/ndk/guides/android_mk" target="_blank" rel="noopener">Android NDK官网</a><br><a href="https://www.jianshu.com/p/87ce6f565d37" target="_blank" rel="noopener">Android JNI</a><br><a href="https://blog.csdn.net/young_time/article/details/80346631" target="_blank" rel="noopener">使用 Android Studio 写出第一个 NDK 程序</a><br><a href="https://www.jianshu.com/c/a25bf14495d7" target="_blank" rel="noopener">Android NDK 开发之旅</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://developer.android.google.cn/ndk/guides/android_mk&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android NDK官网&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>android音视频学习</title>
    <link href="https://ruanyandong.github.io/2019/03/12/android%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/"/>
    <id>https://ruanyandong.github.io/2019/03/12/android音视频学习/</id>
    <published>2019-03-12T06:32:54.000Z</published>
    <updated>2019-03-12T07:05:04.150Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/renhui/p/7452572.html" target="_blank" rel="noopener">android音视频学习</a><br><a href="https://blog.csdn.net/ywl5320/article/details/80335290" target="_blank" rel="noopener">Android音视频开发详解</a><br><a href="https://blog.csdn.net/eydwyz/article/details/79112260" target="_blank" rel="noopener">Android音视频开发进阶</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/renhui/p/7452572.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;android音视频学习&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CheckBox改变样式</title>
    <link href="https://ruanyandong.github.io/2019/03/12/CheckBox%E6%94%B9%E5%8F%98%E6%A0%B7%E5%BC%8F/"/>
    <id>https://ruanyandong.github.io/2019/03/12/CheckBox改变样式/</id>
    <published>2019-03-12T05:11:01.000Z</published>
    <updated>2019-03-12T05:19:27.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-自定义CheckBox样式"><a href="#Android-自定义CheckBox样式" class="headerlink" title="Android 自定义CheckBox样式"></a>Android 自定义CheckBox样式</h1><h2 id="一、修改checkbox选项框样式"><a href="#一、修改checkbox选项框样式" class="headerlink" title="一、修改checkbox选项框样式"></a>一、修改checkbox选项框样式</h2><h3 id="首先我们要找到两张checkbox选项框的图片："><a href="#首先我们要找到两张checkbox选项框的图片：" class="headerlink" title="首先我们要找到两张checkbox选项框的图片："></a>首先我们要找到两张checkbox选项框的图片：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">normal.png</span><br><span class="line"></span><br><span class="line">checked.png</span><br></pre></td></tr></table></figure><h3 id="然后我们设置一个背景选择器checkbox-style-xml："><a href="#然后我们设置一个背景选择器checkbox-style-xml：" class="headerlink" title="然后我们设置一个背景选择器checkbox_style.xml："></a>然后我们设置一个背景选择器checkbox_style.xml：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/checked&quot; android:state_checked=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/normal&quot; android:state_checked=&quot;false&quot;/&gt;</span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/normal&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/selector&gt;</span><br></pre></td></tr></table></figure><h3 id="到这里，在往下有两种方案，一种是直接在布局文件的android：button属性中设置："><a href="#到这里，在往下有两种方案，一种是直接在布局文件的android：button属性中设置：" class="headerlink" title="到这里，在往下有两种方案，一种是直接在布局文件的android：button属性中设置："></a>到这里，在往下有两种方案，一种是直接在布局文件的android：button属性中设置：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;CheckBox</span><br><span class="line">            android:id=&quot;@+id/checkbox1&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:text=&quot;@strings/check_text&quot;</span><br><span class="line">            android:button=&quot;@drawable/checkbox_style&quot;</span><br><span class="line">            android:checked=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure><h3 id="还有一种是在style-xml文件中添加样式MyCheckboxStyle，并在布局文件中的style属性中设置："><a href="#还有一种是在style-xml文件中添加样式MyCheckboxStyle，并在布局文件中的style属性中设置：" class="headerlink" title="还有一种是在style.xml文件中添加样式MyCheckboxStyle，并在布局文件中的style属性中设置："></a>还有一种是在style.xml文件中添加样式MyCheckboxStyle，并在布局文件中的style属性中设置：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;MyCheckboxStyle&quot; parent=&quot;@android:style/Widget.CompoundButton.CheckBox&quot;&gt;</span><br><span class="line">    &lt;item name=&quot;android:button&quot;&gt;@drawable/checkbox_style&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;CheckBox</span><br><span class="line">        android:id=&quot;@+id/checkbox1&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        style=&quot;@style/MyCheckboxStyle&quot; /&gt;</span><br></pre></td></tr></table></figure><h2 id="二、去掉选项框，自定义类Button样式"><a href="#二、去掉选项框，自定义类Button样式" class="headerlink" title="二、去掉选项框，自定义类Button样式"></a>二、去掉选项框，自定义类Button样式</h2><h3 id="同样，我们需要来一个selector-checkbox-style-xml，但是这里的图片就不是选项框的图片了，而是整个checkbox的背景图片"><a href="#同样，我们需要来一个selector-checkbox-style-xml，但是这里的图片就不是选项框的图片了，而是整个checkbox的背景图片" class="headerlink" title="同样，我们需要来一个selector checkbox_style.xml，但是这里的图片就不是选项框的图片了，而是整个checkbox的背景图片"></a>同样，我们需要来一个selector checkbox_style.xml，但是这里的图片就不是选项框的图片了，而是整个checkbox的背景图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/checked&quot; android:state_checked=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/normal&quot; android:state_checked=&quot;false&quot;/&gt;</span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/normal&quot;/&gt;</span><br></pre></td></tr></table></figure><h3 id="然后，我们可以在布局文件中将android：button属性设置为“-null”来去掉选项框，并且在android：background属性中设置："><a href="#然后，我们可以在布局文件中将android：button属性设置为“-null”来去掉选项框，并且在android：background属性中设置：" class="headerlink" title="然后，我们可以在布局文件中将android：button属性设置为“@null”来去掉选项框，并且在android：background属性中设置："></a>然后，我们可以在布局文件中将android：button属性设置为“@null”来去掉选项框，并且在android：background属性中设置：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;CheckBox</span><br><span class="line">            android:id=&quot;@+id/checkbox1&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:background=&quot;@drawable/checkbox_style&quot;</span><br><span class="line">            android:button=&quot;@null&quot;</span><br><span class="line">            android:checked=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure><h2 id="文章链接"><a href="#文章链接" class="headerlink" title="文章链接"></a>文章链接</h2><p><a href="https://www.cnblogs.com/lihualuo/p/3665847.html" target="_blank" rel="noopener">Android知识整理（3） 两种自定义样式的Checkbox</a><br><a href="https://www.cnblogs.com/Claire6649/p/5941145.html" target="_blank" rel="noopener">Android 自定义CheckBox样式</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android-自定义CheckBox样式&quot;&gt;&lt;a href=&quot;#Android-自定义CheckBox样式&quot; class=&quot;headerlink&quot; title=&quot;Android 自定义CheckBox样式&quot;&gt;&lt;/a&gt;Android 自定义CheckBox样式&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JDBC学习</title>
    <link href="https://ruanyandong.github.io/2018/12/30/JDBC%E5%AD%A6%E4%B9%A0/"/>
    <id>https://ruanyandong.github.io/2018/12/30/JDBC学习/</id>
    <published>2018-12-30T10:00:44.000Z</published>
    <updated>2018-12-30T13:27:41.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDBC之存贮过程的调用"><a href="#JDBC之存贮过程的调用" class="headerlink" title="JDBC之存贮过程的调用"></a>JDBC之存贮过程的调用</h1><h2 id="存储过程的代码"><a href="#存储过程的代码" class="headerlink" title="存储过程的代码"></a>存储过程的代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE imooc_db.sp_select_nofilter()</span><br><span class="line">BEGIN</span><br><span class="line">     select * from imooc_goddess;</span><br><span class="line">END;</span><br><span class="line">imooc_db是数据库的名字，sp_select_nofilter()是存储过程的方法名；</span><br></pre></td></tr></table></figure><h2 id="调用代码"><a href="#调用代码" class="headerlink" title="调用代码"></a>调用代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = DBUtil.getConnection();</span><br><span class="line">CallableStatement cs = conn.prepareCall(&quot;&#123;call sp_select_nofilter()&#125;&quot;);</span><br><span class="line">cs.execute();</span><br><span class="line">ResultSet rs = cd.getResultSet();</span><br></pre></td></tr></table></figure><h2 id="博客链接"><a href="#博客链接" class="headerlink" title="博客链接"></a>博客链接</h2><p>  <a href="https://www.cnblogs.com/Qian123/p/5349884.html" target="_blank" rel="noopener">JDBC慕课学习博客链接</a><br>  <a href="https://blog.csdn.net/wqc19920906/article/details/72825793" target="_blank" rel="noopener">Java 数据库系列教程–C3P0详解</a><br>  <a href="https://baike.baidu.com/item/c3p0" target="_blank" rel="noopener">c3p0配置</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JDBC之存贮过程的调用&quot;&gt;&lt;a href=&quot;#JDBC之存贮过程的调用&quot; class=&quot;headerlink&quot; title=&quot;JDBC之存贮过程的调用&quot;&gt;&lt;/a&gt;JDBC之存贮过程的调用&lt;/h1&gt;&lt;h2 id=&quot;存储过程的代码&quot;&gt;&lt;a href=&quot;#存储过程的代
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DialogFragment的宽高设置</title>
    <link href="https://ruanyandong.github.io/2018/12/29/DialogFragment%E7%9A%84%E5%AE%BD%E9%AB%98%E8%AE%BE%E7%BD%AE/"/>
    <id>https://ruanyandong.github.io/2018/12/29/DialogFragment的宽高设置/</id>
    <published>2018-12-28T17:56:34.000Z</published>
    <updated>2018-12-28T18:02:50.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onResume() &#123;</span><br><span class="line">    ViewGroup.LayoutParams params = getDialog().getWindow().getAttributes();</span><br><span class="line">    params.width = LayoutParams.MATCH_PARENT;</span><br><span class="line">    params.height = LayoutParams.MATCH_PARENT;</span><br><span class="line">    getDialog().getWindow().setAttributes((android.view.WindowManager.LayoutParams) params);</span><br><span class="line"></span><br><span class="line">    super.onResume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onResume() &#123;</span><br><span class="line">    getDialog().getWindow().setLayout(width, height);</span><br><span class="line">    super.onResume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;方法一&quot;&gt;&lt;a href=&quot;#方法一&quot; class=&quot;headerlink&quot; title=&quot;方法一&quot;&gt;&lt;/a&gt;方法一&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android依赖管理与私服搭建</title>
    <link href="https://ruanyandong.github.io/2018/12/03/Android%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E4%B8%8E%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/"/>
    <id>https://ruanyandong.github.io/2018/12/03/Android依赖管理与私服搭建/</id>
    <published>2018-12-02T17:37:17.000Z</published>
    <updated>2018-12-03T13:18:52.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android引入依赖的多种方式"><a href="#Android引入依赖的多种方式" class="headerlink" title="Android引入依赖的多种方式"></a>Android引入依赖的多种方式</h1><h2 id="一、第三方jar包"><a href="#一、第三方jar包" class="headerlink" title="一、第三方jar包"></a>一、第三方jar包</h2><p>   步骤：将jar包放入libs目录下面，然后add as library</p><h2 id="二、依赖本地模块"><a href="#二、依赖本地模块" class="headerlink" title="二、依赖本地模块"></a>二、依赖本地模块</h2><p>   步骤：新建本地module或者library，然后用本地模块进行依赖，例如：implementation project(‘:mylibrary’)</p><h2 id="三、aar方式依赖本地模块"><a href="#三、aar方式依赖本地模块" class="headerlink" title="三、aar方式依赖本地模块"></a>三、aar方式依赖本地模块</h2><p>   步骤：新建本地module或者library，然后build或者rebuild整个project，<br>   然后在新建的module或者library的build目录下的output目录下的aar目录，将aar文件放入需要依赖的libs目录下面，<br>   然后在gradle中加入一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">repositories&#123;</span><br><span class="line">        flatDir&#123;</span><br><span class="line">            dirs &apos;libs&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">implementation(name:&apos;lib2&apos;,ext:&apos;aar&apos;)</span><br><span class="line">name是aar文件的名字，ext是后缀名</span><br></pre></td></tr></table></figure></p><h2 id="四、在相应的gradle文件依赖"><a href="#四、在相应的gradle文件依赖" class="headerlink" title="四、在相应的gradle文件依赖"></a>四、在相应的gradle文件依赖</h2><p>   步骤：直接在dependencies进行implementation<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：implementation &apos;com.android.support:appcompat-v7:28.0.0&apos;</span><br></pre></td></tr></table></figure></p><h1 id="私服Nexus的获取和windows平台搭建"><a href="#私服Nexus的获取和windows平台搭建" class="headerlink" title="私服Nexus的获取和windows平台搭建"></a>私服Nexus的获取和windows平台搭建<img src="http://www.sonatype.com" alt="网址"></h1><p>  以下是一些参考博客</p><ul><li><a href="https://www.jianshu.com/p/b1fe26d5b8c8" target="_blank" rel="noopener">maven私服搭建及gradle上传</a>  </li><li><a href="https://blog.csdn.net/huweijian5/article/details/56670569" target="_blank" rel="noopener">Windows下搭建基于Nexus的Android Maven私服(一)</a></li><li><a href="https://blog.csdn.net/huweijian5/article/details/56834199" target="_blank" rel="noopener">Windows下搭建基于Nexus的Android Maven私服(二)</a></li><li><a href="https://www.jianshu.com/p/e8d999465edf" target="_blank" rel="noopener">Gradle中文教程系列-跟我学Gradle-4.1：Nexus私服的安装与配置</a></li><li><a href="https://blog.csdn.net/u011974987/article/details/52372185" target="_blank" rel="noopener">使用Gradle和Sonatype Nexus 搭建私有maven仓库</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android引入依赖的多种方式&quot;&gt;&lt;a href=&quot;#Android引入依赖的多种方式&quot; class=&quot;headerlink&quot; title=&quot;Android引入依赖的多种方式&quot;&gt;&lt;/a&gt;Android引入依赖的多种方式&lt;/h1&gt;&lt;h2 id=&quot;一、第三方jar包
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android绘图基础</title>
    <link href="https://ruanyandong.github.io/2018/11/15/Android%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80/"/>
    <id>https://ruanyandong.github.io/2018/11/15/Android绘图基础/</id>
    <published>2018-11-15T12:51:18.000Z</published>
    <updated>2018-11-15T13:08:31.039Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自定义控件之绘图篇：区域（Region）"><a href="#自定义控件之绘图篇：区域（Region）" class="headerlink" title="自定义控件之绘图篇：区域（Region）"></a><a href="https://blog.csdn.net/lu1024188315/article/details/77197968" target="_blank" rel="noopener">自定义控件之绘图篇：区域（Region）</a></h1><h1 id="自定义控件之绘图篇（三）：区域（Range）"><a href="#自定义控件之绘图篇（三）：区域（Range）" class="headerlink" title="自定义控件之绘图篇（三）：区域（Range）"></a><a href="https://blog.csdn.net/harvic880925/article/details/39056701" target="_blank" rel="noopener">自定义控件之绘图篇（三）：区域（Range）</a></h1><h1 id="android-Graphics：区域（Region）"><a href="#android-Graphics：区域（Region）" class="headerlink" title="android Graphics：区域（Region）"></a><a href="https://blog.csdn.net/wurensen/article/details/46437471" target="_blank" rel="noopener">android Graphics：区域（Region）</a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;自定义控件之绘图篇：区域（Region）&quot;&gt;&lt;a href=&quot;#自定义控件之绘图篇：区域（Region）&quot; class=&quot;headerlink&quot; title=&quot;自定义控件之绘图篇：区域（Region）&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://blog.csdn
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android事件分发</title>
    <link href="https://ruanyandong.github.io/2018/10/28/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"/>
    <id>https://ruanyandong.github.io/2018/10/28/Android事件分发/</id>
    <published>2018-10-28T10:29:23.000Z</published>
    <updated>2018-10-28T10:40:11.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h1><p>1.只有view，ViewGroup，Activity 具有事件分发和消费的功能。<br>2.Activity因为上最先接触到触摸事件，因此Activity没有事件拦截方法。即没有onInterceptTouchEvent方法。<br>3.对于不能添加子控件的view，不能对事件进行分发和拦截，它只有onTouchEvent事件。</p><h1 id="二-三个方法"><a href="#二-三个方法" class="headerlink" title="二.三个方法"></a>二.三个方法</h1><ul><li><p>1.public boolean dispatchTouchEvent(MotionEvent ev)<br>当触摸事件发生的时候，首先会被当前的activity进行分发，即当前activity的dispatchTouchEvent方法会被执行。<br>这个时候,该方法有三种返回的情况：</p><pre><code>return false： 表明事件不会被进行分发。事件会以冒泡的方式被传递给上层的view或activity的onTouchEvent方法进行消费掉。return true：表明该时间已经被处理。事件会被当前view或activity的dispatchTouchEvent给消费掉。不会再进行传递，事件到此结束。return super.dispatchTouchEvent(ev)：表明该事件将会被分发。此时当前View的onIntercepterTouchEvent方法会捕获该事件，判断需不需要进行事件的拦截。</code></pre></li><li><p>2.public boolean onInterceptTouchEvent(MotionEvent ev)<br>该方法用户拦截被传递过来的事件，用于判断被传递过来的事件是否需要被当前的view进行处理。<br>   return false : 不对事件进行拦截，放行该事件。事件会被传递到当前view的子控件中，由子控件中的dispatchTouchEvent方法进行分发处理。<br>   return true : 拦截该事件，将该事件交给当前view的onTouchEvent方法进行处理。<br>   return super.inInterceptTouchEvent(ev)：默认拦截方式，和return true一样。该事件会被拦截，将该事件交给当前view的onTouchEvent方法进行处理。（这里需要有一点说明，当有两个view。A view中有一个B view.点击A.A中如果onInterceptTouchEvent()返回super.interceptTouchEvent(ev),则事件将会被A进行拦截，交给A的onTouchEvent()进行处理，如果点击的是B，A中如果onInterceptTouchEvent()返回super.interceptTouchEvent(ev)，则事件将不会被拦截，会被分发到子控件中）</p></li><li><p>3.public boolean onTouchEvent(MotionEvent event)<br>当前的view把事件进行了拦截，则事件则会被传递到该方法中<br>   return false：表明没有消费该事件，事件将会以冒泡的方式一直被传递到上层的view或Activity中的onTouchEvent事件处理。如果最上层的view或Activity中的onTouchEvent还是返回false。则该事件将消失。接下来来的一系列事件都将会直接被上层的onTouchEvent方法捕获<br>   return true: 表明消费了该事件，事件到此结束。<br>   return super.onTouchEvent(event)：默认情况，和return false一样。</p></li></ul><h1 id="验证"><a href="#验证" class="headerlink" title="验证:"></a>验证:</h1><p>MainActivity FatherView ChildView中几个方法都返回super.<em>**</em>TouchEvent(ev)<br>     分析:</p><pre><code>当点击屏幕。MainActivity 中的dispatchTouchEvent方法先执行，打印MainActivity-dispatchTouchEvent--&gt;ACTION_DOWN因为返回的是super.dispatchTouchEvent(ev),所以事件ev将会被分发，但是MainActivity中没有onInterceptTouchEvent()方法，所以事件被传递到FatherView中的dispatchTouchEvent方法.打印FatherView-dispatchTouchEvent--&gt;ACTION_DOWN在FatherView中dispatchTouchEvent返回的是super.dispatchTouchEvent(ev),所有事件会被分发。FatherView中的onInterceptTouchEven()中的方法被执行。打印FatherView-onInterceptTouchEven--&gt;ACTION_DOWNFatherView中的onInterceptTouchEven()返回的是super.onInterceptTouchEvent(ev)。在这里，（1）如果点击的是屏幕中的ChildView。事件将不会被拦截，会被传递到ChildView中的dispatchTouchEvent方法中。（2）如果点击的值FatherView则事件将会被拦截。FatherView中的onTouchEvent()方法将被执行。以（1）为例，将打印ChildView-dispatchTouchEvent--&gt;ACTION_DOWN。ChildView中dispatchTouchEvent返回的是super.dispatchTouchEvent(ev),所有事件会被分发。打印ChildView-onInterceptTouchEvent--&gt;ACTION_DOWN。此时ChildView中onInterceptTouchEvent返回的是super.onInterceptTouchEvent(ev),，而且已经没有子控件了，所以事件将被拦截。打印ChildView-onTouchEvent--&gt;ACTION_DOWN。在childView中onTouchEvent()返回额是super.onTouchEvent(ev)。事件将不会被消耗，将以冒泡的方式传递到上层空间中的onTouchEvent(),此处上层空间中的onTouchEvent返回的都是super.onTouchEvent(ev)。所以讲一次打印 Father-onTouchEvent--&gt;ACTION_DOWN。 MainActivty-onTouchEvent--&gt;ACTION_DOWN。之后的事件动作，将不再被MainActivity分发到子view，直接被MainActivty中的onTouchEvent处理消耗。打印MainActivity-dispatchTouchEvent--&gt;ACTION_UP,MainActivty-onTouchEvent--&gt;ACTION_UP        MainActivity-dispatchTouchEvent--&gt;ACTION_DOWN        FatherView-dispatchTouchEvent--&gt;ACTION_DOWN        FatherView-onInterceptTouchEven--&gt;ACTION_DOWN        ChildView-dispatchTouchEvent--&gt;ACTION_DOWN        ChildView-onInterceptTouchEvent--&gt;ACTION_DOWN。        ChildView-onTouchEvent--&gt;ACTION_DOWN        Father-onTouchEvent--&gt;ACTION_DOWN。         MainActivty-onTouchEvent--&gt;ACTION_DOWN        MainActivity-dispatchTouchEvent--&gt;ACTION_UP,        MainActivty-onTouchEvent--&gt;ACTION_UP</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一. 概述&quot;&gt;&lt;/a&gt;一. 概述&lt;/h1&gt;&lt;p&gt;1.只有view，ViewGroup，Activity 具有事件分发和消费的功能。&lt;br&gt;2.Activity因为上最先
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android应用安装和卸载时的广播</title>
    <link href="https://ruanyandong.github.io/2018/10/23/Android%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD%E6%97%B6%E7%9A%84%E5%B9%BF%E6%92%AD/"/>
    <id>https://ruanyandong.github.io/2018/10/23/Android应用安装和卸载时的广播/</id>
    <published>2018-10-23T12:12:46.000Z</published>
    <updated>2018-10-23T12:21:02.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在android系统中，安装和卸载都会发送广播，当应用安装完成后系统会发android-intent-action-PACKAGE-ADDED广播。"><a href="#在android系统中，安装和卸载都会发送广播，当应用安装完成后系统会发android-intent-action-PACKAGE-ADDED广播。" class="headerlink" title="在android系统中，安装和卸载都会发送广播，当应用安装完成后系统会发android.intent.action.PACKAGE_ADDED广播。"></a>在android系统中，安装和卸载都会发送广播，当应用安装完成后系统会发android.intent.action.PACKAGE_ADDED广播。</h2><p>   可以通过intent.getDataString()获得所安装的包名。当卸载程序时系统发android.intent.action.PACKAGE_REMOVED广播。<br>   同样intent.getDataString()获得所卸载的包名。</p><h2 id="在安卓APP项目开发中，我们有这样的需求："><a href="#在安卓APP项目开发中，我们有这样的需求：" class="headerlink" title="在安卓APP项目开发中，我们有这样的需求："></a>在安卓APP项目开发中，我们有这样的需求：</h2><pre><code>APP安装更新完成后，需要把 APK 文件删除</code></pre><p>这里，我们可以通过安卓四大组件之一 —— 广播-接收器，来助阵。</p><p>广播有动态注册和静态注册两种方式，此处用静态注册方式。</p><p>在 AndroidManifest.xml 文件中静态注册广播接收器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver android:name=&quot;具体包名.广播接收器名&quot;</span><br><span class="line">            android:enabled=&quot;true&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=&quot;android.intent.action.PACKAGE_ADDED&quot; /&gt;</span><br><span class="line">                &lt;action android:name=&quot;android.intent.action.PACKAGE_REPLACED&quot; /&gt;</span><br><span class="line">                &lt;action android:name=&quot;android.intent.action.PACKAGE_REMOVED&quot; /&gt;</span><br><span class="line">                &lt;!--涉及到存储卡状态改变的时候必须添加--&gt;</span><br><span class="line">                &lt;data android:scheme=&quot;package&quot; /&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/receiver&gt;</span><br></pre></td></tr></table></figure></p><h1 id="几个-intent-filter-name-相信从名字就能知道什么意思了。"><a href="#几个-intent-filter-name-相信从名字就能知道什么意思了。" class="headerlink" title="几个 intent-filter name 相信从名字就能知道什么意思了。"></a>几个 intent-filter name 相信从名字就能知道什么意思了。</h1><pre><code>PACKAGE_ADDED 接受包被添加时发送的广播PACKAGE_REPLACED 接受包被替换时发送的广播PACKAGE_REMOVED 接受包被移除时发送的广播</code></pre><p>安卓系统在我们安装或卸载APP等操作时，会发送以上的一些广播包，我们这里设个接收器来”监听“这些操作的发生。</p><p>新建一个类，继承自 BroadcastReceiver，重写 onReceive 方法，具体逻辑处理可在此书写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import android.content.BroadcastReceiver;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.os.Environment;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by Moses on 2017/12/5.</span><br><span class="line"> *</span><br><span class="line"> * PackageInstallSuccessfulReceiver</span><br><span class="line"> *</span><br><span class="line"> * 接受 广播 软件包被添加、删除和替换时发出</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class PackInstSucRecei extends BroadcastReceiver &#123;</span><br><span class="line">    private String apkfileName = &quot;app-debug.apk&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line"></span><br><span class="line">        if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())) &#123;</span><br><span class="line">            Log.d(TAG, &quot;监听到系统广播,包被添加: &quot;);</span><br><span class="line">            //删除apk文件</span><br><span class="line">            deleteApkfile(apkfileName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (Intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction())) &#123;</span><br><span class="line">            Log.d(TAG, &quot;监听到系统广播,包被移除: &quot;);</span><br><span class="line">            Log.d(TAG, &quot;onReceive: &quot; + intent.getDataString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (Intent.ACTION_PACKAGE_REPLACED.equals(intent.getAction())) &#123;</span><br><span class="line">            Log.d(TAG, &quot;监听到系统广播,包被替换: &quot;);</span><br><span class="line">            Log.d(TAG, &quot;onReceive: &quot;+ intent.getPackage());</span><br><span class="line">            deleteApkfile(apkfileName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Boolean deleteApkfile(String apkFileName)&#123;</span><br><span class="line">        //Apk文件路径可自定义，此处用 download 文件夹</span><br><span class="line">        File apkfile = new File(Environment</span><br><span class="line">                .getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)</span><br><span class="line">                .getPath(), apkFileName);</span><br><span class="line">        if (!apkfile.exists()) &#123;</span><br><span class="line">            Log.d(TAG, &quot;apkfile delete already! &quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //调用现成的文件操作方法删除文件</span><br><span class="line">            if (apkfile.delete())</span><br><span class="line">                Log.d(TAG, &quot;apkfile delete successfully! &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;在android系统中，安装和卸载都会发送广播，当应用安装完成后系统会发android-intent-action-PACKAGE-ADDED广播。&quot;&gt;&lt;a href=&quot;#在android系统中，安装和卸载都会发送广播，当应用安装完成后系统会发android-in
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android广播的顺序</title>
    <link href="https://ruanyandong.github.io/2018/10/23/Android%E5%B9%BF%E6%92%AD%E7%9A%84%E9%A1%BA%E5%BA%8F/"/>
    <id>https://ruanyandong.github.io/2018/10/23/Android广播的顺序/</id>
    <published>2018-10-23T05:46:46.000Z</published>
    <updated>2018-10-23T06:40:26.690Z</updated>
    
    <content type="html"><![CDATA[<p><em>为了利于各个进程应用之间的通信，android提供了一个很方便的处理方式：广播机制。广播机制顾名思义，就是广播发送者无需判断具体某个接收者的存在，把广播发送出去，任务即完成。这样保证了有效通信的同时又最大限度的降低了android系统各个模块的耦合性。</em></p><h1 id="Android广播有两个很重要的要素："><a href="#Android广播有两个很重要的要素：" class="headerlink" title="Android广播有两个很重要的要素："></a>Android广播有两个很重要的要素：</h1><ul><li><p>1 广播 - 用于发送广播</p><pre><code>有序广播  -  被广播接收器接收后，可被终止，无法往下继续传达。         典型代表：短信广播普通广播  -  发送至每一个已经注册（订阅）的广播接收器，无法被终止。 典型代表：开机启动广播</code></pre></li><li><p>2 广播接收器 - 用于订阅广播后接收广播</p><pre><code>静态注册广播 - 在AndroidManifest.xml中设置，程序不用启动亦可接收。 典型代表：很多开机启动的APP，都是接收开机启动广播带起服务的。动态注册广播 - 代码中注册广播，程序未启动时，无法接收广播。</code></pre></li></ul><h1 id="有序广播的优先级："><a href="#有序广播的优先级：" class="headerlink" title="有序广播的优先级："></a>有序广播的优先级：</h1><ul><li>1）动态注册优先级别最高，其次静态注册</li><li>2）在动态注册中，最早动态注册优先级别最高</li><li>3）在静态注册中，最早安装的程序，静态注册优先级别最高（注：安装APK会解析manifest.xml,把其加入队列）</li><li>4）都是静态注册的情况下，按照字符排列顺序决定谁先收到广播消息</li><li>5）adb install xxx.apk安装的应用优先级比adb push到其他目录的应用高</li><li>总体来说：对于接收同一个广播，在相同优先级的情况下，动态注册优先级别高于静态注册。在动态注册中，最早动态注册优先级别最高；在静态注册中，最早安装的程序，静态注册优先级别最高（安装APK会解析manifest.xml,把其加入队列）</li></ul><h2 id="我们以如何抢先开机启动为例，来说明接收无序广播的静态广播接收器的接收顺序。首先我们要明确两个问题："><a href="#我们以如何抢先开机启动为例，来说明接收无序广播的静态广播接收器的接收顺序。首先我们要明确两个问题：" class="headerlink" title="我们以如何抢先开机启动为例，来说明接收无序广播的静态广播接收器的接收顺序。首先我们要明确两个问题："></a>我们以如何抢先开机启动为例，来说明接收无序广播的静态广播接收器的接收顺序。首先我们要明确两个问题：</h2><ul><li>A，接收无序广播的接收器接收到广播的顺序是有序的，</li><li><p>B，接收无序广播的接收器也一样可以设置优先级的。</p><pre><code>我们以开机时候发出的广播android.intent.action.BOOT_COMPLETED为例，这是个无序广播。如果应用想要开启自启动，那么就要监听这个广播，程序启动之前，动态广播接收器肯定是无法使用的，只能在XML中静态注册。大家都知道，第三方应用是存放在/data/app目录下，当安装完毕之后，你会找到一个文件，他的名字是以与安装的应用包名开始的，然后可能会跟着&quot;-数字.apk&quot;，比如：com.android.test-1.apk。接收的顺序与这个名字是有关的！那么关系是怎样的呢？</code></pre></li></ul><p>（1）系统在开机的时候，会按着一个顺序解析apk<br>1，首先，会解析手机中的/system/framework这个目录，原生系统中，这下面就一个apk - framework-res.apk，当然各个厂商也会加入自己的内容<br>2，然后受到重视的文件夹按顺序分别为：<br>/system/app<br>/vendor/app<br>/data/app<br>/drm/app-private</p><p>那么每个文件夹下解析的顺序是怎样的呢？我们先只看/data/app，也就是用户安装的第三方应用的存放位置，这与下面代码返回结果的顺序是一致的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;/data/app/&quot;);</span><br><span class="line">String[] files = file.list();</span><br></pre></td></tr></table></figure></p><p>也就是说，我们按顺序打印这个数组，就能知道哪个接收器会先接收到这个广播，哪个会后接收到</p><p>（2）网上的CODE  DEMO</p><pre><code>做了一个实验，我写了几个只有receiver的应用，把他们的包名分别设置为大家常用的、关系的应用包名</code></pre><p>飞信：cn.com.fetion<br>LBE隐私卫士：com.lbe.security.lite<br>Handsent：com.handsent.nextsms<br>金山手机卫士：com.ijinshan.mguard<br>360手机卫士：com.qihoo360.mobilesafe<br>QQ手机管家：com.tencent.qqpimsecure<br>一个测试应用：com.example.boottest<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;/data/app/&quot;);</span><br><span class="line">String[] files = file.list();</span><br><span class="line">for (int i = 0; i &lt; files.length; i++)&#123;</span><br><span class="line">System.out.println(&quot;/data/app/:files[&quot;+(i+1)+&quot;]:&quot; + files[i]); //在打印语句中(i+1)的值可以自动转成字符</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果为：<br>/data/app/:files[8]:com.tencent.qqpimsecure-1.apk<br>/data/app/:files[9]:com.qihoo360.mobilesafe-1.apk<br>/data/app/:files[10]:com.ijinshan.mguard-1.apk<br>/data/app/:files[11]:cn.com.fetion-1.apk<br>/data/app/:files[12]:com.lbe.security.lite-1.apk<br>/data/app/:files[13]:com.handsent.nextsms-1.apk<br>/data/app/:files[14]:com.example.boottest-1.apk</p><p>如果其中一个优先级较高，比如cn.com.fetion，那么实际的接收顺序为<br>getPackageName:cn.com.fetion<br>getPackageName:com.tencent.qqpimsecure<br>getPackageName:com.qihoo360.mobilesafe<br>getPackageName:com.ijinshan.mguard<br>getPackageName:com.lbe.security.lite<br>getPackageName:com.handsent.nextsms<br>getPackageName:com.example.boottest<br>所以如果同优先级的静态接收器想先接收某个广播，就要在包名上修改已让它靠前显示。</p><p>（3）自己的CODE实验，在一个安卓应用中加入了如下几行测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;/data/app/&quot;);</span><br><span class="line">if (file == null)</span><br><span class="line">return;</span><br><span class="line">String[] files = file.list();</span><br><span class="line">if (files == null)</span><br><span class="line">return;</span><br><span class="line">for (int i = 0; i &lt; files.length; i++)&#123;</span><br><span class="line">Log.i(&quot;zhangcheng&quot;,&quot;/data/app/:files[&quot;+String.valueOf(i+1)+&quot;]:&quot; + files[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的【1】：目录权限一定要有，除了ROOT外，我还设置了777属性，否则file和files都可能是空指针，应用运行报错。【2】LOG的输出必须全都是字符，不是字符的要手工转成字符。我的输出如下：</p><p>/data/app/:files[1]:.restore_list<br>/data/app/:files[2]:HN_Facebook.apk<br>/data/app/:files[3]:HN_IndonesiaCanggih.apk<br>/data/app/:files[4]:HN_KingsoftOffice.apk<br>/data/app/:files[5]:HN_Messenger.apk<br>/data/app/:files[6]:HN_Twitter.apk<br>/data/app/:files[7]:com.qihoo.appstore-1.apk<br>/data/app/:files[8]:com.qihoo360.contacts-1.apk<br>/data/app/:files[9]:com.example.app-1.apk<br>/data/app/:files[10]:com.example.test-2.apk<br>（4）以上讲述的是静态接收器，那动态接收器的优先级呢？</p><pre><code>android系统在收到短信息的时候会发送广播，但是此广播是有序广播，也就是说：先接收到广播的人，如果心情不好，它就不会向后传递此广播，后面的人就不会知道有短信到来。这与无序广播不同，无序广播并不是真的没有顺序，无序广播的接收者也是排队等待广播，只不过是在传递过程中，大家必须遵守规则一直把消息传递给最后一个。以大家关心的接收短消息为例，想要在程序中接收短信，就要接收如下广播android.provider.Telephony.SMS_RECEIVED。系统把它作为有序广播进行发送，那么，谁第一个接收到短信将变得至关重要。上一节说过静态接收器的接收顺序，那么动态接收器和静态接收器相比呢？答案是静态接收器优先级低于动态接收器，也就是说，无论多么高级别的静态接收器和多么低级别的动态接收器都接收同一广播，永远都是动态接收器先接收到！同等优先级的动态接收器，先注册的先接收。</code></pre><p>（5）有些广播必须是动态注册的receiver才能收到<br>   比如ACTION_SCREEN_ON，当屏幕被点亮的时候系统发送此广播，如果你尝试在manifest中注册receiver来接收，那么会失败，这是为什么呢？他们在Intent中都设置了Intent.FLAG_RECEIVER_REGISTERED_ONLY，所以如果要接收，必须动态注册广播接收器，ACTION_SCREEN_OFF也是如此。</p><h1 id="广播注册过程和接收广播顺序过程"><a href="#广播注册过程和接收广播顺序过程" class="headerlink" title="广播注册过程和接收广播顺序过程"></a>广播注册过程和接收广播顺序过程</h1><p><img src="https://images.cnitblog.com/blog/320080/201305/22234432-b4340279f6f44f68a5fdeadb5778b788.png" alt=""></p><pre><code>                                         图1 注册广播流程简图静态广播接收器 由PackageManagerService负责，当手机启动时（或者新安装了应用），PackageManagerService负责扫描手机中所有已安装的APP应用（题外话，确定不再使用的APP需要卸载了），将AndroidManifest.xml中 有关注册广播的信息 解析出来，存储至一个全局静态变量当中mReceivers。</code></pre><h1 id="需要注意的是："><a href="#需要注意的是：" class="headerlink" title="需要注意的是："></a>需要注意的是：</h1><p> 1 PackageManagerService扫描目录的顺序如下：</p><p>　　system/framework</p><p>　　system/app</p><p>　　vendor/app</p><p>　　data/app</p><p>　　drm/app-private</p><p> 2 当处于同一目录下时：按照file.list()的返回顺序。（题外话：因为在data/app下的应用都是用户安装的，并且都是以com.xxx.xxx-1.apk 的形式出现，所以如果打算做手机管家之类的应用，需要好好的研究下包名，争取在file.list()的独木桥下抢的头筹—优先接收开机启动完成的广播。）</p><p> 3 在此处并未对 接收顺序做完整的排序。（注意修饰词完整的，毕竟先扫描的当然会有一定优先级）</p><pre><code>动态广播接收器 由ActivityManagerService负责，当APP的服务或者进程起来之后，执行了注册广播接收的代码逻辑，即进行加载，最后会存储在一个全局静态变量</code></pre><p>mReceiverResolver中。</p><h1 id="需要注意的是：-1"><a href="#需要注意的是：-1" class="headerlink" title="需要注意的是："></a>需要注意的是：</h1><pre><code>1 这个并非是一成不变的，当程序被杀死之后，  已注册的动态广播接收器也会被移出mReceiverResolver，直到下次程序启动，再进行动态广播的注册，当然这里面的顺序也已经变更了一次。2  这里也并没完整的进行广播的排序，只记录的注册的先后顺序，并未有结合优先级的处理。</code></pre><h1 id="当有广播发出时，接收顺序如下："><a href="#当有广播发出时，接收顺序如下：" class="headerlink" title="当有广播发出时，接收顺序如下："></a>当有广播发出时，接收顺序如下：</h1><p><img src="https://images.cnitblog.com/blog/320080/201305/23090937-42036226199c4985a3902a98a6541f15.jpg" alt=""></p><pre><code>图2 广播接收流程简图</code></pre><p>   在ActivityManagerService处理广播，当广播为有序广播时，将动态广播接收器和动态广播接收器合并起来，形成最终的有序广播接收顺序。<br>   上述的规则1排序为：<br>                                1 优先级高的先接收<br>                                2 同优先级的动静态广播接收器，动态优先于静态<br>                                3 同优先级的动态广播接收器  或者同优先级的静态广播接收器，按照图1 的流程注册顺序。<br>                                   即静态：先扫描的大于后扫描的，动态：先注册的大于后注册的。</p><p>   当广播为普通广播时，规则2排序为：<br>                                1 无视优先级，动态广播接收器优先于静态广播接收器<br>                                2 同规则1排序的第3点  </p><h1 id="最后举个例子："><a href="#最后举个例子：" class="headerlink" title="最后举个例子："></a>最后举个例子：</h1><p>（以下的静A 表示静态广播接收器，同理动B。）</p><p>1 静A (优先级1）</p><p>2 动B（优先级1）</p><p>3 静C （优先级2，后扫描）</p><p>4 静D （优先级2，先扫描）</p><p>5 动E   (优先级2，先注册）</p><p>6 动F  （优先级2，后注册）</p><p>当来了一个 有序广播，接收顺序如下：动E &gt;  动F  &gt; 静D &gt; 静C &gt; 动B &gt; 静A</p><p>当来了一个 普通广播，接收顺序如下：动E &gt;  动F  &gt; 动B &gt; 静D &gt; 静C &gt; 静A                                </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;为了利于各个进程应用之间的通信，android提供了一个很方便的处理方式：广播机制。广播机制顾名思义，就是广播发送者无需判断具体某个接收者的存在，把广播发送出去，任务即完成。这样保证了有效通信的同时又最大限度的降低了android系统各个模块的耦合性。&lt;/em&gt;&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android内存溢出和内存泄漏</title>
    <link href="https://ruanyandong.github.io/2018/10/23/Android%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>https://ruanyandong.github.io/2018/10/23/Android内存溢出和内存泄漏/</id>
    <published>2018-10-22T16:10:16.000Z</published>
    <updated>2018-10-22T17:24:29.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安卓官方学习教程"><a href="#安卓官方学习教程" class="headerlink" title="安卓官方学习教程"></a><a href="http://hukai.me/android-training-course-in-chinese/basics/index.html" target="_blank" rel="noopener">安卓官方学习教程</a></h1><h1 id="一、内存泄露"><a href="#一、内存泄露" class="headerlink" title="一、内存泄露"></a>一、内存泄露</h1><pre><code>垃圾回收器无法回收原本应该被回收的对象，这个对象就引发了内存泄露。内存泄露的危害：    （1）过多的内存泄露最终会导致内存溢出（OOM）    （2）内存泄露导致可用内存不足，会触发频繁GC，不管是Android2.2以前的单线程GC还是现在的CMS和G1，都有一部分的操作会导致用户线程停止（就是所谓的Stop the world），从而导致UI卡顿。</code></pre><h1 id="二、内存溢出（OOM）"><a href="#二、内存溢出（OOM）" class="headerlink" title="二、内存溢出（OOM）"></a>二、内存溢出（OOM）</h1><pre><code>Android为每个进程设置Dalvik Heap Size阈值，这个阈值在不同的设备上会因为RAM大小不同而各有差异。如果APP想要分配的内存超过这个阈值，就会发生OOM。ActivityManager.getMemoryClass()可以查询当前APP的Heap Size阈值，单位是MB。在3.x以前，Bitmap分配在Native heap中，而在4.x之后，Bitmap分配在Dalvik或ART的Java heap中。Android 2.x系统，当dalvik allocated + native allocated + 新分配的大小 &gt;= dalvik heap 最大值时候就会发生OOM，也就是说在2.x系统中，考虑native heap对每个进程的内存限制。Android 4.x系统，废除了native的计数器，类似bitmap的分配改到dalvik的java heap中申请，只要allocated + 新分配的内存 &gt;= dalvik heap 最大值的时候就会发生OOM（art运行环境的统计规则还是和dalvik保持一致），也就是说在4.x系统中，不考虑native heap对每个进程的内存限制，native heap只会收到本机总内存（包括RAM以及SWAP区或分页文件）的限制。</code></pre><h1 id="一、原理"><a href="#一、原理" class="headerlink" title="一、原理"></a>一、原理</h1><pre><code>内存溢出（Out of memory）:系统会给每个APP分配内存也就是Heap size值，当APP所需要的内存大于了系统分配的内存，就会造成内存溢出；通俗点就是10L桶只能装10L水，但是你却用来装11L的水，那就有1L的水就会溢出内存泄漏（Memory leak）:当一个对象不在使用了，本应该被垃圾回收器（JVM）回收，但是这个对象由于被其他正在使用的对象所持有，造成无法被回收的结果，通俗点就是系统把一定的内存值A借给程序，但是系统却收不回完整的A值，那就是内存泄漏</code></pre><h1 id="二、两者的关系"><a href="#二、两者的关系" class="headerlink" title="二、两者的关系"></a>二、两者的关系</h1><pre><code>内存泄漏是造成内存溢出（OOM）的主要原因，因为系统分配给每个程序的内存也就是Heap size的值都是有限的，当内存泄漏到一定值的时候，最终会发生程序所需要的内存值加上泄漏值大于了系统所分配的内存额度，就是触发内存溢出</code></pre><h1 id="三、危害"><a href="#三、危害" class="headerlink" title="三、危害"></a>三、危害</h1><pre><code>内存溢出：会触发Java.lang.OutOfMemoryError，造成程序崩溃内存泄漏：过多的内存泄漏会造成OOM的发送，同样也会造成相关UI的卡顿现象</code></pre><h1 id="四、如何避免内存泄漏"><a href="#四、如何避免内存泄漏" class="headerlink" title="四、如何避免内存泄漏"></a>四、如何避免内存泄漏</h1><h2 id="1、使用轻量的数据结构"><a href="#1、使用轻量的数据结构" class="headerlink" title="1、使用轻量的数据结构"></a>1、使用轻量的数据结构</h2><ul><li>使用ArrayMap/SparseArray来代替HashMap，ArrayMap/SparseArray是专门为移动设备设计的高效的数据结构。</li><li><em>HashMap实现原理:</em></li><li>HashMap内部使用一个默认容量为16的数组来存储数据，采用拉链法解决hash冲突（数组+链表），如下图：<br><img src="https://img-blog.csdn.net/20160331144232258" alt="拉链法的hashMap"></li><li>Entry存储的内容有key、value、hash值、next指针，通过计算hash(key)%len找到Entry在数组中的位置。</li><li><p>缺点：（1）就算没有数据，也需要分配默认16个元素的数组（2）一旦数据量达到Hashmap限定容量的75%，就将按两倍扩容</p></li><li><p><em>SparseArray:</em></p></li><li>支持int类型，避免自动装箱，但是也只支持int类型的key</li><li>内部通过两个数组来进行数据存储的，一个存储key，另外一个存储value</li><li>因为key是int，在查找时，采用二分查找，效率高，SparseArray存储的元素都是按元素的key值从小到大排列好的。 （Hashmap通过遍历Entry数组来获取对象）</li><li><p>默认初始size为0，每次增加元素，size++</p></li><li><p><em>ArrayMap:</em></p></li><li>跟SparseArray一样，内部两个数组，但是第一个存key的hash值，一个存value，对象按照key的hash值排序，二分查找也是按照hash</li><li>查找index时，传入key，计算出hash，通过二分查找hash数组，确定index<h2 id="2、不要使用Enum"><a href="#2、不要使用Enum" class="headerlink" title="2、不要使用Enum"></a>2、不要使用Enum</h2><h2 id="3、大胖子Bitmap的处理"><a href="#3、大胖子Bitmap的处理" class="headerlink" title="3、大胖子Bitmap的处理"></a>3、大胖子Bitmap的处理</h2></li><li>Bitmap压缩</li><li>Lru机制处理Bitmap，也可以使用那些有名的图片缓存框架。<h2 id="4、不要使用String进行字符串拼接"><a href="#4、不要使用String进行字符串拼接" class="headerlink" title="4、不要使用String进行字符串拼接"></a>4、不要使用String进行字符串拼接</h2></li><li>严格的讲，String拼接只能归结到内存抖动中，因为产生的String副本能够被GC，不会造成内存泄露。</li><li>频繁的字符串拼接，使用StringBuffer或者StringBuilder代替String，可以在一定程度上避免OOM和内存抖动。<h2 id="5、非静态内部类内存泄露"><a href="#5、非静态内部类内存泄露" class="headerlink" title="5、非静态内部类内存泄露"></a>5、非静态内部类内存泄露</h2></li><li>在Activity中创建非静态内部类，非静态内部类会持有Activity的隐式引用，若内部类生命周期长于Activity，会导致Activity实例无法被回收。（屏幕旋转后会重新创建Activity实例，如果内部类持有引用，将会导致旋转前的实例无法被回收）。</li><li>解决方案：如果一定要使用内部类，就改用static内部类，在内部类中通过WeakReference的方式引用外界资源。</li><li>正确的代码示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static class ImageDownloadTask extends AsyncTask&lt;String, Void, Bitmap&gt; &#123;</span><br><span class="line"></span><br><span class="line">        private String url;</span><br><span class="line">        private WeakReference&lt;PhotoAdapter&gt; photoAdapter;</span><br><span class="line"></span><br><span class="line">        public ImageDownloadTask(PhotoAdapter photoAdapter) &#123;</span><br><span class="line">            this.photoAdapter = new WeakReference&lt;PhotoAdapter&gt;(photoAdapter);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected Bitmap doInBackground(String... params) &#123;</span><br><span class="line">            //在后台开始下载图片</span><br><span class="line">            url = params[0];</span><br><span class="line">            Bitmap bitmap = photoAdapter.get().loadBitmap(url);</span><br><span class="line">            if (bitmap != null) &#123;</span><br><span class="line">                //把下载好的图片放入LruCache中</span><br><span class="line">                String key = MD5Tools.decodeString(url);</span><br><span class="line">                photoAdapter.get().put(key, bitmap);</span><br><span class="line">            &#125;</span><br><span class="line">            return bitmap;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected void onPostExecute(Bitmap bitmap) &#123;</span><br><span class="line">            super.onPostExecute(bitmap);</span><br><span class="line">            //把下载好的图片显示出来</span><br><span class="line">            ImageView mImageView = (ImageView) photoAdapter.get().mGridView.get().findViewWithTag(MD5Tools.decodeString(url));</span><br><span class="line">            if (mImageView != null &amp;&amp; bitmap != null) &#123;</span><br><span class="line">                mImageView.setImageBitmap(bitmap);</span><br><span class="line">                photoAdapter.get().mDownloadTaskList.remove(this);//把下载好的任务移除</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="6、匿名内部类内存泄漏"><a href="#6、匿名内部类内存泄漏" class="headerlink" title="6、匿名内部类内存泄漏"></a>6、匿名内部类内存泄漏</h2><ul><li>跟非静态内部类一样，匿名内部类也会持有外部类的隐式引用，比较常见的情况有，耗时Handler，耗时Thread，都会造成内存泄漏，解决方式也是static+WeakReference，下面给出正确写法。</li><li><p>Handler的正确写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private static class MyHandler extends Handler &#123;</span><br><span class="line"></span><br><span class="line">    private final WeakReference&lt;Context&gt; context;</span><br><span class="line"></span><br><span class="line">    private MyHandler(Context context) &#123;</span><br><span class="line">        this.context = new WeakReference&lt;Context&gt;(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        switch (msg.what) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final MyHandler mHandler = new MyHandler(this);</span><br><span class="line"></span><br><span class="line">private static final Runnable sRunnable = new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_home);</span><br><span class="line">    //  发送一个10分钟后执行的一个消息</span><br><span class="line">    mHandler.postDelayed(sRunnable, 600000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Thread的正确写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private static class MyThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            // TODO 耗时任务</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">new MyThread().start();</span><br><span class="line">``` </span><br><span class="line">## 7、Context持有导致内存泄漏</span><br><span class="line">* Activity Context被传递到其他实例中，这可能导致自身被引用而发生泄漏。</span><br><span class="line">* 解决：对于大部分非必须使用Activity Context的情况（创建Dialog的Context必须是Activity Context），应该使用Application Context。</span><br><span class="line"></span><br><span class="line">## 8、记得注销监听器</span><br><span class="line">* 注册监听器的时候会add Listener，不要忘记在不需要的时候remove掉Listener。</span><br><span class="line"></span><br><span class="line">## 9、资源文件需要选择合适的文件夹进行存放</span><br><span class="line">* hdpi/xhdpi/xxhdpi等等不同dpi的文件夹下的图片在不同的设备上会经过scale的处理。例如我们只在hdpi的目录下放置了一张100100的图片，那么根据换算关系，xxhdpi的手机去引用那张图片就会被拉伸到200200。需要注意到在这种情况下，内存占用是会显著提高的。对于不希望被拉伸的图片，需要放到assets或者nodpi的目录下。</span><br><span class="line"></span><br><span class="line">## 10、谨慎使用static对象</span><br><span class="line">* static对象的生命周期过长，应该谨慎使用</span><br><span class="line"></span><br><span class="line">## 11、谨慎使用单例中不合理的持有</span><br><span class="line">* 单例中的对象生命周期与应用一致，注意不要在单例中进行不必要的外界引用持有。如果一定要引用外部变量，需要在外部变量生命周期结束的时候接触引用（赋为null）。</span><br><span class="line"></span><br><span class="line">## 12、一定要记得关闭无用连接</span><br><span class="line">* 在onDestory中关闭Cursor，I/O，数据库，网络的连接用完记得关闭。</span><br><span class="line"></span><br><span class="line">## 13、注意：谨慎使用lager heap</span><br><span class="line">* 不同的设备有不容的RAM，他们为应用程序设置了不同大小的Heap的阈值。虽然可以通过largeHeap=true的属性来为应用获得一个更大的heap空间，然后通过getLargeMemoryClass()来获取到这个更大的heap阈值。但是你要注意，largeHeap只是为了一些本来就需要大量内存的APP存在，比如图墙和图片编辑软件。所以，不要随意的使用large heap，否则会影响系统整体的用户体验，会使每次gc时间更长。</span><br><span class="line"></span><br><span class="line"># 四、内存泄露检测</span><br><span class="line">* 这里介绍LeakCanary，一款非常好用的内存泄露检测工具，安装在手机上，能够通过Log的方式告诉你是哪块代码发生了内存泄露。</span><br><span class="line">* 使用方法，在Application中install LeakCanary（默认只能检测Activity内容的内存泄露）：</span><br></pre></td></tr></table></figure></li></ul><p>public class MyApplication extends Application {</p><p>  @Override public void onCreate() {<br>    super.onCreate();<br>    LeakCanary.install(this);<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 想要检测更多，首先注册一个RefWatcher：</span><br></pre></td></tr></table></figure></p><p>public class MyApplication extends Application {</p><pre><code>private static RefWatcher sRefWatcher;@Overridepublic void onCreate() {    super.onCreate();    sRefWatcher = LeakCanary.install(this);}public static RefWatcher getRefWatcher() {    return sRefWatcher;}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## 然后对某个可能发生泄露的占用大内存的对象进行监测：</span><br></pre></td></tr></table></figure></p><p>MyApplication.getRefWatcher().watch(sLeaky);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 对Fragment、BroadcastReceiver、Service进行监测：</span><br></pre></td></tr></table></figure></p><p>public class MyFragment extends Fragment {<br>    @Override<br>    public void onDestroy() {<br>        super.onDestroy();<br>        MyApplication.getRefWatcher().watch(this);<br>    }<br>}<br><code>`</code></p><p><a href="https://blog.csdn.net/mxm691292118/article/details/51020023" target="_blank" rel="noopener">原文地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安卓官方学习教程&quot;&gt;&lt;a href=&quot;#安卓官方学习教程&quot; class=&quot;headerlink&quot; title=&quot;安卓官方学习教程&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://hukai.me/android-training-course-in-chinese/ba
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java四种引用</title>
    <link href="https://ruanyandong.github.io/2018/10/05/java%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/"/>
    <id>https://ruanyandong.github.io/2018/10/05/java四种引用/</id>
    <published>2018-10-04T23:28:09.000Z</published>
    <updated>2018-10-04T23:31:01.736Z</updated>
    
    <content type="html"><![CDATA[<p>参考文章<a href="https://blog.csdn.net/swebin/article/details/78571933" target="_blank" rel="noopener">java四种引用</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考文章&lt;a href=&quot;https://blog.csdn.net/swebin/article/details/78571933&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;java四种引用&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GC ROOT</title>
    <link href="https://ruanyandong.github.io/2018/10/04/GC-ROOT/"/>
    <id>https://ruanyandong.github.io/2018/10/04/GC-ROOT/</id>
    <published>2018-10-04T10:00:21.000Z</published>
    <updated>2018-10-04T10:02:34.743Z</updated>
    
    <content type="html"><![CDATA[<p>关于GC ROOT,请参考这篇文章====&gt;<a href="https://blog.csdn.net/u010497228/article/details/44106119" target="_blank" rel="noopener">GC ROOT</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于GC ROOT,请参考这篇文章====&amp;gt;&lt;a href=&quot;https://blog.csdn.net/u010497228/article/details/44106119&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GC ROOT&lt;/a&gt;&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>android字体相关知识</title>
    <link href="https://ruanyandong.github.io/2018/10/03/android%E5%AD%97%E4%BD%93%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <id>https://ruanyandong.github.io/2018/10/03/android字体相关知识/</id>
    <published>2018-10-03T07:59:26.000Z</published>
    <updated>2018-10-03T08:16:58.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android字体简介"><a href="#Android字体简介" class="headerlink" title="Android字体简介"></a>Android字体简介</h1><hr><p>Android系统默认支持三种字体，分别为：“sans”,“serif”,“monospace”。</p><p>android.graphic.typeface字体类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">本类的常量静态定义，首先为字体类型（typeface）名称</span><br><span class="line">        TypefaceDEFAULTTypeface </span><br><span class="line">        DEFAULT_BOLDTypeface </span><br><span class="line">MONOSPACETypefaceSANS_SERIF</span><br><span class="line">Typeface SERIF</span><br><span class="line">-------------------------------------------</span><br><span class="line">字体风格（style）名称int </span><br><span class="line">BOLDint </span><br><span class="line">BOLD_ITALICint </span><br><span class="line">ITALICint NORMAL</span><br><span class="line">---------------------------------------------------</span><br><span class="line">设置TextView的字体可以通过TextView中的setTypeface方法来指定一个Typeface对象，</span><br><span class="line">因为Android的字体类比较简单，我们列出所有成员方法:</span><br><span class="line">    </span><br><span class="line">staticTypeface create(Typeface family, int style)//静态方法，参数一为字体类型这里是Typeface的静态定义，如宋体，参数二风格，如粗体，斜体   </span><br><span class="line">staticTypeface create(String familyName, int style)//静态方法，参数一为字体名的字符串，参数二为风格同上，这里我们推荐使用上面的方法。    </span><br><span class="line">staticTypeface createFromAsset(AssetManager mgr, String path)//静态方法，参数一为AssetManager对象，主要用于从APK的assets文件夹中取出字体，参数二为相对于Android工程下 的assets文件夹中的外挂字体文件的路径。    </span><br><span class="line">staticTypeface createFromFile(File path)//静态方法，从文件系统构造一个字体，这里参数可以是sdcard中的某个字体文件    </span><br><span class="line">staticTypeface createFromFile(String path) //静态方法，从指定路径中构造字体    </span><br><span class="line">staticTypeface defaultFromStyle(int style) //静态方法，返回默认的字体风格    </span><br><span class="line">intgetStyle() //获取当前字体风格    </span><br><span class="line">finalboolean isBold() //判断当前是否为粗体    </span><br><span class="line">finalboolean isItalic() //判断当前风格是否为斜体</span><br></pre></td></tr></table></figure><h2 id="Android字体工作原理"><a href="#Android字体工作原理" class="headerlink" title="Android字体工作原理"></a>Android字体工作原理</h2><p>   android字体由android 2D图形引擎skia实现，并在Zygote的Preloading classes中对系统字体进行load。<br>   相关文件有：skTypeface.cpp和skFontHost_android.cpp，其中后者是skia针对android平台字体实现的port。<br>   主要的变量有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct FontInitRec &#123;</span><br><span class="line">       const char*         fFileName;</span><br><span class="line">       const char* const*  fNames;     </span><br><span class="line">// null-terminated list</span><br><span class="line">&#125;;</span><br><span class="line">struct FamilyRec &#123;</span><br><span class="line">       FamilyRec*  fNext;</span><br><span class="line">       SkTypeface* fFaces[5];</span><br><span class="line">&#125;;</span><br><span class="line">uint32_t gFallbackFonts[SK_ARRAY_COUNT(gSystemFonts)+1];</span><br><span class="line">load_system_fonts()@skFontHost_android.cpp load</span><br></pre></td></tr></table></figure></p><hr><p>系统中所有的字体并给每种字体分配唯一的ID，并将字体分为两种：FamilyFonts和FallbackFonts，skPaint通过应用程序设置的字体（Typeface）所对应的ID最终实现字符的显示。<br>替换Android默认的汉字字体在android系统中，DroidSans是默认字体，只包含西方字符，<br>应用程序默认情况下都会调用它，而DroidSansFallback包含了东亚字符，<br>当需要显示的字符在DroidSans字体中不存在（如：汉字）时，即没有对应编码的字符时，<br>系统会到DroidSansFallback中去找相应编码的字符，如果找到，则使用DroidSansFallback字体来显示它，<br>如果仍找不到该编码对应的字符，则无法在屏幕上显示该字符。<br>更换默认中文字体的步骤为：<br>   1、将幼圆字体库youyuan.ttf重命名为DroidSansFallback.ttf,覆盖Android源码中frameworks/base/data/fonts目录下的DroidSansFallback.ttf文件<br>   2、重新编译Android系统3、编译SDK。生成的SDK中，android默认的中文字体已更换为幼圆字体。该方法的不足是删除了Android系统原来的中文字体<br>     为android系统添加一种默认字体在android系统中，默认的中文字体只有一种：DroidSansFallback.ttf，<br>     如果想在android应用程序中随意设置想要的中文字体，除了在应用程序中通过assets目录引入字体文件外，还可以通过增加android默认字体的方式来实现。<br>     添加步骤大致如下：<br>     1、在frameworks/base/data/fonts目录下添加字体文件，例如Driod-kaishu.ttf;<br>     2、在skia中增加楷书这一字体，需要修改的文件主要有skFontHost.cpp、skTypeface.cpp、Typeface.java等;<br>     3、在java层添加楷书字体相关API，需要修改的文件主要有typeface.java和textview.java;</p><pre><code>4、编译SDK5、将新生成的sdk导入eclipse，在eclipse中即可通过setTypeface(Typeface.KAISHU)和android:typeface=(“kaishu”)两种方式设置自己添加的字体</code></pre><hr><h1 id="以及一些相关链接，可以参考："><a href="#以及一些相关链接，可以参考：" class="headerlink" title="以及一些相关链接，可以参考："></a>以及一些相关链接，可以参考：</h1><p><a href="https://blog.csdn.net/ludandan1234/article/details/53330944" target="_blank" rel="noopener">修改android app 字体格式</a><br><a href="https://blog.csdn.net/shiyangkai/article/details/70257004" target="_blank" rel="noopener">Android TextView 自定义字体设置</a><br><a href="https://blog.csdn.net/sinat_34754865/article/details/53389923" target="_blank" rel="noopener">Android ttf字体的使用</a><br><a href="https://blog.csdn.net/JavaAndroid730/article/details/53122953" target="_blank" rel="noopener">Android中快速实现自定义字体！</a><br><a href="https://blog.csdn.net/wonderful19891024/article/details/6033304" target="_blank" rel="noopener">Android中字体的处理</a><br><a href="https://blog.csdn.net/songjinshi/article/details/46633341" target="_blank" rel="noopener">Android字体Font相关知识</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android字体简介&quot;&gt;&lt;a href=&quot;#Android字体简介&quot; class=&quot;headerlink&quot; title=&quot;Android字体简介&quot;&gt;&lt;/a&gt;Android字体简介&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;Android系统默认支持三种字体，分别为：“sans”,
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android动态改变图片颜色</title>
    <link href="https://ruanyandong.github.io/2018/10/03/Android%E5%8A%A8%E6%80%81%E6%94%B9%E5%8F%98%E5%9B%BE%E7%89%87%E9%A2%9C%E8%89%B2/"/>
    <id>https://ruanyandong.github.io/2018/10/03/Android动态改变图片颜色/</id>
    <published>2018-10-03T06:52:08.000Z</published>
    <updated>2018-10-03T07:27:03.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="方法一、通过属性动画来改变图片的颜色"><a href="#方法一、通过属性动画来改变图片的颜色" class="headerlink" title="方法一、通过属性动画来改变图片的颜色"></a>方法一、通过属性动画来改变图片的颜色</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">                    ObjectAnimator objectAnimatorTran = ObjectAnimator.ofArgb(mSplashImage, &quot;ColorFilter&quot;, getResources().getColor(R.color.colorWhite), getResources().getColor(R.color.colorAccent));</span><br><span class="line">                    objectAnimatorTran.setDuration(5000);</span><br><span class="line">                    //objectAnimatorTran.setRepeatCount(-1);</span><br><span class="line">                    objectAnimatorTran.start();</span><br><span class="line">                </span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"># 方法二</span><br><span class="line">## 关键点</span><br><span class="line">获取目标图标的所有像素点</span><br><span class="line">验证像素点的alpha值，是否透明</span><br><span class="line">在不透明的像素点上修改为我们想要的颜色</span><br><span class="line">根据输入的颜色值改变图标颜色</span><br></pre></td></tr></table></figure><p>final EditText et = findViewById(R.id.et);<br>final ImageView iv = findViewById(R.id.iv);<br>iv.setOnClickListener(new View.OnClickListener() {<br>    @Override<br>    public void onClick(View view) {<br>        //获取ImageView上的图片<br>        iv.setDrawingCacheEnabled(true);<br>        Bitmap bitmap = iv.getDrawingCache();</p><pre><code>    //按照输入的颜色转换图标    String s = et.getText().toString();    Bitmap newBitmap = changeBitmapColor(bitmap,s);    iv.setDrawingCacheEnabled(false);    iv.setImageBitmap(newBitmap);}</code></pre><p>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## 实现方法：</span><br></pre></td></tr></table></figure></p><p>public Bitmap changeBitmapColor(Bitmap sourceBitmap,String aimColorStr){<br>    //验证参数合理<br>    if(sourceBitmap == null || sourceBitmap.isRecycled()){<br>        throw new RuntimeException(“source exception!!!”);<br>    }<br>    int aimColor;<br>    try {<br>        aimColor = Color.parseColor(aimColorStr.trim());<br>    } catch (Exception e){<br>        throw new RuntimeException(“aimColorStr error!!!”);<br>    }<br>    //按照图标的大小创建数组<br>    int mBitmapWidth = sourceBitmap.getWidth();<br>    int mBitmapHeight = sourceBitmap.getHeight();<br>    int mArrayColorLengh = mBitmapWidth * mBitmapHeight;<br>    int[] mArrayColor = new int[mArrayColorLengh];</p><pre><code>//循环bitmap 的每个像素点，查看alpha值int count = 0;for (int i = 0; i &lt; mBitmapHeight; i++) {    for (int j = 0; j &lt; mBitmapWidth; j++) {        //获得Bitmap 图片中每一个点的color颜色值        int color = sourceBitmap.getPixel(j, i);        int a = Color.alpha(color);        if(a != 0){//不等于0 即不透明部分，设置成我们想要的颜色            mArrayColor[count] = aimColor;        } else {//透明仍然为透明            int aimColor2 = Color.parseColor(&quot;#00000000&quot;);            mArrayColor[count] = aimColor2;        }        count++;    }}//根据数组创建新的BitmapBitmap newBitmap = Bitmap.createBitmap(mBitmapWidth,mBitmapHeight, Bitmap.Config.ARGB_8888);newBitmap.setPixels(mArrayColor,0,mBitmapWidth,0,0,mBitmapWidth,mBitmapHeight);return newBitmap;</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 方法三</span><br></pre></td></tr></table></figure><pre><code>//提取图像Alpha位图          public static Bitmap getAlphaBitmap(Bitmap mBitmap,int mColor) {  //          BitmapDrawable mBitmapDrawable = (BitmapDrawable) mContext.getResources().getDrawable(R.drawable.enemy_infantry_ninja);  //          Bitmap mBitmap = mBitmapDrawable.getBitmap();              //BitmapDrawable的getIntrinsicWidth（）方法，Bitmap的getWidth（）方法              //注意这两个方法的区别              //Bitmap mAlphaBitmap = Bitmap.createBitmap(mBitmapDrawable.getIntrinsicWidth(), mBitmapDrawable.getIntrinsicHeight(), Config.ARGB_8888);              Bitmap mAlphaBitmap = Bitmap.createBitmap(mBitmap.getWidth(), mBitmap.getHeight(), Config.ARGB_8888);              Canvas mCanvas = new Canvas(mAlphaBitmap);              Paint mPaint = new Paint();              mPaint.setColor(mColor);              //从原位图中提取只包含alpha的位图              Bitmap alphaBitmap = mBitmap.extractAlpha();              //在画布上（mAlphaBitmap）绘制alpha位图              mCanvas.drawBitmap(alphaBitmap, 0, 0, mPaint);              return mAlphaBitmap;          }  </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 实现</span><br></pre></td></tr></table></figure><p>   ImageView deviceIV.setDrawingCacheEnabled(true);<br>   Bitmap deviceBmp = deviceIV.getDrawingCache();<br>   int color = Color.parseColor(“#00000000”);<br>   Bitmap bitmap = getAlphaBitmap(deviceBmp,color);<br>   deviceIV.setImageBitmap(bitmap);<br>   时常会出现null，原因是超出系统提供最大的DrawingCache值，所以要在此代码前添加如下代码：<br>   deviceIV.measure(MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED), MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED));<br>   deviceIV.layout(0, 0, deviceIV.getMeasuredWidth(), deviceIV.getMeasuredHeight());</p><p><code>`</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;方法一、通过属性动画来改变图片的颜色&quot;&gt;&lt;a href=&quot;#方法一、通过属性动画来改变图片的颜色&quot; class=&quot;headerlink&quot; title=&quot;方法一、通过属性动画来改变图片的颜色&quot;&gt;&lt;/a&gt;方法一、通过属性动画来改变图片的颜色&lt;/h1&gt;&lt;figure c
      
    
    </summary>
    
    
  </entry>
  
</feed>
