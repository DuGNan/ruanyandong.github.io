<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>灵魂长者的博客</title>
  
  <subtitle>科技改变世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ruanyandong.github.io/"/>
  <updated>2018-12-30T13:27:41.308Z</updated>
  <id>https://ruanyandong.github.io/</id>
  
  <author>
    <name>阮严冬</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JDBC学习</title>
    <link href="https://ruanyandong.github.io/2018/12/30/JDBC%E5%AD%A6%E4%B9%A0/"/>
    <id>https://ruanyandong.github.io/2018/12/30/JDBC学习/</id>
    <published>2018-12-30T10:00:44.000Z</published>
    <updated>2018-12-30T13:27:41.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDBC之存贮过程的调用"><a href="#JDBC之存贮过程的调用" class="headerlink" title="JDBC之存贮过程的调用"></a>JDBC之存贮过程的调用</h1><h2 id="存储过程的代码"><a href="#存储过程的代码" class="headerlink" title="存储过程的代码"></a>存储过程的代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE imooc_db.sp_select_nofilter()</span><br><span class="line">BEGIN</span><br><span class="line">     select * from imooc_goddess;</span><br><span class="line">END;</span><br><span class="line">imooc_db是数据库的名字，sp_select_nofilter()是存储过程的方法名；</span><br></pre></td></tr></table></figure><h2 id="调用代码"><a href="#调用代码" class="headerlink" title="调用代码"></a>调用代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = DBUtil.getConnection();</span><br><span class="line">CallableStatement cs = conn.prepareCall(&quot;&#123;call sp_select_nofilter()&#125;&quot;);</span><br><span class="line">cs.execute();</span><br><span class="line">ResultSet rs = cd.getResultSet();</span><br></pre></td></tr></table></figure><h2 id="博客链接"><a href="#博客链接" class="headerlink" title="博客链接"></a>博客链接</h2><p>  <a href="https://www.cnblogs.com/Qian123/p/5349884.html" target="_blank" rel="noopener">JDBC慕课学习博客链接</a><br>  <a href="https://blog.csdn.net/wqc19920906/article/details/72825793" target="_blank" rel="noopener">Java 数据库系列教程–C3P0详解</a><br>  <a href="https://baike.baidu.com/item/c3p0" target="_blank" rel="noopener">c3p0配置</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JDBC之存贮过程的调用&quot;&gt;&lt;a href=&quot;#JDBC之存贮过程的调用&quot; class=&quot;headerlink&quot; title=&quot;JDBC之存贮过程的调用&quot;&gt;&lt;/a&gt;JDBC之存贮过程的调用&lt;/h1&gt;&lt;h2 id=&quot;存储过程的代码&quot;&gt;&lt;a href=&quot;#存储过程的代
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DialogFragment的宽高设置</title>
    <link href="https://ruanyandong.github.io/2018/12/29/DialogFragment%E7%9A%84%E5%AE%BD%E9%AB%98%E8%AE%BE%E7%BD%AE/"/>
    <id>https://ruanyandong.github.io/2018/12/29/DialogFragment的宽高设置/</id>
    <published>2018-12-28T17:56:34.000Z</published>
    <updated>2018-12-28T18:02:50.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onResume() &#123;</span><br><span class="line">    ViewGroup.LayoutParams params = getDialog().getWindow().getAttributes();</span><br><span class="line">    params.width = LayoutParams.MATCH_PARENT;</span><br><span class="line">    params.height = LayoutParams.MATCH_PARENT;</span><br><span class="line">    getDialog().getWindow().setAttributes((android.view.WindowManager.LayoutParams) params);</span><br><span class="line"></span><br><span class="line">    super.onResume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onResume() &#123;</span><br><span class="line">    getDialog().getWindow().setLayout(width, height);</span><br><span class="line">    super.onResume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;方法一&quot;&gt;&lt;a href=&quot;#方法一&quot; class=&quot;headerlink&quot; title=&quot;方法一&quot;&gt;&lt;/a&gt;方法一&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android依赖管理与私服搭建</title>
    <link href="https://ruanyandong.github.io/2018/12/03/Android%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E4%B8%8E%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/"/>
    <id>https://ruanyandong.github.io/2018/12/03/Android依赖管理与私服搭建/</id>
    <published>2018-12-02T17:37:17.000Z</published>
    <updated>2018-12-03T13:18:52.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android引入依赖的多种方式"><a href="#Android引入依赖的多种方式" class="headerlink" title="Android引入依赖的多种方式"></a>Android引入依赖的多种方式</h1><h2 id="一、第三方jar包"><a href="#一、第三方jar包" class="headerlink" title="一、第三方jar包"></a>一、第三方jar包</h2><p>   步骤：将jar包放入libs目录下面，然后add as library</p><h2 id="二、依赖本地模块"><a href="#二、依赖本地模块" class="headerlink" title="二、依赖本地模块"></a>二、依赖本地模块</h2><p>   步骤：新建本地module或者library，然后用本地模块进行依赖，例如：implementation project(‘:mylibrary’)</p><h2 id="三、aar方式依赖本地模块"><a href="#三、aar方式依赖本地模块" class="headerlink" title="三、aar方式依赖本地模块"></a>三、aar方式依赖本地模块</h2><p>   步骤：新建本地module或者library，然后build或者rebuild整个project，<br>   然后在新建的module或者library的build目录下的output目录下的aar目录，将aar文件放入需要依赖的libs目录下面，<br>   然后在gradle中加入一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">repositories&#123;</span><br><span class="line">        flatDir&#123;</span><br><span class="line">            dirs &apos;libs&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">implementation(name:&apos;lib2&apos;,ext:&apos;aar&apos;)</span><br><span class="line">name是aar文件的名字，ext是后缀名</span><br></pre></td></tr></table></figure></p><h2 id="四、在相应的gradle文件依赖"><a href="#四、在相应的gradle文件依赖" class="headerlink" title="四、在相应的gradle文件依赖"></a>四、在相应的gradle文件依赖</h2><p>   步骤：直接在dependencies进行implementation<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：implementation &apos;com.android.support:appcompat-v7:28.0.0&apos;</span><br></pre></td></tr></table></figure></p><h1 id="私服Nexus的获取和windows平台搭建"><a href="#私服Nexus的获取和windows平台搭建" class="headerlink" title="私服Nexus的获取和windows平台搭建"></a>私服Nexus的获取和windows平台搭建<img src="http://www.sonatype.com" alt="网址"></h1><p>  以下是一些参考博客</p><ul><li><a href="https://www.jianshu.com/p/b1fe26d5b8c8" target="_blank" rel="noopener">maven私服搭建及gradle上传</a>  </li><li><a href="https://blog.csdn.net/huweijian5/article/details/56670569" target="_blank" rel="noopener">Windows下搭建基于Nexus的Android Maven私服(一)</a></li><li><a href="https://blog.csdn.net/huweijian5/article/details/56834199" target="_blank" rel="noopener">Windows下搭建基于Nexus的Android Maven私服(二)</a></li><li><a href="https://www.jianshu.com/p/e8d999465edf" target="_blank" rel="noopener">Gradle中文教程系列-跟我学Gradle-4.1：Nexus私服的安装与配置</a></li><li><a href="https://blog.csdn.net/u011974987/article/details/52372185" target="_blank" rel="noopener">使用Gradle和Sonatype Nexus 搭建私有maven仓库</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android引入依赖的多种方式&quot;&gt;&lt;a href=&quot;#Android引入依赖的多种方式&quot; class=&quot;headerlink&quot; title=&quot;Android引入依赖的多种方式&quot;&gt;&lt;/a&gt;Android引入依赖的多种方式&lt;/h1&gt;&lt;h2 id=&quot;一、第三方jar包
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android绘图基础</title>
    <link href="https://ruanyandong.github.io/2018/11/15/Android%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80/"/>
    <id>https://ruanyandong.github.io/2018/11/15/Android绘图基础/</id>
    <published>2018-11-15T12:51:18.000Z</published>
    <updated>2018-11-15T13:08:31.039Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自定义控件之绘图篇：区域（Region）"><a href="#自定义控件之绘图篇：区域（Region）" class="headerlink" title="自定义控件之绘图篇：区域（Region）"></a><a href="https://blog.csdn.net/lu1024188315/article/details/77197968" target="_blank" rel="noopener">自定义控件之绘图篇：区域（Region）</a></h1><h1 id="自定义控件之绘图篇（三）：区域（Range）"><a href="#自定义控件之绘图篇（三）：区域（Range）" class="headerlink" title="自定义控件之绘图篇（三）：区域（Range）"></a><a href="https://blog.csdn.net/harvic880925/article/details/39056701" target="_blank" rel="noopener">自定义控件之绘图篇（三）：区域（Range）</a></h1><h1 id="android-Graphics：区域（Region）"><a href="#android-Graphics：区域（Region）" class="headerlink" title="android Graphics：区域（Region）"></a><a href="https://blog.csdn.net/wurensen/article/details/46437471" target="_blank" rel="noopener">android Graphics：区域（Region）</a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;自定义控件之绘图篇：区域（Region）&quot;&gt;&lt;a href=&quot;#自定义控件之绘图篇：区域（Region）&quot; class=&quot;headerlink&quot; title=&quot;自定义控件之绘图篇：区域（Region）&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://blog.csdn
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android事件分发</title>
    <link href="https://ruanyandong.github.io/2018/10/28/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"/>
    <id>https://ruanyandong.github.io/2018/10/28/Android事件分发/</id>
    <published>2018-10-28T10:29:23.000Z</published>
    <updated>2018-10-28T10:40:11.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h1><p>1.只有view，ViewGroup，Activity 具有事件分发和消费的功能。<br>2.Activity因为上最先接触到触摸事件，因此Activity没有事件拦截方法。即没有onInterceptTouchEvent方法。<br>3.对于不能添加子控件的view，不能对事件进行分发和拦截，它只有onTouchEvent事件。</p><h1 id="二-三个方法"><a href="#二-三个方法" class="headerlink" title="二.三个方法"></a>二.三个方法</h1><ul><li><p>1.public boolean dispatchTouchEvent(MotionEvent ev)<br>当触摸事件发生的时候，首先会被当前的activity进行分发，即当前activity的dispatchTouchEvent方法会被执行。<br>这个时候,该方法有三种返回的情况：</p><pre><code>return false： 表明事件不会被进行分发。事件会以冒泡的方式被传递给上层的view或activity的onTouchEvent方法进行消费掉。return true：表明该时间已经被处理。事件会被当前view或activity的dispatchTouchEvent给消费掉。不会再进行传递，事件到此结束。return super.dispatchTouchEvent(ev)：表明该事件将会被分发。此时当前View的onIntercepterTouchEvent方法会捕获该事件，判断需不需要进行事件的拦截。</code></pre></li><li><p>2.public boolean onInterceptTouchEvent(MotionEvent ev)<br>该方法用户拦截被传递过来的事件，用于判断被传递过来的事件是否需要被当前的view进行处理。<br>   return false : 不对事件进行拦截，放行该事件。事件会被传递到当前view的子控件中，由子控件中的dispatchTouchEvent方法进行分发处理。<br>   return true : 拦截该事件，将该事件交给当前view的onTouchEvent方法进行处理。<br>   return super.inInterceptTouchEvent(ev)：默认拦截方式，和return true一样。该事件会被拦截，将该事件交给当前view的onTouchEvent方法进行处理。（这里需要有一点说明，当有两个view。A view中有一个B view.点击A.A中如果onInterceptTouchEvent()返回super.interceptTouchEvent(ev),则事件将会被A进行拦截，交给A的onTouchEvent()进行处理，如果点击的是B，A中如果onInterceptTouchEvent()返回super.interceptTouchEvent(ev)，则事件将不会被拦截，会被分发到子控件中）</p></li><li><p>3.public boolean onTouchEvent(MotionEvent event)<br>当前的view把事件进行了拦截，则事件则会被传递到该方法中<br>   return false：表明没有消费该事件，事件将会以冒泡的方式一直被传递到上层的view或Activity中的onTouchEvent事件处理。如果最上层的view或Activity中的onTouchEvent还是返回false。则该事件将消失。接下来来的一系列事件都将会直接被上层的onTouchEvent方法捕获<br>   return true: 表明消费了该事件，事件到此结束。<br>   return super.onTouchEvent(event)：默认情况，和return false一样。</p></li></ul><h1 id="验证"><a href="#验证" class="headerlink" title="验证:"></a>验证:</h1><p>MainActivity FatherView ChildView中几个方法都返回super.<em>**</em>TouchEvent(ev)<br>     分析:</p><pre><code>当点击屏幕。MainActivity 中的dispatchTouchEvent方法先执行，打印MainActivity-dispatchTouchEvent--&gt;ACTION_DOWN因为返回的是super.dispatchTouchEvent(ev),所以事件ev将会被分发，但是MainActivity中没有onInterceptTouchEvent()方法，所以事件被传递到FatherView中的dispatchTouchEvent方法.打印FatherView-dispatchTouchEvent--&gt;ACTION_DOWN在FatherView中dispatchTouchEvent返回的是super.dispatchTouchEvent(ev),所有事件会被分发。FatherView中的onInterceptTouchEven()中的方法被执行。打印FatherView-onInterceptTouchEven--&gt;ACTION_DOWNFatherView中的onInterceptTouchEven()返回的是super.onInterceptTouchEvent(ev)。在这里，（1）如果点击的是屏幕中的ChildView。事件将不会被拦截，会被传递到ChildView中的dispatchTouchEvent方法中。（2）如果点击的值FatherView则事件将会被拦截。FatherView中的onTouchEvent()方法将被执行。以（1）为例，将打印ChildView-dispatchTouchEvent--&gt;ACTION_DOWN。ChildView中dispatchTouchEvent返回的是super.dispatchTouchEvent(ev),所有事件会被分发。打印ChildView-onInterceptTouchEvent--&gt;ACTION_DOWN。此时ChildView中onInterceptTouchEvent返回的是super.onInterceptTouchEvent(ev),，而且已经没有子控件了，所以事件将被拦截。打印ChildView-onTouchEvent--&gt;ACTION_DOWN。在childView中onTouchEvent()返回额是super.onTouchEvent(ev)。事件将不会被消耗，将以冒泡的方式传递到上层空间中的onTouchEvent(),此处上层空间中的onTouchEvent返回的都是super.onTouchEvent(ev)。所以讲一次打印 Father-onTouchEvent--&gt;ACTION_DOWN。 MainActivty-onTouchEvent--&gt;ACTION_DOWN。之后的事件动作，将不再被MainActivity分发到子view，直接被MainActivty中的onTouchEvent处理消耗。打印MainActivity-dispatchTouchEvent--&gt;ACTION_UP,MainActivty-onTouchEvent--&gt;ACTION_UP        MainActivity-dispatchTouchEvent--&gt;ACTION_DOWN        FatherView-dispatchTouchEvent--&gt;ACTION_DOWN        FatherView-onInterceptTouchEven--&gt;ACTION_DOWN        ChildView-dispatchTouchEvent--&gt;ACTION_DOWN        ChildView-onInterceptTouchEvent--&gt;ACTION_DOWN。        ChildView-onTouchEvent--&gt;ACTION_DOWN        Father-onTouchEvent--&gt;ACTION_DOWN。         MainActivty-onTouchEvent--&gt;ACTION_DOWN        MainActivity-dispatchTouchEvent--&gt;ACTION_UP,        MainActivty-onTouchEvent--&gt;ACTION_UP</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一. 概述&quot;&gt;&lt;/a&gt;一. 概述&lt;/h1&gt;&lt;p&gt;1.只有view，ViewGroup，Activity 具有事件分发和消费的功能。&lt;br&gt;2.Activity因为上最先
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android应用安装和卸载时的广播</title>
    <link href="https://ruanyandong.github.io/2018/10/23/Android%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD%E6%97%B6%E7%9A%84%E5%B9%BF%E6%92%AD/"/>
    <id>https://ruanyandong.github.io/2018/10/23/Android应用安装和卸载时的广播/</id>
    <published>2018-10-23T12:12:46.000Z</published>
    <updated>2018-10-23T12:21:02.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在android系统中，安装和卸载都会发送广播，当应用安装完成后系统会发android-intent-action-PACKAGE-ADDED广播。"><a href="#在android系统中，安装和卸载都会发送广播，当应用安装完成后系统会发android-intent-action-PACKAGE-ADDED广播。" class="headerlink" title="在android系统中，安装和卸载都会发送广播，当应用安装完成后系统会发android.intent.action.PACKAGE_ADDED广播。"></a>在android系统中，安装和卸载都会发送广播，当应用安装完成后系统会发android.intent.action.PACKAGE_ADDED广播。</h2><p>   可以通过intent.getDataString()获得所安装的包名。当卸载程序时系统发android.intent.action.PACKAGE_REMOVED广播。<br>   同样intent.getDataString()获得所卸载的包名。</p><h2 id="在安卓APP项目开发中，我们有这样的需求："><a href="#在安卓APP项目开发中，我们有这样的需求：" class="headerlink" title="在安卓APP项目开发中，我们有这样的需求："></a>在安卓APP项目开发中，我们有这样的需求：</h2><pre><code>APP安装更新完成后，需要把 APK 文件删除</code></pre><p>这里，我们可以通过安卓四大组件之一 —— 广播-接收器，来助阵。</p><p>广播有动态注册和静态注册两种方式，此处用静态注册方式。</p><p>在 AndroidManifest.xml 文件中静态注册广播接收器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver android:name=&quot;具体包名.广播接收器名&quot;</span><br><span class="line">            android:enabled=&quot;true&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=&quot;android.intent.action.PACKAGE_ADDED&quot; /&gt;</span><br><span class="line">                &lt;action android:name=&quot;android.intent.action.PACKAGE_REPLACED&quot; /&gt;</span><br><span class="line">                &lt;action android:name=&quot;android.intent.action.PACKAGE_REMOVED&quot; /&gt;</span><br><span class="line">                &lt;!--涉及到存储卡状态改变的时候必须添加--&gt;</span><br><span class="line">                &lt;data android:scheme=&quot;package&quot; /&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/receiver&gt;</span><br></pre></td></tr></table></figure></p><h1 id="几个-intent-filter-name-相信从名字就能知道什么意思了。"><a href="#几个-intent-filter-name-相信从名字就能知道什么意思了。" class="headerlink" title="几个 intent-filter name 相信从名字就能知道什么意思了。"></a>几个 intent-filter name 相信从名字就能知道什么意思了。</h1><pre><code>PACKAGE_ADDED 接受包被添加时发送的广播PACKAGE_REPLACED 接受包被替换时发送的广播PACKAGE_REMOVED 接受包被移除时发送的广播</code></pre><p>安卓系统在我们安装或卸载APP等操作时，会发送以上的一些广播包，我们这里设个接收器来”监听“这些操作的发生。</p><p>新建一个类，继承自 BroadcastReceiver，重写 onReceive 方法，具体逻辑处理可在此书写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import android.content.BroadcastReceiver;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.os.Environment;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by Moses on 2017/12/5.</span><br><span class="line"> *</span><br><span class="line"> * PackageInstallSuccessfulReceiver</span><br><span class="line"> *</span><br><span class="line"> * 接受 广播 软件包被添加、删除和替换时发出</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class PackInstSucRecei extends BroadcastReceiver &#123;</span><br><span class="line">    private String apkfileName = &quot;app-debug.apk&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line"></span><br><span class="line">        if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())) &#123;</span><br><span class="line">            Log.d(TAG, &quot;监听到系统广播,包被添加: &quot;);</span><br><span class="line">            //删除apk文件</span><br><span class="line">            deleteApkfile(apkfileName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (Intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction())) &#123;</span><br><span class="line">            Log.d(TAG, &quot;监听到系统广播,包被移除: &quot;);</span><br><span class="line">            Log.d(TAG, &quot;onReceive: &quot; + intent.getDataString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (Intent.ACTION_PACKAGE_REPLACED.equals(intent.getAction())) &#123;</span><br><span class="line">            Log.d(TAG, &quot;监听到系统广播,包被替换: &quot;);</span><br><span class="line">            Log.d(TAG, &quot;onReceive: &quot;+ intent.getPackage());</span><br><span class="line">            deleteApkfile(apkfileName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Boolean deleteApkfile(String apkFileName)&#123;</span><br><span class="line">        //Apk文件路径可自定义，此处用 download 文件夹</span><br><span class="line">        File apkfile = new File(Environment</span><br><span class="line">                .getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)</span><br><span class="line">                .getPath(), apkFileName);</span><br><span class="line">        if (!apkfile.exists()) &#123;</span><br><span class="line">            Log.d(TAG, &quot;apkfile delete already! &quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //调用现成的文件操作方法删除文件</span><br><span class="line">            if (apkfile.delete())</span><br><span class="line">                Log.d(TAG, &quot;apkfile delete successfully! &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;在android系统中，安装和卸载都会发送广播，当应用安装完成后系统会发android-intent-action-PACKAGE-ADDED广播。&quot;&gt;&lt;a href=&quot;#在android系统中，安装和卸载都会发送广播，当应用安装完成后系统会发android-in
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android广播的顺序</title>
    <link href="https://ruanyandong.github.io/2018/10/23/Android%E5%B9%BF%E6%92%AD%E7%9A%84%E9%A1%BA%E5%BA%8F/"/>
    <id>https://ruanyandong.github.io/2018/10/23/Android广播的顺序/</id>
    <published>2018-10-23T05:46:46.000Z</published>
    <updated>2018-10-23T06:40:26.690Z</updated>
    
    <content type="html"><![CDATA[<p><em>为了利于各个进程应用之间的通信，android提供了一个很方便的处理方式：广播机制。广播机制顾名思义，就是广播发送者无需判断具体某个接收者的存在，把广播发送出去，任务即完成。这样保证了有效通信的同时又最大限度的降低了android系统各个模块的耦合性。</em></p><h1 id="Android广播有两个很重要的要素："><a href="#Android广播有两个很重要的要素：" class="headerlink" title="Android广播有两个很重要的要素："></a>Android广播有两个很重要的要素：</h1><ul><li><p>1 广播 - 用于发送广播</p><pre><code>有序广播  -  被广播接收器接收后，可被终止，无法往下继续传达。         典型代表：短信广播普通广播  -  发送至每一个已经注册（订阅）的广播接收器，无法被终止。 典型代表：开机启动广播</code></pre></li><li><p>2 广播接收器 - 用于订阅广播后接收广播</p><pre><code>静态注册广播 - 在AndroidManifest.xml中设置，程序不用启动亦可接收。 典型代表：很多开机启动的APP，都是接收开机启动广播带起服务的。动态注册广播 - 代码中注册广播，程序未启动时，无法接收广播。</code></pre></li></ul><h1 id="有序广播的优先级："><a href="#有序广播的优先级：" class="headerlink" title="有序广播的优先级："></a>有序广播的优先级：</h1><ul><li>1）动态注册优先级别最高，其次静态注册</li><li>2）在动态注册中，最早动态注册优先级别最高</li><li>3）在静态注册中，最早安装的程序，静态注册优先级别最高（注：安装APK会解析manifest.xml,把其加入队列）</li><li>4）都是静态注册的情况下，按照字符排列顺序决定谁先收到广播消息</li><li>5）adb install xxx.apk安装的应用优先级比adb push到其他目录的应用高</li><li>总体来说：对于接收同一个广播，在相同优先级的情况下，动态注册优先级别高于静态注册。在动态注册中，最早动态注册优先级别最高；在静态注册中，最早安装的程序，静态注册优先级别最高（安装APK会解析manifest.xml,把其加入队列）</li></ul><h2 id="我们以如何抢先开机启动为例，来说明接收无序广播的静态广播接收器的接收顺序。首先我们要明确两个问题："><a href="#我们以如何抢先开机启动为例，来说明接收无序广播的静态广播接收器的接收顺序。首先我们要明确两个问题：" class="headerlink" title="我们以如何抢先开机启动为例，来说明接收无序广播的静态广播接收器的接收顺序。首先我们要明确两个问题："></a>我们以如何抢先开机启动为例，来说明接收无序广播的静态广播接收器的接收顺序。首先我们要明确两个问题：</h2><ul><li>A，接收无序广播的接收器接收到广播的顺序是有序的，</li><li><p>B，接收无序广播的接收器也一样可以设置优先级的。</p><pre><code>我们以开机时候发出的广播android.intent.action.BOOT_COMPLETED为例，这是个无序广播。如果应用想要开启自启动，那么就要监听这个广播，程序启动之前，动态广播接收器肯定是无法使用的，只能在XML中静态注册。大家都知道，第三方应用是存放在/data/app目录下，当安装完毕之后，你会找到一个文件，他的名字是以与安装的应用包名开始的，然后可能会跟着&quot;-数字.apk&quot;，比如：com.android.test-1.apk。接收的顺序与这个名字是有关的！那么关系是怎样的呢？</code></pre></li></ul><p>（1）系统在开机的时候，会按着一个顺序解析apk<br>1，首先，会解析手机中的/system/framework这个目录，原生系统中，这下面就一个apk - framework-res.apk，当然各个厂商也会加入自己的内容<br>2，然后受到重视的文件夹按顺序分别为：<br>/system/app<br>/vendor/app<br>/data/app<br>/drm/app-private</p><p>那么每个文件夹下解析的顺序是怎样的呢？我们先只看/data/app，也就是用户安装的第三方应用的存放位置，这与下面代码返回结果的顺序是一致的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;/data/app/&quot;);</span><br><span class="line">String[] files = file.list();</span><br></pre></td></tr></table></figure></p><p>也就是说，我们按顺序打印这个数组，就能知道哪个接收器会先接收到这个广播，哪个会后接收到</p><p>（2）网上的CODE  DEMO</p><pre><code>做了一个实验，我写了几个只有receiver的应用，把他们的包名分别设置为大家常用的、关系的应用包名</code></pre><p>飞信：cn.com.fetion<br>LBE隐私卫士：com.lbe.security.lite<br>Handsent：com.handsent.nextsms<br>金山手机卫士：com.ijinshan.mguard<br>360手机卫士：com.qihoo360.mobilesafe<br>QQ手机管家：com.tencent.qqpimsecure<br>一个测试应用：com.example.boottest<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;/data/app/&quot;);</span><br><span class="line">String[] files = file.list();</span><br><span class="line">for (int i = 0; i &lt; files.length; i++)&#123;</span><br><span class="line">System.out.println(&quot;/data/app/:files[&quot;+(i+1)+&quot;]:&quot; + files[i]); //在打印语句中(i+1)的值可以自动转成字符</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果为：<br>/data/app/:files[8]:com.tencent.qqpimsecure-1.apk<br>/data/app/:files[9]:com.qihoo360.mobilesafe-1.apk<br>/data/app/:files[10]:com.ijinshan.mguard-1.apk<br>/data/app/:files[11]:cn.com.fetion-1.apk<br>/data/app/:files[12]:com.lbe.security.lite-1.apk<br>/data/app/:files[13]:com.handsent.nextsms-1.apk<br>/data/app/:files[14]:com.example.boottest-1.apk</p><p>如果其中一个优先级较高，比如cn.com.fetion，那么实际的接收顺序为<br>getPackageName:cn.com.fetion<br>getPackageName:com.tencent.qqpimsecure<br>getPackageName:com.qihoo360.mobilesafe<br>getPackageName:com.ijinshan.mguard<br>getPackageName:com.lbe.security.lite<br>getPackageName:com.handsent.nextsms<br>getPackageName:com.example.boottest<br>所以如果同优先级的静态接收器想先接收某个广播，就要在包名上修改已让它靠前显示。</p><p>（3）自己的CODE实验，在一个安卓应用中加入了如下几行测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;/data/app/&quot;);</span><br><span class="line">if (file == null)</span><br><span class="line">return;</span><br><span class="line">String[] files = file.list();</span><br><span class="line">if (files == null)</span><br><span class="line">return;</span><br><span class="line">for (int i = 0; i &lt; files.length; i++)&#123;</span><br><span class="line">Log.i(&quot;zhangcheng&quot;,&quot;/data/app/:files[&quot;+String.valueOf(i+1)+&quot;]:&quot; + files[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的【1】：目录权限一定要有，除了ROOT外，我还设置了777属性，否则file和files都可能是空指针，应用运行报错。【2】LOG的输出必须全都是字符，不是字符的要手工转成字符。我的输出如下：</p><p>/data/app/:files[1]:.restore_list<br>/data/app/:files[2]:HN_Facebook.apk<br>/data/app/:files[3]:HN_IndonesiaCanggih.apk<br>/data/app/:files[4]:HN_KingsoftOffice.apk<br>/data/app/:files[5]:HN_Messenger.apk<br>/data/app/:files[6]:HN_Twitter.apk<br>/data/app/:files[7]:com.qihoo.appstore-1.apk<br>/data/app/:files[8]:com.qihoo360.contacts-1.apk<br>/data/app/:files[9]:com.example.app-1.apk<br>/data/app/:files[10]:com.example.test-2.apk<br>（4）以上讲述的是静态接收器，那动态接收器的优先级呢？</p><pre><code>android系统在收到短信息的时候会发送广播，但是此广播是有序广播，也就是说：先接收到广播的人，如果心情不好，它就不会向后传递此广播，后面的人就不会知道有短信到来。这与无序广播不同，无序广播并不是真的没有顺序，无序广播的接收者也是排队等待广播，只不过是在传递过程中，大家必须遵守规则一直把消息传递给最后一个。以大家关心的接收短消息为例，想要在程序中接收短信，就要接收如下广播android.provider.Telephony.SMS_RECEIVED。系统把它作为有序广播进行发送，那么，谁第一个接收到短信将变得至关重要。上一节说过静态接收器的接收顺序，那么动态接收器和静态接收器相比呢？答案是静态接收器优先级低于动态接收器，也就是说，无论多么高级别的静态接收器和多么低级别的动态接收器都接收同一广播，永远都是动态接收器先接收到！同等优先级的动态接收器，先注册的先接收。</code></pre><p>（5）有些广播必须是动态注册的receiver才能收到<br>   比如ACTION_SCREEN_ON，当屏幕被点亮的时候系统发送此广播，如果你尝试在manifest中注册receiver来接收，那么会失败，这是为什么呢？他们在Intent中都设置了Intent.FLAG_RECEIVER_REGISTERED_ONLY，所以如果要接收，必须动态注册广播接收器，ACTION_SCREEN_OFF也是如此。</p><h1 id="广播注册过程和接收广播顺序过程"><a href="#广播注册过程和接收广播顺序过程" class="headerlink" title="广播注册过程和接收广播顺序过程"></a>广播注册过程和接收广播顺序过程</h1><p><img src="https://images.cnitblog.com/blog/320080/201305/22234432-b4340279f6f44f68a5fdeadb5778b788.png" alt=""></p><pre><code>                                         图1 注册广播流程简图静态广播接收器 由PackageManagerService负责，当手机启动时（或者新安装了应用），PackageManagerService负责扫描手机中所有已安装的APP应用（题外话，确定不再使用的APP需要卸载了），将AndroidManifest.xml中 有关注册广播的信息 解析出来，存储至一个全局静态变量当中mReceivers。</code></pre><h1 id="需要注意的是："><a href="#需要注意的是：" class="headerlink" title="需要注意的是："></a>需要注意的是：</h1><p> 1 PackageManagerService扫描目录的顺序如下：</p><p>　　system/framework</p><p>　　system/app</p><p>　　vendor/app</p><p>　　data/app</p><p>　　drm/app-private</p><p> 2 当处于同一目录下时：按照file.list()的返回顺序。（题外话：因为在data/app下的应用都是用户安装的，并且都是以com.xxx.xxx-1.apk 的形式出现，所以如果打算做手机管家之类的应用，需要好好的研究下包名，争取在file.list()的独木桥下抢的头筹—优先接收开机启动完成的广播。）</p><p> 3 在此处并未对 接收顺序做完整的排序。（注意修饰词完整的，毕竟先扫描的当然会有一定优先级）</p><pre><code>动态广播接收器 由ActivityManagerService负责，当APP的服务或者进程起来之后，执行了注册广播接收的代码逻辑，即进行加载，最后会存储在一个全局静态变量</code></pre><p>mReceiverResolver中。</p><h1 id="需要注意的是：-1"><a href="#需要注意的是：-1" class="headerlink" title="需要注意的是："></a>需要注意的是：</h1><pre><code>1 这个并非是一成不变的，当程序被杀死之后，  已注册的动态广播接收器也会被移出mReceiverResolver，直到下次程序启动，再进行动态广播的注册，当然这里面的顺序也已经变更了一次。2  这里也并没完整的进行广播的排序，只记录的注册的先后顺序，并未有结合优先级的处理。</code></pre><h1 id="当有广播发出时，接收顺序如下："><a href="#当有广播发出时，接收顺序如下：" class="headerlink" title="当有广播发出时，接收顺序如下："></a>当有广播发出时，接收顺序如下：</h1><p><img src="https://images.cnitblog.com/blog/320080/201305/23090937-42036226199c4985a3902a98a6541f15.jpg" alt=""></p><pre><code>图2 广播接收流程简图</code></pre><p>   在ActivityManagerService处理广播，当广播为有序广播时，将动态广播接收器和动态广播接收器合并起来，形成最终的有序广播接收顺序。<br>   上述的规则1排序为：<br>                                1 优先级高的先接收<br>                                2 同优先级的动静态广播接收器，动态优先于静态<br>                                3 同优先级的动态广播接收器  或者同优先级的静态广播接收器，按照图1 的流程注册顺序。<br>                                   即静态：先扫描的大于后扫描的，动态：先注册的大于后注册的。</p><p>   当广播为普通广播时，规则2排序为：<br>                                1 无视优先级，动态广播接收器优先于静态广播接收器<br>                                2 同规则1排序的第3点  </p><h1 id="最后举个例子："><a href="#最后举个例子：" class="headerlink" title="最后举个例子："></a>最后举个例子：</h1><p>（以下的静A 表示静态广播接收器，同理动B。）</p><p>1 静A (优先级1）</p><p>2 动B（优先级1）</p><p>3 静C （优先级2，后扫描）</p><p>4 静D （优先级2，先扫描）</p><p>5 动E   (优先级2，先注册）</p><p>6 动F  （优先级2，后注册）</p><p>当来了一个 有序广播，接收顺序如下：动E &gt;  动F  &gt; 静D &gt; 静C &gt; 动B &gt; 静A</p><p>当来了一个 普通广播，接收顺序如下：动E &gt;  动F  &gt; 动B &gt; 静D &gt; 静C &gt; 静A                                </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;为了利于各个进程应用之间的通信，android提供了一个很方便的处理方式：广播机制。广播机制顾名思义，就是广播发送者无需判断具体某个接收者的存在，把广播发送出去，任务即完成。这样保证了有效通信的同时又最大限度的降低了android系统各个模块的耦合性。&lt;/em&gt;&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android内存溢出和内存泄漏</title>
    <link href="https://ruanyandong.github.io/2018/10/23/Android%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>https://ruanyandong.github.io/2018/10/23/Android内存溢出和内存泄漏/</id>
    <published>2018-10-22T16:10:16.000Z</published>
    <updated>2018-10-22T17:24:29.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安卓官方学习教程"><a href="#安卓官方学习教程" class="headerlink" title="安卓官方学习教程"></a><a href="http://hukai.me/android-training-course-in-chinese/basics/index.html" target="_blank" rel="noopener">安卓官方学习教程</a></h1><h1 id="一、内存泄露"><a href="#一、内存泄露" class="headerlink" title="一、内存泄露"></a>一、内存泄露</h1><pre><code>垃圾回收器无法回收原本应该被回收的对象，这个对象就引发了内存泄露。内存泄露的危害：    （1）过多的内存泄露最终会导致内存溢出（OOM）    （2）内存泄露导致可用内存不足，会触发频繁GC，不管是Android2.2以前的单线程GC还是现在的CMS和G1，都有一部分的操作会导致用户线程停止（就是所谓的Stop the world），从而导致UI卡顿。</code></pre><h1 id="二、内存溢出（OOM）"><a href="#二、内存溢出（OOM）" class="headerlink" title="二、内存溢出（OOM）"></a>二、内存溢出（OOM）</h1><pre><code>Android为每个进程设置Dalvik Heap Size阈值，这个阈值在不同的设备上会因为RAM大小不同而各有差异。如果APP想要分配的内存超过这个阈值，就会发生OOM。ActivityManager.getMemoryClass()可以查询当前APP的Heap Size阈值，单位是MB。在3.x以前，Bitmap分配在Native heap中，而在4.x之后，Bitmap分配在Dalvik或ART的Java heap中。Android 2.x系统，当dalvik allocated + native allocated + 新分配的大小 &gt;= dalvik heap 最大值时候就会发生OOM，也就是说在2.x系统中，考虑native heap对每个进程的内存限制。Android 4.x系统，废除了native的计数器，类似bitmap的分配改到dalvik的java heap中申请，只要allocated + 新分配的内存 &gt;= dalvik heap 最大值的时候就会发生OOM（art运行环境的统计规则还是和dalvik保持一致），也就是说在4.x系统中，不考虑native heap对每个进程的内存限制，native heap只会收到本机总内存（包括RAM以及SWAP区或分页文件）的限制。</code></pre><h1 id="一、原理"><a href="#一、原理" class="headerlink" title="一、原理"></a>一、原理</h1><pre><code>内存溢出（Out of memory）:系统会给每个APP分配内存也就是Heap size值，当APP所需要的内存大于了系统分配的内存，就会造成内存溢出；通俗点就是10L桶只能装10L水，但是你却用来装11L的水，那就有1L的水就会溢出内存泄漏（Memory leak）:当一个对象不在使用了，本应该被垃圾回收器（JVM）回收，但是这个对象由于被其他正在使用的对象所持有，造成无法被回收的结果，通俗点就是系统把一定的内存值A借给程序，但是系统却收不回完整的A值，那就是内存泄漏</code></pre><h1 id="二、两者的关系"><a href="#二、两者的关系" class="headerlink" title="二、两者的关系"></a>二、两者的关系</h1><pre><code>内存泄漏是造成内存溢出（OOM）的主要原因，因为系统分配给每个程序的内存也就是Heap size的值都是有限的，当内存泄漏到一定值的时候，最终会发生程序所需要的内存值加上泄漏值大于了系统所分配的内存额度，就是触发内存溢出</code></pre><h1 id="三、危害"><a href="#三、危害" class="headerlink" title="三、危害"></a>三、危害</h1><pre><code>内存溢出：会触发Java.lang.OutOfMemoryError，造成程序崩溃内存泄漏：过多的内存泄漏会造成OOM的发送，同样也会造成相关UI的卡顿现象</code></pre><h1 id="四、如何避免内存泄漏"><a href="#四、如何避免内存泄漏" class="headerlink" title="四、如何避免内存泄漏"></a>四、如何避免内存泄漏</h1><h2 id="1、使用轻量的数据结构"><a href="#1、使用轻量的数据结构" class="headerlink" title="1、使用轻量的数据结构"></a>1、使用轻量的数据结构</h2><ul><li>使用ArrayMap/SparseArray来代替HashMap，ArrayMap/SparseArray是专门为移动设备设计的高效的数据结构。</li><li><em>HashMap实现原理:</em></li><li>HashMap内部使用一个默认容量为16的数组来存储数据，采用拉链法解决hash冲突（数组+链表），如下图：<br><img src="https://img-blog.csdn.net/20160331144232258" alt="拉链法的hashMap"></li><li>Entry存储的内容有key、value、hash值、next指针，通过计算hash(key)%len找到Entry在数组中的位置。</li><li><p>缺点：（1）就算没有数据，也需要分配默认16个元素的数组（2）一旦数据量达到Hashmap限定容量的75%，就将按两倍扩容</p></li><li><p><em>SparseArray:</em></p></li><li>支持int类型，避免自动装箱，但是也只支持int类型的key</li><li>内部通过两个数组来进行数据存储的，一个存储key，另外一个存储value</li><li>因为key是int，在查找时，采用二分查找，效率高，SparseArray存储的元素都是按元素的key值从小到大排列好的。 （Hashmap通过遍历Entry数组来获取对象）</li><li><p>默认初始size为0，每次增加元素，size++</p></li><li><p><em>ArrayMap:</em></p></li><li>跟SparseArray一样，内部两个数组，但是第一个存key的hash值，一个存value，对象按照key的hash值排序，二分查找也是按照hash</li><li>查找index时，传入key，计算出hash，通过二分查找hash数组，确定index<h2 id="2、不要使用Enum"><a href="#2、不要使用Enum" class="headerlink" title="2、不要使用Enum"></a>2、不要使用Enum</h2><h2 id="3、大胖子Bitmap的处理"><a href="#3、大胖子Bitmap的处理" class="headerlink" title="3、大胖子Bitmap的处理"></a>3、大胖子Bitmap的处理</h2></li><li>Bitmap压缩</li><li>Lru机制处理Bitmap，也可以使用那些有名的图片缓存框架。<h2 id="4、不要使用String进行字符串拼接"><a href="#4、不要使用String进行字符串拼接" class="headerlink" title="4、不要使用String进行字符串拼接"></a>4、不要使用String进行字符串拼接</h2></li><li>严格的讲，String拼接只能归结到内存抖动中，因为产生的String副本能够被GC，不会造成内存泄露。</li><li>频繁的字符串拼接，使用StringBuffer或者StringBuilder代替String，可以在一定程度上避免OOM和内存抖动。<h2 id="5、非静态内部类内存泄露"><a href="#5、非静态内部类内存泄露" class="headerlink" title="5、非静态内部类内存泄露"></a>5、非静态内部类内存泄露</h2></li><li>在Activity中创建非静态内部类，非静态内部类会持有Activity的隐式引用，若内部类生命周期长于Activity，会导致Activity实例无法被回收。（屏幕旋转后会重新创建Activity实例，如果内部类持有引用，将会导致旋转前的实例无法被回收）。</li><li>解决方案：如果一定要使用内部类，就改用static内部类，在内部类中通过WeakReference的方式引用外界资源。</li><li>正确的代码示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static class ImageDownloadTask extends AsyncTask&lt;String, Void, Bitmap&gt; &#123;</span><br><span class="line"></span><br><span class="line">        private String url;</span><br><span class="line">        private WeakReference&lt;PhotoAdapter&gt; photoAdapter;</span><br><span class="line"></span><br><span class="line">        public ImageDownloadTask(PhotoAdapter photoAdapter) &#123;</span><br><span class="line">            this.photoAdapter = new WeakReference&lt;PhotoAdapter&gt;(photoAdapter);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected Bitmap doInBackground(String... params) &#123;</span><br><span class="line">            //在后台开始下载图片</span><br><span class="line">            url = params[0];</span><br><span class="line">            Bitmap bitmap = photoAdapter.get().loadBitmap(url);</span><br><span class="line">            if (bitmap != null) &#123;</span><br><span class="line">                //把下载好的图片放入LruCache中</span><br><span class="line">                String key = MD5Tools.decodeString(url);</span><br><span class="line">                photoAdapter.get().put(key, bitmap);</span><br><span class="line">            &#125;</span><br><span class="line">            return bitmap;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected void onPostExecute(Bitmap bitmap) &#123;</span><br><span class="line">            super.onPostExecute(bitmap);</span><br><span class="line">            //把下载好的图片显示出来</span><br><span class="line">            ImageView mImageView = (ImageView) photoAdapter.get().mGridView.get().findViewWithTag(MD5Tools.decodeString(url));</span><br><span class="line">            if (mImageView != null &amp;&amp; bitmap != null) &#123;</span><br><span class="line">                mImageView.setImageBitmap(bitmap);</span><br><span class="line">                photoAdapter.get().mDownloadTaskList.remove(this);//把下载好的任务移除</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="6、匿名内部类内存泄漏"><a href="#6、匿名内部类内存泄漏" class="headerlink" title="6、匿名内部类内存泄漏"></a>6、匿名内部类内存泄漏</h2><ul><li>跟非静态内部类一样，匿名内部类也会持有外部类的隐式引用，比较常见的情况有，耗时Handler，耗时Thread，都会造成内存泄漏，解决方式也是static+WeakReference，下面给出正确写法。</li><li><p>Handler的正确写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private static class MyHandler extends Handler &#123;</span><br><span class="line"></span><br><span class="line">    private final WeakReference&lt;Context&gt; context;</span><br><span class="line"></span><br><span class="line">    private MyHandler(Context context) &#123;</span><br><span class="line">        this.context = new WeakReference&lt;Context&gt;(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        switch (msg.what) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final MyHandler mHandler = new MyHandler(this);</span><br><span class="line"></span><br><span class="line">private static final Runnable sRunnable = new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_home);</span><br><span class="line">    //  发送一个10分钟后执行的一个消息</span><br><span class="line">    mHandler.postDelayed(sRunnable, 600000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Thread的正确写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private static class MyThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            // TODO 耗时任务</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">new MyThread().start();</span><br><span class="line">``` </span><br><span class="line">## 7、Context持有导致内存泄漏</span><br><span class="line">* Activity Context被传递到其他实例中，这可能导致自身被引用而发生泄漏。</span><br><span class="line">* 解决：对于大部分非必须使用Activity Context的情况（创建Dialog的Context必须是Activity Context），应该使用Application Context。</span><br><span class="line"></span><br><span class="line">## 8、记得注销监听器</span><br><span class="line">* 注册监听器的时候会add Listener，不要忘记在不需要的时候remove掉Listener。</span><br><span class="line"></span><br><span class="line">## 9、资源文件需要选择合适的文件夹进行存放</span><br><span class="line">* hdpi/xhdpi/xxhdpi等等不同dpi的文件夹下的图片在不同的设备上会经过scale的处理。例如我们只在hdpi的目录下放置了一张100100的图片，那么根据换算关系，xxhdpi的手机去引用那张图片就会被拉伸到200200。需要注意到在这种情况下，内存占用是会显著提高的。对于不希望被拉伸的图片，需要放到assets或者nodpi的目录下。</span><br><span class="line"></span><br><span class="line">## 10、谨慎使用static对象</span><br><span class="line">* static对象的生命周期过长，应该谨慎使用</span><br><span class="line"></span><br><span class="line">## 11、谨慎使用单例中不合理的持有</span><br><span class="line">* 单例中的对象生命周期与应用一致，注意不要在单例中进行不必要的外界引用持有。如果一定要引用外部变量，需要在外部变量生命周期结束的时候接触引用（赋为null）。</span><br><span class="line"></span><br><span class="line">## 12、一定要记得关闭无用连接</span><br><span class="line">* 在onDestory中关闭Cursor，I/O，数据库，网络的连接用完记得关闭。</span><br><span class="line"></span><br><span class="line">## 13、注意：谨慎使用lager heap</span><br><span class="line">* 不同的设备有不容的RAM，他们为应用程序设置了不同大小的Heap的阈值。虽然可以通过largeHeap=true的属性来为应用获得一个更大的heap空间，然后通过getLargeMemoryClass()来获取到这个更大的heap阈值。但是你要注意，largeHeap只是为了一些本来就需要大量内存的APP存在，比如图墙和图片编辑软件。所以，不要随意的使用large heap，否则会影响系统整体的用户体验，会使每次gc时间更长。</span><br><span class="line"></span><br><span class="line"># 四、内存泄露检测</span><br><span class="line">* 这里介绍LeakCanary，一款非常好用的内存泄露检测工具，安装在手机上，能够通过Log的方式告诉你是哪块代码发生了内存泄露。</span><br><span class="line">* 使用方法，在Application中install LeakCanary（默认只能检测Activity内容的内存泄露）：</span><br></pre></td></tr></table></figure></li></ul><p>public class MyApplication extends Application {</p><p>  @Override public void onCreate() {<br>    super.onCreate();<br>    LeakCanary.install(this);<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 想要检测更多，首先注册一个RefWatcher：</span><br></pre></td></tr></table></figure></p><p>public class MyApplication extends Application {</p><pre><code>private static RefWatcher sRefWatcher;@Overridepublic void onCreate() {    super.onCreate();    sRefWatcher = LeakCanary.install(this);}public static RefWatcher getRefWatcher() {    return sRefWatcher;}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## 然后对某个可能发生泄露的占用大内存的对象进行监测：</span><br></pre></td></tr></table></figure></p><p>MyApplication.getRefWatcher().watch(sLeaky);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 对Fragment、BroadcastReceiver、Service进行监测：</span><br></pre></td></tr></table></figure></p><p>public class MyFragment extends Fragment {<br>    @Override<br>    public void onDestroy() {<br>        super.onDestroy();<br>        MyApplication.getRefWatcher().watch(this);<br>    }<br>}<br><code>`</code></p><p><a href="https://blog.csdn.net/mxm691292118/article/details/51020023" target="_blank" rel="noopener">原文地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安卓官方学习教程&quot;&gt;&lt;a href=&quot;#安卓官方学习教程&quot; class=&quot;headerlink&quot; title=&quot;安卓官方学习教程&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://hukai.me/android-training-course-in-chinese/ba
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java四种引用</title>
    <link href="https://ruanyandong.github.io/2018/10/05/java%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/"/>
    <id>https://ruanyandong.github.io/2018/10/05/java四种引用/</id>
    <published>2018-10-04T23:28:09.000Z</published>
    <updated>2018-10-04T23:31:01.736Z</updated>
    
    <content type="html"><![CDATA[<p>参考文章<a href="https://blog.csdn.net/swebin/article/details/78571933" target="_blank" rel="noopener">java四种引用</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考文章&lt;a href=&quot;https://blog.csdn.net/swebin/article/details/78571933&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;java四种引用&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GC ROOT</title>
    <link href="https://ruanyandong.github.io/2018/10/04/GC-ROOT/"/>
    <id>https://ruanyandong.github.io/2018/10/04/GC-ROOT/</id>
    <published>2018-10-04T10:00:21.000Z</published>
    <updated>2018-10-04T10:02:34.743Z</updated>
    
    <content type="html"><![CDATA[<p>关于GC ROOT,请参考这篇文章====&gt;<a href="https://blog.csdn.net/u010497228/article/details/44106119" target="_blank" rel="noopener">GC ROOT</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于GC ROOT,请参考这篇文章====&amp;gt;&lt;a href=&quot;https://blog.csdn.net/u010497228/article/details/44106119&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GC ROOT&lt;/a&gt;&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>android字体相关知识</title>
    <link href="https://ruanyandong.github.io/2018/10/03/android%E5%AD%97%E4%BD%93%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <id>https://ruanyandong.github.io/2018/10/03/android字体相关知识/</id>
    <published>2018-10-03T07:59:26.000Z</published>
    <updated>2018-10-03T08:16:58.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android字体简介"><a href="#Android字体简介" class="headerlink" title="Android字体简介"></a>Android字体简介</h1><hr><p>Android系统默认支持三种字体，分别为：“sans”,“serif”,“monospace”。</p><p>android.graphic.typeface字体类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">本类的常量静态定义，首先为字体类型（typeface）名称</span><br><span class="line">        TypefaceDEFAULTTypeface </span><br><span class="line">        DEFAULT_BOLDTypeface </span><br><span class="line">MONOSPACETypefaceSANS_SERIF</span><br><span class="line">Typeface SERIF</span><br><span class="line">-------------------------------------------</span><br><span class="line">字体风格（style）名称int </span><br><span class="line">BOLDint </span><br><span class="line">BOLD_ITALICint </span><br><span class="line">ITALICint NORMAL</span><br><span class="line">---------------------------------------------------</span><br><span class="line">设置TextView的字体可以通过TextView中的setTypeface方法来指定一个Typeface对象，</span><br><span class="line">因为Android的字体类比较简单，我们列出所有成员方法:</span><br><span class="line">    </span><br><span class="line">staticTypeface create(Typeface family, int style)//静态方法，参数一为字体类型这里是Typeface的静态定义，如宋体，参数二风格，如粗体，斜体   </span><br><span class="line">staticTypeface create(String familyName, int style)//静态方法，参数一为字体名的字符串，参数二为风格同上，这里我们推荐使用上面的方法。    </span><br><span class="line">staticTypeface createFromAsset(AssetManager mgr, String path)//静态方法，参数一为AssetManager对象，主要用于从APK的assets文件夹中取出字体，参数二为相对于Android工程下 的assets文件夹中的外挂字体文件的路径。    </span><br><span class="line">staticTypeface createFromFile(File path)//静态方法，从文件系统构造一个字体，这里参数可以是sdcard中的某个字体文件    </span><br><span class="line">staticTypeface createFromFile(String path) //静态方法，从指定路径中构造字体    </span><br><span class="line">staticTypeface defaultFromStyle(int style) //静态方法，返回默认的字体风格    </span><br><span class="line">intgetStyle() //获取当前字体风格    </span><br><span class="line">finalboolean isBold() //判断当前是否为粗体    </span><br><span class="line">finalboolean isItalic() //判断当前风格是否为斜体</span><br></pre></td></tr></table></figure><h2 id="Android字体工作原理"><a href="#Android字体工作原理" class="headerlink" title="Android字体工作原理"></a>Android字体工作原理</h2><p>   android字体由android 2D图形引擎skia实现，并在Zygote的Preloading classes中对系统字体进行load。<br>   相关文件有：skTypeface.cpp和skFontHost_android.cpp，其中后者是skia针对android平台字体实现的port。<br>   主要的变量有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct FontInitRec &#123;</span><br><span class="line">       const char*         fFileName;</span><br><span class="line">       const char* const*  fNames;     </span><br><span class="line">// null-terminated list</span><br><span class="line">&#125;;</span><br><span class="line">struct FamilyRec &#123;</span><br><span class="line">       FamilyRec*  fNext;</span><br><span class="line">       SkTypeface* fFaces[5];</span><br><span class="line">&#125;;</span><br><span class="line">uint32_t gFallbackFonts[SK_ARRAY_COUNT(gSystemFonts)+1];</span><br><span class="line">load_system_fonts()@skFontHost_android.cpp load</span><br></pre></td></tr></table></figure></p><hr><p>系统中所有的字体并给每种字体分配唯一的ID，并将字体分为两种：FamilyFonts和FallbackFonts，skPaint通过应用程序设置的字体（Typeface）所对应的ID最终实现字符的显示。<br>替换Android默认的汉字字体在android系统中，DroidSans是默认字体，只包含西方字符，<br>应用程序默认情况下都会调用它，而DroidSansFallback包含了东亚字符，<br>当需要显示的字符在DroidSans字体中不存在（如：汉字）时，即没有对应编码的字符时，<br>系统会到DroidSansFallback中去找相应编码的字符，如果找到，则使用DroidSansFallback字体来显示它，<br>如果仍找不到该编码对应的字符，则无法在屏幕上显示该字符。<br>更换默认中文字体的步骤为：<br>   1、将幼圆字体库youyuan.ttf重命名为DroidSansFallback.ttf,覆盖Android源码中frameworks/base/data/fonts目录下的DroidSansFallback.ttf文件<br>   2、重新编译Android系统3、编译SDK。生成的SDK中，android默认的中文字体已更换为幼圆字体。该方法的不足是删除了Android系统原来的中文字体<br>     为android系统添加一种默认字体在android系统中，默认的中文字体只有一种：DroidSansFallback.ttf，<br>     如果想在android应用程序中随意设置想要的中文字体，除了在应用程序中通过assets目录引入字体文件外，还可以通过增加android默认字体的方式来实现。<br>     添加步骤大致如下：<br>     1、在frameworks/base/data/fonts目录下添加字体文件，例如Driod-kaishu.ttf;<br>     2、在skia中增加楷书这一字体，需要修改的文件主要有skFontHost.cpp、skTypeface.cpp、Typeface.java等;<br>     3、在java层添加楷书字体相关API，需要修改的文件主要有typeface.java和textview.java;</p><pre><code>4、编译SDK5、将新生成的sdk导入eclipse，在eclipse中即可通过setTypeface(Typeface.KAISHU)和android:typeface=(“kaishu”)两种方式设置自己添加的字体</code></pre><hr><h1 id="以及一些相关链接，可以参考："><a href="#以及一些相关链接，可以参考：" class="headerlink" title="以及一些相关链接，可以参考："></a>以及一些相关链接，可以参考：</h1><p><a href="https://blog.csdn.net/ludandan1234/article/details/53330944" target="_blank" rel="noopener">修改android app 字体格式</a><br><a href="https://blog.csdn.net/shiyangkai/article/details/70257004" target="_blank" rel="noopener">Android TextView 自定义字体设置</a><br><a href="https://blog.csdn.net/sinat_34754865/article/details/53389923" target="_blank" rel="noopener">Android ttf字体的使用</a><br><a href="https://blog.csdn.net/JavaAndroid730/article/details/53122953" target="_blank" rel="noopener">Android中快速实现自定义字体！</a><br><a href="https://blog.csdn.net/wonderful19891024/article/details/6033304" target="_blank" rel="noopener">Android中字体的处理</a><br><a href="https://blog.csdn.net/songjinshi/article/details/46633341" target="_blank" rel="noopener">Android字体Font相关知识</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android字体简介&quot;&gt;&lt;a href=&quot;#Android字体简介&quot; class=&quot;headerlink&quot; title=&quot;Android字体简介&quot;&gt;&lt;/a&gt;Android字体简介&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;Android系统默认支持三种字体，分别为：“sans”,
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android动态改变图片颜色</title>
    <link href="https://ruanyandong.github.io/2018/10/03/Android%E5%8A%A8%E6%80%81%E6%94%B9%E5%8F%98%E5%9B%BE%E7%89%87%E9%A2%9C%E8%89%B2/"/>
    <id>https://ruanyandong.github.io/2018/10/03/Android动态改变图片颜色/</id>
    <published>2018-10-03T06:52:08.000Z</published>
    <updated>2018-10-03T07:27:03.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="方法一、通过属性动画来改变图片的颜色"><a href="#方法一、通过属性动画来改变图片的颜色" class="headerlink" title="方法一、通过属性动画来改变图片的颜色"></a>方法一、通过属性动画来改变图片的颜色</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">                    ObjectAnimator objectAnimatorTran = ObjectAnimator.ofArgb(mSplashImage, &quot;ColorFilter&quot;, getResources().getColor(R.color.colorWhite), getResources().getColor(R.color.colorAccent));</span><br><span class="line">                    objectAnimatorTran.setDuration(5000);</span><br><span class="line">                    //objectAnimatorTran.setRepeatCount(-1);</span><br><span class="line">                    objectAnimatorTran.start();</span><br><span class="line">                </span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"># 方法二</span><br><span class="line">## 关键点</span><br><span class="line">获取目标图标的所有像素点</span><br><span class="line">验证像素点的alpha值，是否透明</span><br><span class="line">在不透明的像素点上修改为我们想要的颜色</span><br><span class="line">根据输入的颜色值改变图标颜色</span><br></pre></td></tr></table></figure><p>final EditText et = findViewById(R.id.et);<br>final ImageView iv = findViewById(R.id.iv);<br>iv.setOnClickListener(new View.OnClickListener() {<br>    @Override<br>    public void onClick(View view) {<br>        //获取ImageView上的图片<br>        iv.setDrawingCacheEnabled(true);<br>        Bitmap bitmap = iv.getDrawingCache();</p><pre><code>    //按照输入的颜色转换图标    String s = et.getText().toString();    Bitmap newBitmap = changeBitmapColor(bitmap,s);    iv.setDrawingCacheEnabled(false);    iv.setImageBitmap(newBitmap);}</code></pre><p>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## 实现方法：</span><br></pre></td></tr></table></figure></p><p>public Bitmap changeBitmapColor(Bitmap sourceBitmap,String aimColorStr){<br>    //验证参数合理<br>    if(sourceBitmap == null || sourceBitmap.isRecycled()){<br>        throw new RuntimeException(“source exception!!!”);<br>    }<br>    int aimColor;<br>    try {<br>        aimColor = Color.parseColor(aimColorStr.trim());<br>    } catch (Exception e){<br>        throw new RuntimeException(“aimColorStr error!!!”);<br>    }<br>    //按照图标的大小创建数组<br>    int mBitmapWidth = sourceBitmap.getWidth();<br>    int mBitmapHeight = sourceBitmap.getHeight();<br>    int mArrayColorLengh = mBitmapWidth * mBitmapHeight;<br>    int[] mArrayColor = new int[mArrayColorLengh];</p><pre><code>//循环bitmap 的每个像素点，查看alpha值int count = 0;for (int i = 0; i &lt; mBitmapHeight; i++) {    for (int j = 0; j &lt; mBitmapWidth; j++) {        //获得Bitmap 图片中每一个点的color颜色值        int color = sourceBitmap.getPixel(j, i);        int a = Color.alpha(color);        if(a != 0){//不等于0 即不透明部分，设置成我们想要的颜色            mArrayColor[count] = aimColor;        } else {//透明仍然为透明            int aimColor2 = Color.parseColor(&quot;#00000000&quot;);            mArrayColor[count] = aimColor2;        }        count++;    }}//根据数组创建新的BitmapBitmap newBitmap = Bitmap.createBitmap(mBitmapWidth,mBitmapHeight, Bitmap.Config.ARGB_8888);newBitmap.setPixels(mArrayColor,0,mBitmapWidth,0,0,mBitmapWidth,mBitmapHeight);return newBitmap;</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 方法三</span><br></pre></td></tr></table></figure><pre><code>//提取图像Alpha位图          public static Bitmap getAlphaBitmap(Bitmap mBitmap,int mColor) {  //          BitmapDrawable mBitmapDrawable = (BitmapDrawable) mContext.getResources().getDrawable(R.drawable.enemy_infantry_ninja);  //          Bitmap mBitmap = mBitmapDrawable.getBitmap();              //BitmapDrawable的getIntrinsicWidth（）方法，Bitmap的getWidth（）方法              //注意这两个方法的区别              //Bitmap mAlphaBitmap = Bitmap.createBitmap(mBitmapDrawable.getIntrinsicWidth(), mBitmapDrawable.getIntrinsicHeight(), Config.ARGB_8888);              Bitmap mAlphaBitmap = Bitmap.createBitmap(mBitmap.getWidth(), mBitmap.getHeight(), Config.ARGB_8888);              Canvas mCanvas = new Canvas(mAlphaBitmap);              Paint mPaint = new Paint();              mPaint.setColor(mColor);              //从原位图中提取只包含alpha的位图              Bitmap alphaBitmap = mBitmap.extractAlpha();              //在画布上（mAlphaBitmap）绘制alpha位图              mCanvas.drawBitmap(alphaBitmap, 0, 0, mPaint);              return mAlphaBitmap;          }  </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 实现</span><br></pre></td></tr></table></figure><p>   ImageView deviceIV.setDrawingCacheEnabled(true);<br>   Bitmap deviceBmp = deviceIV.getDrawingCache();<br>   int color = Color.parseColor(“#00000000”);<br>   Bitmap bitmap = getAlphaBitmap(deviceBmp,color);<br>   deviceIV.setImageBitmap(bitmap);<br>   时常会出现null，原因是超出系统提供最大的DrawingCache值，所以要在此代码前添加如下代码：<br>   deviceIV.measure(MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED), MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED));<br>   deviceIV.layout(0, 0, deviceIV.getMeasuredWidth(), deviceIV.getMeasuredHeight());</p><p><code>`</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;方法一、通过属性动画来改变图片的颜色&quot;&gt;&lt;a href=&quot;#方法一、通过属性动画来改变图片的颜色&quot; class=&quot;headerlink&quot; title=&quot;方法一、通过属性动画来改变图片的颜色&quot;&gt;&lt;/a&gt;方法一、通过属性动画来改变图片的颜色&lt;/h1&gt;&lt;figure c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>吃苹果递归问题</title>
    <link href="https://ruanyandong.github.io/2018/10/02/%E5%90%83%E8%8B%B9%E6%9E%9C%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98/"/>
    <id>https://ruanyandong.github.io/2018/10/02/吃苹果递归问题/</id>
    <published>2018-10-01T21:00:12.000Z</published>
    <updated>2018-10-01T21:15:01.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述:"></a>问题描述:</h1><p>  n个苹果，一天吃一个或者一天吃两个，共有几种吃法？<br>  请用递归的方式写出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 例如：3个苹果，则吃法有</span><br><span class="line">       2,1</span><br><span class="line"> 1,1,1</span><br><span class="line">       1,2</span><br><span class="line">共三种</span><br></pre></td></tr></table></figure></p><h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> int i = 0;</span><br><span class="line"> f(n)&#123;</span><br><span class="line">      if(n-1 &gt;= 0)&#123;</span><br><span class="line">   if(n-1 == 0)&#123;</span><br><span class="line">      i++；</span><br><span class="line">   &#125;</span><br><span class="line">   f(n-1);</span><br><span class="line">&#125;</span><br><span class="line">if(n-2 &gt;= 0)&#123;</span><br><span class="line">   if(n-2 == 0)&#123;</span><br><span class="line">      i++；</span><br><span class="line">   &#125;</span><br><span class="line">   f(n-2);</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述:&quot;&gt;&lt;/a&gt;问题描述:&lt;/h1&gt;&lt;p&gt;  n个苹果，一天吃一个或者一天吃两个，共有几种吃法？&lt;br&gt;  请用递归的方式写出&lt;br&gt;&lt;figure class=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在xml文件中定义drawable数组、id数组等</title>
    <link href="https://ruanyandong.github.io/2018/09/23/%E5%9C%A8xml%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89drawable%E6%95%B0%E7%BB%84%E3%80%81id%E6%95%B0%E7%BB%84%E7%AD%89/"/>
    <id>https://ruanyandong.github.io/2018/09/23/在xml文件中定义drawable数组、id数组等/</id>
    <published>2018-09-23T00:25:04.000Z</published>
    <updated>2018-09-23T00:27:53.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在xml文件中定义drawable数组、id数组"><a href="#在xml文件中定义drawable数组、id数组" class="headerlink" title="在xml文件中定义drawable数组、id数组"></a>在xml文件中定义drawable数组、id数组</h1><h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 要这样定义 --&gt;</span><br><span class="line">    &lt;string-array name=&quot;items_id&quot;&gt;</span><br><span class="line">        &lt;item&gt;@drawable/qwe&lt;/item&gt;</span><br><span class="line">        &lt;item&gt;@drawable/qwe1&lt;/item&gt;</span><br><span class="line">    &lt;/string-array&gt;</span><br></pre></td></tr></table></figure><h2 id="2、获取"><a href="#2、获取" class="headerlink" title="2、获取"></a>2、获取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 代码中获取,其他资源也是一样的方法                                    </span><br><span class="line">TypedArray ar = context.getResources().obtainTypedArray(</span><br><span class="line">R.array.items_id);                              </span><br><span class="line">int len = ar.length();                                  </span><br><span class="line">int[] resIds = new int[len];                            </span><br><span class="line">for (int i = 0; i &lt; len; i++)&#123;                          </span><br><span class="line">resIds[i] = ar.getResourceId(i, 0);                 </span><br><span class="line">&#125;                                                       </span><br><span class="line">ar.recycle();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;在xml文件中定义drawable数组、id数组&quot;&gt;&lt;a href=&quot;#在xml文件中定义drawable数组、id数组&quot; class=&quot;headerlink&quot; title=&quot;在xml文件中定义drawable数组、id数组&quot;&gt;&lt;/a&gt;在xml文件中定义drawa
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ubuntu安装网易云全套教程</title>
    <link href="https://ruanyandong.github.io/2018/09/18/ubuntu%E5%AE%89%E8%A3%85%E7%BD%91%E6%98%93%E4%BA%91%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/"/>
    <id>https://ruanyandong.github.io/2018/09/18/ubuntu安装网易云全套教程/</id>
    <published>2018-09-17T22:14:39.000Z</published>
    <updated>2018-09-17T20:10:17.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ubuntu18-04安装网易云音乐以及实现双击打开网易云音乐教程"><a href="#ubuntu18-04安装网易云音乐以及实现双击打开网易云音乐教程" class="headerlink" title="ubuntu18.04安装网易云音乐以及实现双击打开网易云音乐教程"></a>ubuntu18.04安装网易云音乐以及实现双击打开网易云音乐教程</h1><h2 id="1：先去官网下载最新版本的ubuntu-网易云音乐"><a href="#1：先去官网下载最新版本的ubuntu-网易云音乐" class="headerlink" title="1：先去官网下载最新版本的ubuntu 网易云音乐"></a>1：先去官网下载最新版本的ubuntu <a href="http://music.163.com/#/download" target="_blank" rel="noopener">网易云音乐</a></h2><p>   我这里下载的是netease-cloud-music_1.1.0_amd64_ubuntu.deb</p><h2 id="2：执行命令安装："><a href="#2：执行命令安装：" class="headerlink" title="2：执行命令安装："></a>2：执行命令安装：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i netease-cloud-music_1.1.0_amd64_ubuntu.deb</span><br></pre></td></tr></table></figure><h2 id="3：会出现依赖问题，执行以下命令"><a href="#3：会出现依赖问题，执行以下命令" class="headerlink" title="3：会出现依赖问题，执行以下命令"></a>3：会出现依赖问题，执行以下命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get -f install</span><br></pre></td></tr></table></figure><h2 id="4：到这里安装完毕"><a href="#4：到这里安装完毕" class="headerlink" title="4：到这里安装完毕"></a>4：到这里安装完毕</h2><pre><code>但是双击图标无法打开，原因是权限不足，只能在命令行下打开，而且关闭命令行，网易云音乐也关闭</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netease-cloud-music</span><br></pre></td></tr></table></figure><h2 id="5：实现双击图标打开网易云音乐"><a href="#5：实现双击图标打开网易云音乐" class="headerlink" title="5：实现双击图标打开网易云音乐"></a>5：实现双击图标打开网易云音乐</h2><h3 id="1、将当前用户加入-sudoer"><a href="#1、将当前用户加入-sudoer" class="headerlink" title="1、将当前用户加入 sudoer"></a>1、将当前用户加入 sudoer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo visudo -f /etc/sudoers.d/username</span><br></pre></td></tr></table></figure><h3 id="2、并输入："><a href="#2、并输入：" class="headerlink" title="2、并输入："></a>2、并输入：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username ALL=(ALL:ALL) NOPASSWD:ALL</span><br></pre></td></tr></table></figure><p>如果不习惯使用nano编辑器可以 更换为vim</p><h3 id="3、编辑启动文件："><a href="#3、编辑启动文件：" class="headerlink" title="3、编辑启动文件："></a>3、编辑启动文件：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /usr/share/applications/netease-cloud-music.desktop</span><br></pre></td></tr></table></figure><h3 id="4、在第11行前加上-sudo"><a href="#4、在第11行前加上-sudo" class="headerlink" title="4、在第11行前加上 sudo"></a>4、在第11行前加上 sudo</h3><pre><code>Exec=sudo netease-cloud-music %U</code></pre><h3 id="5、大功告成！点击图标即可启动！"><a href="#5、大功告成！点击图标即可启动！" class="headerlink" title="5、大功告成！点击图标即可启动！"></a>5、大功告成！点击图标即可启动！</h3><h2 id="系统版本：Ubuntu-18-04-1"><a href="#系统版本：Ubuntu-18-04-1" class="headerlink" title="系统版本：Ubuntu 18.04.1"></a>系统版本：Ubuntu 18.04.1</h2><h2 id="软件版本：netease-cloud-music-1-1-0"><a href="#软件版本：netease-cloud-music-1-1-0" class="headerlink" title="软件版本：netease-cloud-music 1.1.0"></a>软件版本：netease-cloud-music 1.1.0</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ubuntu18-04安装网易云音乐以及实现双击打开网易云音乐教程&quot;&gt;&lt;a href=&quot;#ubuntu18-04安装网易云音乐以及实现双击打开网易云音乐教程&quot; class=&quot;headerlink&quot; title=&quot;ubuntu18.04安装网易云音乐以及实现双击打开
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ubuntu界面美化教程</title>
    <link href="https://ruanyandong.github.io/2018/09/18/ubuntu%E7%95%8C%E9%9D%A2%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B/"/>
    <id>https://ruanyandong.github.io/2018/09/18/ubuntu界面美化教程/</id>
    <published>2018-09-17T22:14:07.000Z</published>
    <updated>2018-09-17T22:27:07.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ubuntu18-04界面美化教程，美化成McOS"><a href="#ubuntu18-04界面美化教程，美化成McOS" class="headerlink" title="ubuntu18.04界面美化教程，美化成McOS"></a>ubuntu18.04界面美化教程，美化成McOS</h1><p>  请看这篇教程<a href="https://www.cnblogs.com/lishanlei/p/9090404.html" target="_blank" rel="noopener">ubuntu18.04美化McOS</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ubuntu18-04界面美化教程，美化成McOS&quot;&gt;&lt;a href=&quot;#ubuntu18-04界面美化教程，美化成McOS&quot; class=&quot;headerlink&quot; title=&quot;ubuntu18.04界面美化教程，美化成McOS&quot;&gt;&lt;/a&gt;ubuntu18.04
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Http的get和post的区别</title>
    <link href="https://ruanyandong.github.io/2018/09/12/Http%E7%9A%84get%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://ruanyandong.github.io/2018/09/12/Http的get和post的区别/</id>
    <published>2018-09-12T09:34:24.000Z</published>
    <updated>2018-09-12T10:41:08.902Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-方法：GET-对比-POST"><a href="#HTTP-方法：GET-对比-POST" class="headerlink" title="HTTP 方法：GET 对比 POST"></a>HTTP 方法：GET 对比 POST</h1><h2 id="两种最常用的-HTTP-方法是：GET-和-POST。"><a href="#两种最常用的-HTTP-方法是：GET-和-POST。" class="headerlink" title="两种最常用的 HTTP 方法是：GET 和 POST。"></a>两种最常用的 HTTP 方法是：GET 和 POST。</h2><p> 什么是 HTTP？</p><p>超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。</p><p>HTTP 的工作方式是客户机与服务器之间的请求-应答协议。</p><p>web 浏览器可能是客户端，而计算机上的网络应用程序也可能作为服务器端。</p><p>举例：客户端（浏览器）向服务器提交 HTTP 请求；服务器向客户端返回响应。响应包含关于请求的状态信息以及可能被请求的内容。</p><h2 id="两种-HTTP-请求方法：GET-和-POST"><a href="#两种-HTTP-请求方法：GET-和-POST" class="headerlink" title="两种 HTTP 请求方法：GET 和 POST"></a>两种 HTTP 请求方法：GET 和 POST</h2><p>在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 POST。</p><pre><code>GET - 从指定的资源请求数据。POST - 向指定的资源提交要被处理的数据</code></pre><h3 id="GET-方法"><a href="#GET-方法" class="headerlink" title="GET 方法"></a>GET 方法</h3><p>请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：</p><p>/test/demo_form.asp?name1=value1&amp;name2=value2</p><p>有关 GET 请求的其他一些注释：</p><pre><code>GET 请求可被缓存GET 请求保留在浏览器历史记录中GET 请求可被收藏为书签GET 请求不应在处理敏感数据时使用GET 请求有长度限制GET 请求只应当用于取回数据</code></pre><h3 id="POST-方法"><a href="#POST-方法" class="headerlink" title="POST 方法"></a>POST 方法</h3><p>请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：</p><p>POST /test/demo_form.asp HTTP/1.1<br>Host: w3schools.com<br>name1=value1&amp;name2=value2</p><p>有关 POST 请求的其他一些注释：</p><pre><code>POST 请求不会被缓存POST 请求不会保留在浏览器历史记录中POST 不能被收藏为书签POST 请求对数据长度没有要求</code></pre><p>比较 GET 与 POST</p><p>下面的表格比较了两种 HTTP 方法：GET 和 POST。<br>                          GET==============================POST</p><h3 id="后退按钮-刷新"><a href="#后退按钮-刷新" class="headerlink" title="后退按钮/刷新"></a>后退按钮/刷新</h3><pre><code>GET:无害==========POST:数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</code></pre><h3 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h3><pre><code>GET:可收藏为书签==========POST:不可收藏为书签</code></pre><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><pre><code>GET:能被缓存==========POST:不能缓存</code></pre><h3 id="编码类型"><a href="#编码类型" class="headerlink" title="编码类型"></a>编码类型</h3><pre><code>GET:application/x-www-form-urlencoded==========POST:application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</code></pre><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><pre><code>GET:参数保留在浏览器历史中。==========POST:参数不会保存在浏览器历史中。</code></pre><h3 id="对数据长度的限制"><a href="#对数据长度的限制" class="headerlink" title="对数据长度的限制"></a>对数据长度的限制</h3><pre><code>GET:是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。==========POST:无限制。</code></pre><h3 id="对数据类型的限制"><a href="#对数据类型的限制" class="headerlink" title="对数据类型的限制"></a>对数据类型的限制</h3><pre><code>GET:只允许 ASCII 字符。==========POST:没有限制。也允许二进制数据。</code></pre><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><pre><code>GET:与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！==========POST: POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</code></pre><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><pre><code>GET:数据在 URL 中对所有人都是可见的。==========POST:数据不会显示在 URL 中。</code></pre><h2 id="下面的表格列出了其他一些-HTTP-请求方法："><a href="#下面的表格列出了其他一些-HTTP-请求方法：" class="headerlink" title="下面的表格列出了其他一些 HTTP 请求方法："></a>下面的表格列出了其他一些 HTTP 请求方法：</h2><p>方法     描述<br>HEAD     与 GET 相同，但只返回 HTTP 报头，不返回文档主体。<br>PUT     上传指定的 URI 表示。<br>DELETE     删除指定资源。<br>OPTIONS     返回服务器支持的 HTTP 方法。<br>CONNECT     把请求连接转换到透明的 TCP/IP 通道。</p><h1 id="当浏览器从-web-服务器请求服务时，可能会发生错误。从而有可能会返回下面的一系列状态消息："><a href="#当浏览器从-web-服务器请求服务时，可能会发生错误。从而有可能会返回下面的一系列状态消息：" class="headerlink" title="当浏览器从 web 服务器请求服务时，可能会发生错误。从而有可能会返回下面的一系列状态消息："></a>当浏览器从 web 服务器请求服务时，可能会发生错误。从而有可能会返回下面的一系列状态消息：</h1><h2 id="1xx-信息"><a href="#1xx-信息" class="headerlink" title="1xx: 信息"></a>1xx: 信息</h2><p>消息:     描述:<br>100 Continue     服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。<br>101 Switching Protocols     服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。</p><h2 id="2xx-成功"><a href="#2xx-成功" class="headerlink" title="2xx: 成功"></a>2xx: 成功</h2><p>消息:     描述:<br>200 OK     请求成功（其后是对GET和POST请求的应答文档。）<br>201 Created     请求被创建完成，同时新的资源被创建。<br>202 Accepted     供处理的请求已被接受，但是处理未完成。<br>203 Non-authoritative Information     文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。<br>204 No Content     没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。<br>205 Reset Content     没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。<br>206 Partial Content     客户发送了一个带有Range头的GET请求，服务器完成了它。</p><h2 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx: 重定向"></a>3xx: 重定向</h2><p>消息:     描述:<br>300 Multiple Choices     多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。<br>301 Moved Permanently     所请求的页面已经转移至新的url。<br>302 Found     所请求的页面已经临时转移至新的url。<br>303 See Other     所请求的页面可在别的url下被找到。<br>304 Not Modified     未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。<br>305 Use Proxy     客户请求的文档应该通过Location头所指明的代理服务器提取。<br>306 Unused     此代码被用于前一版本。目前已不再使用，但是代码依然被保留。<br>307 Temporary Redirect     被请求的页面已经临时移至新的url。</p><h2 id="4xx-客户端错误"><a href="#4xx-客户端错误" class="headerlink" title="4xx: 客户端错误"></a>4xx: 客户端错误</h2><p>消息:     描述:<br>400 Bad Request     服务器未能理解请求。<br>401 Unauthorized     被请求的页面需要用户名和密码。<br>402 Payment Required     此代码尚无法使用。<br>403 Forbidden     对被请求页面的访问被禁止。<br>404 Not Found     服务器无法找到被请求的页面。<br>405 Method Not Allowed     请求中指定的方法不被允许。<br>406 Not Acceptable     服务器生成的响应无法被客户端所接受。<br>407 Proxy Authentication Required     用户必须首先使用代理服务器进行验证，这样请求才会被处理。<br>408 Request Timeout     请求超出了服务器的等待时间。<br>409 Conflict     由于冲突，请求无法被完成。<br>410 Gone     被请求的页面不可用。<br>411 Length Required     “Content-Length” 未被定义。如果无此内容，服务器不会接受请求。<br>412 Precondition Failed     请求中的前提条件被服务器评估为失败。<br>413 Request Entity Too Large     由于所请求的实体的太大，服务器不会接受请求。<br>414 Request-url Too Long     由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。<br>415 Unsupported Media Type     由于媒介类型不被支持，服务器不会接受请求。<br>416      服务器不能满足客户在请求中指定的Range头。<br>417 Expectation Failed      </p><h2 id="5xx-服务器错误"><a href="#5xx-服务器错误" class="headerlink" title="5xx: 服务器错误"></a>5xx: 服务器错误</h2><p>消息:     描述:<br>500 Internal Server Error     请求未完成。服务器遇到不可预知的情况。<br>501 Not Implemented     请求未完成。服务器不支持所请求的功能。<br>502 Bad Gateway     请求未完成。服务器从上游服务器收到一个无效的响应。<br>503 Service Unavailable     请求未完成。服务器临时过载或当机。<br>504 Gateway Timeout     网关超时。<br>505 HTTP Version Not Supported     服务器不支持请求中指明的HTTP协议版本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTTP-方法：GET-对比-POST&quot;&gt;&lt;a href=&quot;#HTTP-方法：GET-对比-POST&quot; class=&quot;headerlink&quot; title=&quot;HTTP 方法：GET 对比 POST&quot;&gt;&lt;/a&gt;HTTP 方法：GET 对比 POST&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Http与Https的区别</title>
    <link href="https://ruanyandong.github.io/2018/09/12/Http%E4%B8%8EHttps%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://ruanyandong.github.io/2018/09/12/Http与Https的区别/</id>
    <published>2018-09-12T09:30:41.000Z</published>
    <updated>2018-09-12T10:14:26.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Http与Https的区别"><a href="#Http与Https的区别" class="headerlink" title="Http与Https的区别"></a>Http与Https的区别</h1><pre><code>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</code></pre><p>　　为了解决HTTP协议的这一缺陷，需要使用另一种协议：<br>   安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，<br>   SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><h2 id="一、HTTP和HTTPS的基本概念"><a href="#一、HTTP和HTTPS的基本概念" class="headerlink" title="一、HTTP和HTTPS的基本概念"></a>一、HTTP和HTTPS的基本概念</h2><p>　　HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><p>　　HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p>　　HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><h2 id="二、HTTP与HTTPS有什么区别？"><a href="#二、HTTP与HTTPS有什么区别？" class="headerlink" title="二、HTTP与HTTPS有什么区别？"></a>二、HTTP与HTTPS有什么区别？</h2><p>　　HTTP协议传输的数据都是未加密的，也就是明文的，<br>因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，<br>于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。<br>简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p><p>　　HTTPS和HTTP的区别主要如下：</p><p>　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p><p>　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p><p>　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><h2 id="三、HTTPS的工作原理"><a href="#三、HTTPS的工作原理" class="headerlink" title="三、HTTPS的工作原理"></a>三、HTTPS的工作原理</h2><p>　　我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。</p><p>　客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。</p><p>　　（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</p><p>　　（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</p><p>　　（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</p><p>　　（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</p><p>　　（5）Web服务器利用自己的私钥解密出会话密钥。</p><p>　　（6）Web服务器利用会话密钥加密与客户端之间的通信。</p><h2 id="四、HTTPS的优点"><a href="#四、HTTPS的优点" class="headerlink" title="四、HTTPS的优点"></a>四、HTTPS的优点</h2><p>　　尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：</p><p>　　（1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p><p>　　（2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p><p>　　（3）HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p><p>　　（4）谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</p><h2 id="五、HTTPS的缺点"><a href="#五、HTTPS的缺点" class="headerlink" title="五、HTTPS的缺点"></a>五、HTTPS的缺点</h2><p>　　虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：</p><p>　　（1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；</p><p>　　（2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</p><p>　　（3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p><p>　   （4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</p><p>　　（5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p><h2 id="六、http切换到HTTPS"><a href="#六、http切换到HTTPS" class="headerlink" title="六、http切换到HTTPS"></a>六、http切换到HTTPS</h2><p>　　如果需要将网站从http切换到https到底该如何实现呢？</p><pre><code>这里需要将页面中所有的链接，例如js，css，图片等等链接都由http改为https。例如：http://www.baidu.com改为https://www.baidu.com</code></pre><p>　　BTW，这里虽然将http切换为了https，还是建议保留http。<br>所以我们在切换的时候可以做http和https的兼容，<br>具体实现方式是，去掉页面链接中的http头部，这样可以自动匹配http头和https头。<br>例如：将<a href="http://www.baidu.com改为//www.baidu.com。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的。" target="_blank" rel="noopener">http://www.baidu.com改为//www.baidu.com。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的。</a></p><h2 id="七、SSL的作用"><a href="#七、SSL的作用" class="headerlink" title="七、SSL的作用"></a>七、SSL的作用</h2><p>（1）、认证用户和服务器，确保数据发送到正确的客户机和服务器；</p><p>（2）、加密数据以防止数据中途被窃取；</p><p>（3）、维护数据的完整性，确保数据在传输过程中不被改变。</p><p>而SSL证书指的是在SSL通信中验证通信双方身份的数字文件，<br>一般分为服务器证书和客户端证书，我们通常说的SSL证书主要指服务器证书，<br>SSL证书由受信任的数字证书颁发机构CA（如VeriSign，GlobalSign，WoSign等），<br>在验证服务器身份后颁发，具有服务器身份验证和数据传输加密功能，<br>分为扩展验证型(EV)SSL证书、组织验证型(OV)SSL证书、和域名验证型（DV）SSL证书。</p><h2 id="八、SSL证书申请的3个主要步骤"><a href="#八、SSL证书申请的3个主要步骤" class="headerlink" title="八、SSL证书申请的3个主要步骤"></a>八、SSL证书申请的3个主要步骤</h2><p>对于SSL证书的申请，主要有以下3个步骤：</p><h3 id="（1）、制作CSR文件"><a href="#（1）、制作CSR文件" class="headerlink" title="（1）、制作CSR文件"></a>（1）、制作CSR文件</h3><p>所谓CSR就是由申请人制作的Certificate Secure Request证书请求文件，制作过程中，系统会产生2个密钥，一个是公钥就是这个CSR文件；另外一个是私钥，存放在服务器上。</p><p>要制作CSR文件，申请人可以参考WEB SERVER的文档，一般APACHE等，使用OPENSSL命令行来生成KEY+CSR2个文件，Tomcat，JBoss，Resin等使用KEYTOOL来生成JKS和CSR文件，IIS通过向导建立一个挂起的请求和一个CSR文件。</p><h3 id="（2）、CA认证"><a href="#（2）、CA认证" class="headerlink" title="（2）、CA认证"></a>（2）、CA认证</h3><p>将CSR提交给CA，CA一般有2种认证方式：</p><p>①、域名认证：一般通过对管理员邮箱认证的方式，这种方式认证速度快，但是签发的证书中没有企业的名称。</p><p>②、企业文档认证：需要提供企业的营业执照，一般需要3-5个工作日。</p><p>也有需要同时认证以上2种方式的证书，叫EV证书，这种证书可以使IE7以上的浏览器地址栏变成绿色，所以认证也最严格。</p><h3 id="（3）、证书的安装"><a href="#（3）、证书的安装" class="headerlink" title="（3）、证书的安装"></a>（3）、证书的安装</h3><p>在收到CA的证书后，可以将证书部署上服务器，一般APACHE文件直接将KEY+CER复制到文件上，然后修改HTTPD.CONF文件；TOMCAT等，需要将CA签发的证书CER文件导入JKS文件后，复制上服务器，然后修改SERVER.XML；IIS需要处理挂起的请求，将CER文件导入。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Http与Https的区别&quot;&gt;&lt;a href=&quot;#Http与Https的区别&quot; class=&quot;headerlink&quot; title=&quot;Http与Https的区别&quot;&gt;&lt;/a&gt;Http与Https的区别&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;超文本传输协议HTTP协议被用于在W
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://ruanyandong.github.io/2018/08/04/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://ruanyandong.github.io/2018/08/04/单例模式/</id>
    <published>2018-08-04T03:12:06.000Z</published>
    <updated>2018-08-04T18:23:11.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、饿汉单例模式（线程安全）"><a href="#1、饿汉单例模式（线程安全）" class="headerlink" title="1、饿汉单例模式（线程安全）"></a>1、饿汉单例模式（线程安全）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  public class object&#123;</span><br><span class="line"></span><br><span class="line">      private static final object obj = new object();</span><br><span class="line">      </span><br><span class="line">public object()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static object getInstance()&#123;</span><br><span class="line"></span><br><span class="line">         return obj;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="2、懒汉式单例（线程不安全-除非加上同步关键字）"><a href="#2、懒汉式单例（线程不安全-除非加上同步关键字）" class="headerlink" title="2、懒汉式单例（线程不安全,除非加上同步关键字）"></a>2、懒汉式单例（线程不安全,除非加上同步关键字）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   public class Singleton&#123;</span><br><span class="line"></span><br><span class="line">      private static Singleton instance ;</span><br><span class="line">  </span><br><span class="line">  private Singleton()&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static synchronized Singleton getInstance()&#123;</span><br><span class="line">  </span><br><span class="line">         if(instance == null)&#123;</span><br><span class="line"> </span><br><span class="line">      instance = new Singleton();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、Double-Check-Lock-DCL-实现单例"><a href="#3、Double-Check-Lock-DCL-实现单例" class="headerlink" title="3、Double Check Lock(DCL)实现单例"></a>3、Double Check Lock(DCL)实现单例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> public class Singleton&#123;</span><br><span class="line"> </span><br><span class="line">      private static Singleton instance = null;</span><br><span class="line"></span><br><span class="line">private Singleton()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Singleton getInstance()&#123;</span><br><span class="line"></span><br><span class="line">       if(instance == null)&#123;</span><br><span class="line">   </span><br><span class="line">       synchronized(Singleton.class)&#123;</span><br><span class="line">   </span><br><span class="line">             if(instance == null)&#123;</span><br><span class="line"> </span><br><span class="line">      instance = new Singleton();</span><br><span class="line">  </span><br><span class="line"> &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   return instance;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="4、静态内部类单例模式"><a href="#4、静态内部类单例模式" class="headerlink" title="4、静态内部类单例模式"></a>4、静态内部类单例模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   public class Singleton&#123;</span><br><span class="line">      </span><br><span class="line">  private Singleton()&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private static  class SingletonHolder&#123;</span><br><span class="line">  </span><br><span class="line">        private static final Singleton instance = new Singleton();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static Singleton getInstance()&#123;</span><br><span class="line">  </span><br><span class="line">       return SingletonHolder.instance;</span><br><span class="line">  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、枚举单例"><a href="#5、枚举单例" class="headerlink" title="5、枚举单例"></a>5、枚举单例</h2><pre><code>public enum SingletonEnum{       INSTANCE;       public void doSomething(){       }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、饿汉单例模式（线程安全）&quot;&gt;&lt;a href=&quot;#1、饿汉单例模式（线程安全）&quot; class=&quot;headerlink&quot; title=&quot;1、饿汉单例模式（线程安全）&quot;&gt;&lt;/a&gt;1、饿汉单例模式（线程安全）&lt;/h2&gt;&lt;figure class=&quot;highlight 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面向对象的六大原则</title>
    <link href="https://ruanyandong.github.io/2018/08/04/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>https://ruanyandong.github.io/2018/08/04/面向对象的六大原则/</id>
    <published>2018-08-04T02:02:19.000Z</published>
    <updated>2018-08-04T02:26:54.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、单一职责"><a href="#1、单一职责" class="headerlink" title="1、单一职责"></a>1、单一职责</h2><pre><code>就一个类而言，应该仅有一个引起它变化的原因，一个类中，应该是一组相关性很高的函数、数据的封装。</code></pre><h2 id="2、开闭原则"><a href="#2、开闭原则" class="headerlink" title="2、开闭原则"></a>2、开闭原则</h2><pre><code>软件中的对象（类，模块、函数等）应该对于扩展是开放的，对于修改是封闭的。</code></pre><h2 id="3、里氏替换原则"><a href="#3、里氏替换原则" class="headerlink" title="3、里氏替换原则"></a>3、里氏替换原则</h2><pre><code>父类出现的地方，子类就可以出现，并且不会产生错误，但是子类可以出现的地方父类未必可以出现。</code></pre><h2 id="4、依赖倒置原则"><a href="#4、依赖倒置原则" class="headerlink" title="4、依赖倒置原则"></a>4、依赖倒置原则</h2><pre><code>也叫控制反转、依赖注入，模块之间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，依赖关系通过接口或者抽象类产生。</code></pre><h2 id="5、接口隔离原则"><a href="#5、接口隔离原则" class="headerlink" title="5、接口隔离原则"></a>5、接口隔离原则</h2><pre><code>系统揭开耦合，从而容易更改、重构和部署。</code></pre><h2 id="6、迪米特原则"><a href="#6、迪米特原则" class="headerlink" title="6、迪米特原则"></a>6、迪米特原则</h2><pre><code>一个类应该对于自己需要耦合的或者调用的类知道最少，类的内部如何实现与调用者或者依赖着没有关系，调用者只需要知道他需要调用的方法即可，其他一概不管。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、单一职责&quot;&gt;&lt;a href=&quot;#1、单一职责&quot; class=&quot;headerlink&quot; title=&quot;1、单一职责&quot;&gt;&lt;/a&gt;1、单一职责&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;就一个类而言，应该仅有一个引起它变化的原因，一个类中，应该是一组相关性很高的函数、数据的封装
      
    
    </summary>
    
    
  </entry>
  
</feed>
